GTDB:CONT:
	BVER:UI32:1
	BTIM:UI64:1484723612385978
	TSKS:CONT:
		BCMT:CONT:
			0001:CSTR:"-- Bundle Commit Task\n-- Version 1\n\nfunction commitBundles(path)\n\x09local result = 1\n\x09local reason = OID_GRIDTASK_MSG_NONE\n\x09\n\x09for data in taskParams:datas(path) do\n\x09\x09data:set_name('AAPC')\n\x09\x09result,reason = executeOnOneActor('BCMN', 'BCMT', data)\n\x09\x09if(result ~= 1) then\n\x09\x09\x09Debug.log(\"warn\",\"Exiting bundle-commit loop, reason =\",reason)\n\x09\x09\x09break\n\x09\x09end\n\x09end\n\n\x09return result,reason\nend\n\nfunction gtPrepare()\n\x09pushAbort(\"taskFinished()\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09pushAbort(\"getLocks({})\")\n\x09addStage(\"getLocks({['GRID-BUNDLE'] = true})\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_BUNDLE_COMMIT)\")\n\x09addStage(\"commitBundles('/')\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"getLocks({})\")\n\x09popAbort() -- RLOK\n\x09\n\x09--------------------------------------------------------------------------------\n\x09popAbort()\n\x09\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n\x09addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\nend\n"
		END
		BDLI:CONT:
			0001:CSTR:"-- Bundle Import Task\n-- Version 1\n\nfunction addBundles(path)\n\x09local result = 1\n\x09local reason = OID_GRIDTASK_MSG_NONE\n\x09\n\x09for data in taskParams:datas(path) do\n\x09\x09data:set_name('AAPC')\n\x09\x09result,reason = executeOnOneActor('BCMN', 'BDLI', data)\n\x09\x09if(result ~= 1) then\n\x09\x09\x09Debug.log(\"warn\",\"Exiting bundle-import loop, reason =\",reason)\n\x09\x09\x09break\n\x09\x09end\n\x09end\n\n\x09return result,reason\nend\n\nfunction gtPrepare()\n\x09pushAbort(\"taskFinished()\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09pushAbort(\"getLocks({})\")\n\x09addStage(\"getLocks({['GRID-BUNDLE'] = true})\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_BUNDLE_IMPORT)\")\n\x09addStage(\"addBundles('/')\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"getLocks({})\")\n\x09popAbort() -- RLOK\n\x09\n\x09--------------------------------------------------------------------------------\n\x09popAbort()\n\x09\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n\x09addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\nend\n"
		END
		CCLE:CONT:
			0001:CSTR:"-- Nodetool cleanup task\n-- Version 1\n\nfunction waitForNewDDS(nid, value)\n        -- See if DDS is in the expected state\n        local function checkDone(nid, status)\n            return status:data(\"STCR\") == value\n        end\n        return waitOnActors(nid, 'DDSS', AtomContainer.new{'CHPC'}, checkDone, true)\nend\n\nfunction gtPrepare()\n    pushAbort(\"taskFinished()\")\n    addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n    pushAbort(\"getLocks({})\")\n\n    ---------------------------------------------------------------------------\n    --Check whether the new DDSs are in the expected state: cassandra up running\n    for nid in taskParams:datas(\"/NDDS\") do\n        addStage(\"stageName(OID_GRIDTASK_STAGE_CHECKING_CASSANDRA_STATUS..': '..OID_GRIDTASK_MSG_NID..' \"..nid..\"')\")\n        addStage(\"waitForNewDDS(\"..nid..\", 'REDY')\")\n    end\n\n    ---------------------------------------------------------------------------\n    -- Perform Cassandra node cleanup sequentially in old DDS nodes.\n    for nid in taskParams:datas(\"/ODDS\") do\n        addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n        addStage(\"getLocks({['\"..nid..\"-NODETOOL'] = true})\")\n        pushAbort(\"stopAction(\"..nid..\", 'CCLE', gtActPc)\")\n        addStage(\"startAction(\"..nid..\", 'CCLE', gtActPc)\")\n        addStage(\"stageName(OID_GRIDTASK_STAGE_RUNNING_NODETOOL_CLEAN_UP..': '..OID_GRIDTASK_MSG_NID..' \"..nid..\"')\")\n        addStage(\"waitDone(\"..nid..\", 'CCLE', gtActPc)\")\n    end\n    ---------------------------------------------------------------------------\n    addStage(\"getLocks({})\")\n    popAbort() -- RLOK\n\n    for nid in taskParams:datas(\"/ODDS\") do\n        popAbort() -- stopAction abortCCLE\n    end\n\n    popAbort()\n\n    addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n    addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\n\x09gtActPc = AtomContainer.new{'AAPC', TKID={ui32=taskId}}\nend\n"
		END
		CDBR:CONT:
			0001:CSTR:"-- CMS Database Recovery Grid Task\n-- Version 1\n\nfunction abortCDBR()\n\x09-- Helper function to clean up a recovery task\n\x09local res,reas\n\n\x09Debug.log(\"warn\",\"Stopping CMS action\")\n\x09for _,nid in pairs(gtCmsList) do\n\x09\x09res,reas = stopAction(nid,'CDBA',gtActPc)\n\x09\x09if(res ~= 1) then\n\x09\x09\x09return 0,reas\n\x09\x09end\n\x09end\n\n\x09return 1,\"OK\"\nend\n\nfunction gtPrepare()\n\x09-- Called once, the first time that the task is run. \n\x09\n\x09pushAbort(\"taskFinished()\")\n\n\x09pushAbort(\"abortCDBR()\")\n\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09pushAbort(\"getLocks({})\")\n\x09addStage(\"getLocks({['\"..gtTargetCms..\"-TASK-CDBR'] = true})\")\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_STARTING)\")\n\x09Debug.log(\"info\", \"NID = \", gtTargetCms)\n\x09\x09\n\x09for _,nid in pairs(gtCmsList) do\n\x09\x09Debug.log(\"info\", \"NID = \", nid)\n\x09\x09addStage(\"stopAction(\"..nid..\",'CDBA',gtActPc)\")\n\x09end\n\x09\x09\n\x09for _,nid in pairs(gtCmsList) do\n\x09\x09addStage(\"startAction(\"..nid..\",'CDBA',gtActPc)\")\n\x09end\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_CMS_DATABASE_RECOVERY..': '..OID_GRIDTASK_MSG_NID..' \"..gtTargetCms..\"')\")\n\x09addStage(\"waitDone(gtCmsList, 'CDBA', gtActPc)\")\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_FINISHING)\")\n\x09for _,nid in pairs(gtCmsList) do\n\x09\x09addStage(\"stopAction(\"..nid..\",'CDBA',gtActPc)\")\n\x09end\n\x09\x09\n\x09addStage(\"getLocks({})\")\n\x09popAbort() -- RLOK\n\x09\n\x09popAbort() -- abortCDBR()\n\x09\n\x09popAbort()\n\x09\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n\x09addStage(\"taskFinished()\")\n\x09\n\x09-- FIXME - Save bundle to GTEN.\nend\n\x09\x09\x09\x09\nfunction gtInit()\n\x09-- Called every time that the task is run (first time, as well as after any CMN restart). \n\n\x09gtTargetCms = taskParams:data('/NOID')\n\x09\n\x09gtActPc = AtomContainer.new{'AAPC', NOID = {ui32 = gtTargetCms} }\n\x09gtCmsList = cacheLoadList('CMSL')\n\x09\n\x09if(gtCmsList == nil) then\n\x09\x09gtCmsList  = coFindActors('BCMS')\n\x09\x09cacheStoreList('CMSL',gtCmsList)\n\x09end\nend\n"
		END
		CDCM:CONT:
			0001:CSTR:"-- CMS Decommissioning Task\n-- Version 1\nfunction revokeCert(nid)\n--  return executeOnOneActor('BADC', 'ADBP', AtomContainer.new{'AAPC', DLVL = 'NOTE', DSTR = \"Revoking cert for \"..nid})\n    return executeOnOneActor('BADC', 'CRVK', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})\nend\n\nfunction removeEntity(oid)\n    return executeOnOneActor('BCMN', 'ANER', AtomContainer.new{'AAPC', EOID = {cstr = oid}})\nend\n\nfunction setOwnerMapping(ocms, ncms)\n    return executeOnOneActor('BDDS', 'COWR', AtomContainer.new{'AAPC', NIDS={ui32=ocms},  NIDD={ui32=ncms}})\nend\n\nfunction setServiceState(nid, value)\n    return executeOnActors(nid, 'SVST', AtomContainer.new{'AAPC', SVST={fc32=value}})\nend\n\nfunction setAuditState(nid, value)\n    return executeOnActors(nid, 'AUDT', AtomContainer.new{'AAPC', AUDT={fc32=value}})\nend\n\nfunction waitAudit(nid, value)\n    local function checkDone(nid, status)\n        return status:data(\"AQSZ\") == UINT64.new(0)\n    end\n    return waitOnActors(nid, 'AUDQ', AtomContainer.new{'CHPC'}, checkDone)\nend\n\nfunction removeNode(nid, device)\n    return executeOnOneActor('BCMN', 'UNOD', AtomContainer.new{'AAPC', NOID = {ui32 = nid}, DTYP = {fc32 = device}})\nend\n\nfunction filterCmsList(nid)\n    for i=#cmsList,1,-1 do\n        if (nid == cmsList[i]) then\n            table.remove(cmsList, i)\n        end\n    end\nend\n\nfunction gtPrepare()\n    -- Called once, the first time that the task is run.\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n    addStage(\"getLocks({['BCMS-TOPOLOGY'] = true})\")\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_STARTING)\")\n\n    for nid in taskParams:datas(\"/NOID\") do\n        filterCmsList(nid)\n    end\n\n    if(table.getn(cmsList) > 0) then\n\n        for nid in taskParams:datas(\"/NOID\") do\n            local newCms = cmsList[ math.random(table.getn(cmsList)) ]\n            addStage(\"setOwnerMapping(\"..nid..\", \"..newCms..\" )\")\n        end\n\n        addStage(\"stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)\")\n        for nid in taskParams:datas(\"/NOID\") do\n            addStage(\"setServiceState(\"..nid..\", 'DABL')\")\n        end\n\n        -- TODO: CMS doesn't support these actions/checks yet.\n        --       Uncomment when story B-25861 is implemented.\n        -- addStage(\"stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)\")\n        -- for nid in taskParams:datas(\"/NOID\") do\n        --     addStage(\"setAuditState(\"..nid..\", 'DABL')\")\n        --     addStage(\"waitAudit(\"..nid..\", 'DABL')\")\n        -- end\n\n        addStage(\"stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)\")\n        for nid in taskParams:datas(\"/NOID\") do\n            addStage(\"revokeCert(\"..nid..\")\")\n        end\n\n        addStage(\"stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)\")\n        for eoid in taskParams:datas(\"/EOID\") do\n            addStage(\"removeEntity('\"..eoid..\"')\")\n        end\n\n        addStage(\"stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)\")\n        for nid in taskParams:datas(\"/NOID\") do\n            addStage(\"removeNode(\"..nid..\", 'BCMS')\")\n        end\n\n        addStage(\"getLocks({})\")\n\n        addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n        addStage(\"taskFinished()\")\n    else\n        Debug.log(\"err\",\"Owner mapping failed. No running CMS\")\n    end\nend\n\nfunction gtInit()\n    -- Called every time that the task is run (first time, as well as after any CMN restart).\n    gtActPc = AtomContainer.new{'AAPC'}\n    cmsList = actorsToList('BCMS', true)\nend\n"
		END
		CEXP:CONT:
			0001:CSTR:"-- Cassandra Site Expansion task\n-- Version 1\nfunction alterKeyspace(grps)\n    return executeOnOneActor('BDDS', 'AKEY', AtomContainer.new{'AAPC', GRPS = {ui32 = grps}})\nend\n\nfunction gtPrepare()\n    pushAbort(\"taskFinished()\")\n    addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n    pushAbort(\"getLocks({})\")\n    ---------------------------------------------------------------------------\n    addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n    addStage(\"getLocks({['GRID-CEXP'] = true})\")\n\n    for grps in taskParams:datas(\"/GRPS\") do\n        if grps then\n            addStage(\"stageName(OID_GRIDTASK_STAGE_ALTER_KEYSPACE..' Group(\"..grps..\")')\")\n            addStage(\"alterKeyspace('\"..grps..\"')\")\n        end\n    end\n    ---------------------------------------------------------------------------\n    addStage(\"getLocks({})\")\n    popAbort() -- RLOK\n    popAbort()\n\n    addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n    addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\n    gtActPc = AtomContainer.new{'AAPC'}\nend\n"
		END
		CSRC:CONT:
			0001:CSTR:"-- Content Migration Cleanup Task\n-- Used to clean up after a corrupted volume is detected during a content migration stage of a hardware refresh task.\n-- Based on CSRF-1 task. Does all it does, except doesn't do the content migrate, \n--   and instead sends a CLOC_LOST for all objects on the source LDR\n-- Version 1\n\n--Storage Maintenance Mode\nfunction actionSMNT(ldr,value)\n\x09return executeOnActors(ldr, 'SMNT', AtomContainer.new{'AAPC', SMNT={fc32=value}})\nend\n\nfunction actionCLDQ(ldr,value)\n\x09return executeOnActors(ldr, 'CLDQ', AtomContainer.new{'AAPC', FRWD={fc32=value}})\nend\n\nfunction disableCLOCLOSTForwarding(ldr)\n\x09return actionCLDQ(ldr, 'DABL')\nend\n\nfunction enableCLOCLOSTForwarding(ldr)\n\x09return actionCLDQ(ldr, 'ENBL')\nend\n\n--Set Storage State\nfunction actionSTDS(ldr,value)\n\x09return executeOnActors(ldr, 'STDS', AtomContainer.new{'AAPC', STDS={fc32=value}})\nend\n\n--Storage State\nfunction waitSTCR(ldr,value)\n\x09-- See if Storage is in the expected state\n\x09local function checkDone(nid, status)\n\x09\x09return status:data(\"STUS\") == 'NONE' and\n\x09\x09\x09status:data(\"STCR\") == value\n\x09end\n\x09\n\x09return waitOnActors(ldr, 'STCR', AtomContainer.new{'CHPC'}, checkDone)\nend\n\nfunction cmsRemap(from, to, action, skipNode)\n\x09-- Called for both the LDR-remapping and CMS-remapping actions.\n\x09\n\x09local actPc = AtomContainer.new{'AAPC', SNID = {ui32 = from} ,DNID = {ui32 = to} }\n\x09\n\x09local cmsList = { }\n\x09local tmpList = coFindActors('BCMS')\n\x09\n\x09local seq = 1\n\x09for _,nid in pairs(tmpList) do\n\x09\x09-- The now-revoked gtSourceCms node ID may still show up in the coFindActors query response, and must be filtered here.\n\x09\x09\n\x09\x09if(nid ~= skipNode) then\n\x09\x09\x09cmsList[seq] = nid\n\x09\x09\x09seq = seq + 1\n\x09\x09else\n\x09\x09\x09Debug.log(\"note\",\"Excluding NID \"..skipNode..\"from coFindActors() response\")\n\x09\x09end\n\x09end\n\n\x09return executeOnActors(cmsList, action, actPc)\nend\n\nfunction revokeCert(nid)\n\x09return executeOnOneActor('BADC', 'CRVK', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})\nend\n\nfunction removeEntity(oid)\n\x09return executeOnOneActor('BCMN', 'ANER', AtomContainer.new{'AAPC', EOID = {cstr = oid}})\nend\n\nfunction setServiceState(nid, value)\n\x09return executeOnActors(nid, 'SVST', AtomContainer.new{'AAPC', SVST={fc32=value}})\nend\n\nfunction setAuditState(nid, value)\n\x09return executeOnActors(nid, 'AUDT', AtomContainer.new{'AAPC', AUDT={fc32=value}})\nend\n\nfunction waitAudit(nid, value)\n\x09local function checkDone(nid, status)\n\x09\x09return status:data(\"AQSZ\") == UINT64.new(0)\n\x09end\n\x09return waitOnActors(nid, 'AUDQ', AtomContainer.new{'CHPC'}, checkDone)\nend\n\nfunction removeGrade(nid)\n\x09return executeOnOneActor('BCMN', 'USTG', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})\nend\n\nfunction removeNode(nid, device)\n\x09return executeOnOneActor('BCMN', 'UNOD', AtomContainer.new{'AAPC', NOID = {ui32 = nid}, DTYP = {fc32 = device}})\nend\n\nfunction checkOnline(nid)\n\x09-- Uses the \"Version Check\" check to make sure that the target node is reachable. Doesn't care about the actual version.\n\x09\n\x09local resp = postCheckAsk(nid, 'CSWV', AtomContainer.new{'CHPC'})\n\n\x09if(resp:data('/RSLT') == 'SUCS') then\n\x09\x09return 1, \"OK\"\n\x09else\n\x09\x09return 0, OID_GRIDTASK_MSG_CHECK_FAILED..\" - \"..OID_GRIDTASK_MSG_NID..\" \"..nid\n\x09end\n\nend\n\nfunction checkTargetExists(nid, dtype)\n\x09-- FIXME - This is inefficient; replace with a direct \"certificate lookup\" check once a proper Certificate grid service has been implemented.\n\x09\n\x09exists = false\n\x09\n\x09tmpList = coFindActors(dtype)\n\x09\n\x09for _,foundnid in pairs(tmpList) do\n\x09\x09if(nid == foundnid) then\n\x09\x09\x09exists = true\n\x09\x09end\n\x09end\n\x09\n\x09if(exists) then\n\x09\x09return 1, \"OK\"\n\x09else\n\x09\x09return 0, OID_GRIDTASK_MSG_NOID_NOT_FOUND..nid\x09\n\x09end\nend\n\nfunction sendObjectLost(ldr)\n\x09return executeOnOneActor('BLDR', 'OLOA', AtomContainer.new{'AAPC', SNID = {ui32 = ldr}})\nend\n\nfunction gtPrepare()\n\x09-- Called once, the first time that the task is run. \n\n\x09pushAbort(\"taskFinished()\")\n\x09\n\x09-- Make sure that DLDR and DCMS (if specified) exist in the grid. This is done before the topology lock\n\x09-- is acquired, so that it's still possible for the user to recover if he/she forgot to run the expansion tasks\n\x09-- before starting this Cleanup task.\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_VERIFY_TARGETS_EXIST)\")\n\x09\n\x09if (gtDestCms) then\n\x09\x09addStage(\"checkTargetExists(\"..gtDestCms..\",'BCMS')\")\n\x09end\n\x09\n\x09if (gtDestLdr) then\n\x09\x09addStage(\"checkTargetExists(\"..gtDestLdr..\",'BLDR')\")\n\x09end\n\x09\n\x09popAbort()\x09-- Abort not permitted beyond this point\n\x09\x09\n\x09if gtSourceLdr then\n\x09\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09\x09addStage(\"getLocks({['\"..gtDestLdr..\"-STORAGE'] = true})\")\n\x09\x09\n\x09\x09addStage(\"stageName(OID_GRIDTASK_STAGE_STORAGE_STATE_WAIT)\")\n\x09\x09addStage(\"waitSTCR(\"..gtDestLdr..\",'READ')\")\n\n\x09\x09addStage(\"disableCLOCLOSTForwarding(\"..gtDestLdr..\")\")\n\n\x09\x09addStage(\"stageName(OID_GRIDTASK_STAGE_SEND_OBJECT_LOST)\")\n\x09\x09addStage(\"sendObjectLost(\"..gtSourceLdr..\")\")\n\x09\x09\n\x09\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09\x09addStage(\"getLocks({['\"..gtDestLdr..\"-STORAGE'] = true, ['BCMS-TOPOLOGY'] = false})\")\n\n\x09\x09addStage(\"stageName(OID_GRIDTASK_STAGE_CONTENT_REMAP)\")\n\x09\x09addStage(\"cmsRemap(\"..gtSourceLdr..\",\"..gtDestLdr..\", 'LRMP', gtSourceCms)\")\n\x09\x09addStage(\"getLocks({['\"..gtDestLdr..\"-STORAGE'] = true})\")\n\n\x09\x09addStage(\"enableCLOCLOSTForwarding(\"..gtDestLdr..\")\")\n\n\x09\x09addStage(\"stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)\")\n\x09\x09addStage(\"actionSTDS(\"..gtDestLdr..\",'RDWR')\")\n\x09end\n\x09\n\x09local sourceNodes = {BADC = gtSourceAdc, BSSM = gtSourceSsm}\n\x09\n\x09local locks = \"['GRID-BUNDLE'] = true\"\n\x09for nodeType, nid in pairs(sourceNodes) do\n\x09\x09locks = locks..\", ['\"..nodeType..\"-TOPOLOGY'] = true\"\n\x09end\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09addStage(\"getLocks({\"..locks..\"})\")\n\x09\n\x09for nodeType, nid in pairs(sourceNodes) do\n\x09\x09addStage(\"stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)\")\n\x09\x09addStage(\"setServiceState(\"..nid..\", 'DABL')\")\n\x09\x09\n\x09\x09addStage(\"stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)\")\n\x09\x09addStage(\"setAuditState(\"..nid..\", 'DABL')\")\n\x09\x09addStage(\"waitAudit(\"..nid..\")\")\n\x09end\n\x09\n\x09local revokeNodes = {BLDR = gtSourceLdr, BADC = gtSourceAdc, BSSM = gtSourceSsm}\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)\")\n\x09for nodeType, nid in pairs(revokeNodes) do\n\x09\x09addStage(\"revokeCert(\"..nid..\")\")\n\x09end\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)\")\n\x09addStage(\"removeEntity('\"..gtSourceOid..\"')\")\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)\")\n\x09\n\x09for nodeType, nid in pairs(revokeNodes) do\n\x09\x09addStage(\"removeNode(\"..nid..\", '\"..nodeType..\"')\")\n\x09end\n\x09\n\x09if gtSourceLdr then\n\x09\x09addStage(\"stageName(OID_GRIDTASK_STAGE_GRADE_REMOVE)\")\n\x09\x09addStage(\"removeGrade(\"..gtSourceLdr..\")\")\n\x09end\n\x09\n\x09addStage(\"getLocks({})\")\n\x09\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n\x09addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\n\x09-- Called every time that the task is run (first time, as well as after any CMN restart). \n\n\x09-- Depending on the node type, some of these may be null. \n\x09gtSourceLdr = taskParams:data('/SLDR')\n\x09gtDestLdr = taskParams:data('/DLDR')\n\x09gtSourceCms = taskParams:data('/SCMS')\n\x09gtDestCms = taskParams:data('/DCMS')\n\x09\n\x09gtSourceAdc = taskParams:data('/SADC')\x09-- No \"Dest\" needed for ADC and SSM; just decommission the Src nodes\n\x09gtSourceSsm = taskParams:data('/SSMN')\n\x09\n\x09gtSourceOid = taskParams:data('/EOID')\x09-- OID for the server\n\x09\n\x09if gtDestLdr then\n\x09\x09gtActPc = AtomContainer.new{'AAPC', DNID = {ui32 = gtDestLdr} }\n\x09end\nend\n"
		END
		CSRF:CONT:
			0001:CSTR:"-- Control/Storage Hardware Refresh Task (replaces LMIG)\n-- When splitting a combo-node ([A]GCSN) this task must be run after the Admin/Gateway ones.\n-- Version 1\n\nfunction actionSMNT(ldr,value)\n    return executeOnActors(ldr, 'SMNT', AtomContainer.new{'AAPC', SMNT={fc32=value}})\nend\n\nfunction actionCLDQ(ldr,value)\n    return executeOnActors(ldr, 'CLDQ', AtomContainer.new{'AAPC', FRWD={fc32=value}})\nend\n\nfunction disableCLOCLOSTForwarding(ldr)\n    return actionCLDQ(ldr, 'DABL')\nend\n\nfunction enableCLOCLOSTForwarding(ldr)\n    return actionCLDQ(ldr, 'ENBL')\nend\n\nfunction actionSTDS(ldr,value)\n    return executeOnActors(ldr, 'STDS', AtomContainer.new{'AAPC', STDS={fc32=value}})\nend\n\nfunction waitSTCR(ldr,value)\n    -- See if Storage is in the expected state\n    local function checkDone(nid, status)\n        return status:data(\"STUS\") == 'NONE' and\n            status:data(\"STCR\") == value\n    end\n\n    return waitOnActors(ldr, 'STCR', AtomContainer.new{'CHPC'}, checkDone)\nend\n\nfunction getCMSnodeIDs(gndsAtomContainer)\n    if gndsAtomContainer == nil then\n\n        -- Don't core dump. Just return an empty CMS node ID list.\n        Debug.log(\"warn\", \"Error: gndsAtomContainer is nil.\")\n        return {}\n    end\n\n    local nids = gndsAtomContainer:data(\"/GNID/AVAL\")\n    local types = gndsAtomContainer:data(\"/GNTP/AVAL\")\n\n    if nids == nil or types == nil then\n        Debug.log(\"warn\", \"Error: Node ID and/or node type information missing from cached GNDS bundle.\")\n        return {}\n    end\n\n    local numNids = nids:length()\n    local numTypes = types:length()\n\n    if numNids ~= numTypes then\n        Debug.log(\"warn\",\"Error: Number of node IDs does not match number of node types.\")\n        return nil\n    end\n\n    local cmsids = {}\n\n    for num = 2,numNids do\n        local nid = gndsAtomContainer:data(\"/GNID/AVAL\"):data(num)\n        local typ = gndsAtomContainer:data(\"/GNTP/AVAL\"):data(num)\n\n        if typ == \"BCMS\" then\n            table.insert(cmsids, nid)\n        end\n    end\n\n    return cmsids\nend\n\nfunction elementInTable(element, table)\n    if element == nil or table == nil then\n        return false\n    end\n\n    for _,v in pairs(table) do\n        if v == element then\n            return true\n        end\n    end\n\n    return false\nend\n\nfunction cmsRemap(from, to, action, skipNode)\n    -- Called for both the LDR-remapping and CMS-remapping actions.\n    \n    local actPc = AtomContainer.new{'AAPC', SNID = {ui32 = from} ,DNID = {ui32 = to} }\n\n    local cmsList = { }\n    local tmpList = coFindActors('BCMS')\n\n    local gndsAtomCont = Module.getatom():data(\"/conf/GNDS\")\n\n    local gndsCMSids = getCMSnodeIDs(gndsAtomCont)\n\n    local seq = 1\n    for _,nid in pairs(tmpList) do\n        -- The now-revoked gtSourceCms node ID may still show up in the coFindActors query response, and must be filtered here.\n\n        if(nid ~= skipNode and elementInTable(nid, gndsCMSids)) then\n            cmsList[seq] = nid\n            seq = seq + 1\n        else\n            Debug.log(\"note\",\"Excluding NID \"..skipNode..\"from coFindActors() response\")\n        end\n    end\n\n    return executeOnActors(cmsList, action, actPc)\nend\n\nfunction revokeCert(nid)\n    return executeOnOneActor('BADC', 'CRVK', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})\nend\n\nfunction removeEntity(oid)\n    return executeOnOneActor('BCMN', 'ANER', AtomContainer.new{'AAPC', EOID = {cstr = oid}})\nend\n\nfunction setServiceState(nid, value)\n    return executeOnActors(nid, 'SVST', AtomContainer.new{'AAPC', SVST={fc32=value}})\nend\n\nfunction setAuditState(nid, value)\n    return executeOnActors(nid, 'AUDT', AtomContainer.new{'AAPC', AUDT={fc32=value}})\nend\n\nfunction waitAudit(nid, value)\n    local function checkDone(nid, status)\n        return status:data(\"AQSZ\") == UINT64.new(0)\n    end\n    return waitOnActors(nid, 'AUDQ', AtomContainer.new{'CHPC'}, checkDone)\nend\n\nfunction removeGrade(nid)\n    return executeOnOneActor('BCMN', 'USTG', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})\nend\n\nfunction removeNode(nid, device)\n    return executeOnOneActor('BCMN', 'UNOD', AtomContainer.new{'AAPC', NOID = {ui32 = nid}, DTYP = {fc32 = device}})\nend\n\nfunction checkOnline(nid)\n    -- Uses the \"Version Check\" check to make sure that the target node is reachable. Doesn't care about the actual version.\n\n    local resp = postCheckAsk(nid, 'CSWV', AtomContainer.new{'CHPC'})\n\n    if(resp:data('/RSLT') == 'SUCS') then\n        return 1, \"OK\"\n    else\n        return 0, OID_GRIDTASK_MSG_CHECK_FAILED..\" - \"..OID_GRIDTASK_MSG_NID..\" \"..nid\n    end\n\nend\n\nfunction checkTargetExists(nid, dtype)\n    -- FIXME - This is inefficient; replace with a direct \"certificate lookup\" check once a proper Certificate grid service has been implemented.\n\n    exists = false\n\n    tmpList = coFindActors(dtype)\n\n    for _,foundnid in pairs(tmpList) do\n        if(nid == foundnid) then\n            exists = true\n        end\n    end\n\n    if(exists) then\n        return 1, \"OK\"\n    else\n        return 0, OID_GRIDTASK_MSG_NOID_NOT_FOUND..nid\n    end\nend\n\nfunction gtPrepare()\n    -- Called once, the first time that the task is run.\n\n    pushAbort(\"taskFinished()\")\n\n    -- Make sure that DLDR and DCMS (if specified) exist in the grid. This is done before the topology lock\n    -- is acquired, so that it's still possible for the user to recover if he/she forgot to run the expansion tasks\n    -- before starting this Refresh task.\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_VERIFY_TARGETS_EXIST)\")\n\n    if (gtDestCms) then\n        addStage(\"checkTargetExists(\"..gtDestCms..\",'BCMS')\")\n    end\n\n    if (gtDestLdr) then\n        addStage(\"checkTargetExists(\"..gtDestLdr..\",'BLDR')\")\n    end\n\n    popAbort()  -- Abort not permitted during CMS migration\n\n    if gtSourceCms then\n        addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n        addStage(\"getLocks({['\"..gtSourceCms..\"-STORAGE'] = true, ['\"..gtDestCms..\"-STORAGE'] = true, ['BCMS-TOPOLOGY'] = true, ['CMS-REMAP'] = true})\")\n        \n        addStage(\"stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)\")\n        addStage(\"setServiceState(\"..gtSourceCms..\", 'DABL')\")  -- Stop client services\n        addStage(\"cmsRemap(\"..gtSourceCms..\",\"..gtDestCms..\", 'CRMP', gtDestCms)\")\n        addStage(\"getLocks({['\"..gtSourceCms..\"-STORAGE'] = true, ['\"..gtDestCms..\"-STORAGE'] = true, ['BCMS-TOPOLOGY'] = true})\")\n\n        -- Note - Audit is not flushed because database gets migrated to DestCMS. Expected that any queued audit\n        -- messages will be flushed by the new node, even if they were generated by the old node.\n\n        -- Pause the task and instruct the user to run the cms-refresh.sh script \n        addStage(\"stageName(OID_GRIDTASK_STAGE_CMS_MIGRATION)\")     \n        addStage(\"waitUser(OID_GRIDTASK_MSG_CLONE_CMS_DB)\") \n        \n        addStage(\"stageName(OID_GRIDTASK_STAGE_FINISH_CMS_MIGRATION)\")  \n        addStage(\"checkOnline(\"..gtDestCms..\")\")\n        addStage(\"checkIfIdInGNDS(\"..gtDestCms..\")\")\n\n        addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n        addStage(\"getLocks({['\"..gtSourceCms..\"-STORAGE'] = true, ['BCMS-TOPOLOGY'] = true, ['GRID-BUNDLE'] = true})\")\n\n        addStage(\"stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)\")\n        addStage(\"revokeCert(\"..gtSourceCms..\")\") -- Revoked here so that it is not targeted in the following cmsRemap action\n\n        addStage(\"stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)\")\n        addStage(\"removeNode(\"..gtSourceCms..\", 'BCMS')\")\n    end\n\n    if gtSourceLdr then\n        addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n        addStage(\"getLocks({['\"..gtSourceLdr..\"-STORAGE'] = true, ['\"..gtDestLdr..\"-STORAGE'] = true})\")\n\n        addStage(\"stageName(OID_GRIDTASK_STAGE_STORAGE_STATE_WAIT)\")\n        addStage(\"waitSTCR(\"..gtDestLdr..\",'READ')\")\n\n        pushAbort(\"taskFinished()\")\n        pushAbort(\"enableCLOCLOSTForwarding(\"..gtDestLdr..\")\")\n        addStage(\"disableCLOCLOSTForwarding(\"..gtDestLdr..\")\")\n\n        addStage(\"actionSMNT(\"..gtSourceLdr..\",'ENBL')\")\n\n        pushAbort(\"getLocks({})\")\n        \n        addStage(\"stageName(OID_GRIDTASK_STAGE_CONTENT_MIGRATE)\")\n        pushAbort(\"stopAction(\"..gtSourceLdr..\",'LMIG',gtActPc)\")\n        addStage(\"startAction(\"..gtSourceLdr..\",'LMIG',gtActPc)\")\n        addStage(\"waitDone(\"..gtSourceLdr..\", 'LMIG', gtActPc)\")\n        addStage(\"stopAction(\"..gtSourceLdr..\",'LMIG',gtActPc)\")\n\n        popAbort() -- remove locks\n        popAbort() -- enableCLOCLOSTForwarding\n        popAbort() -- abort not permitted beyond this point. \n\n        addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n        addStage(\"getLocks({['\"..gtSourceLdr..\"-STORAGE'] = true, ['\"..gtDestLdr..\"-STORAGE'] = true, ['BCMS-TOPOLOGY'] = false, ['CMS-REMAP'] = true})\")\n\n        addStage(\"stageName(OID_GRIDTASK_STAGE_CONTENT_REMAP)\")\n        addStage(\"cmsRemap(\"..gtSourceLdr..\",\"..gtDestLdr..\", 'LRMP', gtSourceCms)\")\n        addStage(\"getLocks({['\"..gtSourceLdr..\"-STORAGE'] = true, ['\"..gtDestLdr..\"-STORAGE'] = true})\")\n\n        -- enableCLOCLOSTForwarding\n        addStage(\"enableCLOCLOSTForwarding(\"..gtDestLdr..\")\")\n\n        addStage(\"stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)\")\n        addStage(\"actionSTDS(\"..gtDestLdr..\",'RDWR')\")\n        addStage(\"actionSTDS(\"..gtSourceLdr..\",'OFLN')\")\n    end\n\n    -- Using this way of creating a list of nodeTypes mapped to nodeIds and using ipairs() because unit tests expect ordering which\n    -- pairs() doesn't guarantee.\n    local ldrSource = {nt = 'BLDR', nid = gtSourceLdr}\n    local adcSource = {nt = 'BADC', nid = gtSourceAdc}\n    local ssmSource = {nt = 'BSSM', nid = gtSourceSsm}\n    local ddsSource = {nt = 'BDDS', nid = gtSourceDds}\n\n    local sourceNodes = {}\n\n    if(gtSourceLdr) then\n        table.insert(sourceNodes, ldrSource)\n    end\n    if(gtSourceAdc) then\n        table.insert(sourceNodes, adcSource)\n    end\n    if(gtSourceSsm) then\n        table.insert(sourceNodes, ssmSource)\n    end\n    if(gtSourceDds) then\n        table.insert(sourceNodes, ddsSource)\n    end\n\n    if (gtSourceDds) then\n        addStage(\"stopAction(\"..gtSourceDds..\", 'CCLE', AtomContainer.new{'AAPC'})\")\n        addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n        addStage(\"getLocks({['\"..gtSourceDds..\"-NODETOOL'] = true, ['NODETOOL_DECOMMISSION'] = true})\")\n\n        addStage(\"stageName(OID_GRIDTASK_STAGE_CASSANDRA_NODETOOL_DECOMMISSION)\")\n        addStage(\"startAction(\"..gtSourceDds..\", 'NDEC', AtomContainer.new{'AAPC', NOID = {ui32 = \"..gtSourceDds..\"}})\")\n        addStage(\"waitDone(\"..gtSourceDds..\", 'NDEC', gtActPc)\")\n    end\n\n\n    local locks = \"['GRID-BUNDLE'] = true\"\n    for _,data in ipairs(sourceNodes) do\n        locks = locks..\", ['\"..data['nt']..\"-TOPOLOGY'] = true\"\n    end\n    if gtSourceLdr then\n        locks = locks..\", ['\"..gtSourceLdr..\"-STORAGE'] = true\"\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n    addStage(\"getLocks({\"..locks..\"})\")\n\n    for _,data in ipairs(sourceNodes) do\n        addStage(\"stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)\")\n        addStage(\"setServiceState(\"..data['nid']..\", 'DABL')\")\n\n        addStage(\"stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)\")\n        addStage(\"setAuditState(\"..data['nid']..\", 'DABL')\")\n        addStage(\"waitAudit(\"..data['nid']..\")\")\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)\")\n    for _,data in ipairs(sourceNodes) do\n        addStage(\"revokeCert(\"..data['nid']..\")\")\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)\")\n    addStage(\"removeEntity('\"..gtSourceOid..\"')\")\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)\")\n\n    for _,data in ipairs(sourceNodes) do\n        addStage(\"removeNode(\"..data['nid']..\", '\"..data['nt']..\"')\")\n    end\n\n    if gtSourceLdr then\n        addStage(\"stageName(OID_GRIDTASK_STAGE_GRADE_REMOVE)\")\n        addStage(\"removeGrade(\"..gtSourceLdr..\")\")\n    end\n\n    addStage(\"getLocks({})\")\n\n    addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n    addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\n    -- Called every time that the task is run (first time, as well as after any CMN restart). \n\n    -- Depending on the node type, some of these may be null. \n    gtSourceLdr = taskParams:data('/SLDR')\n    gtDestLdr = taskParams:data('/DLDR')\n    gtSourceCms = taskParams:data('/SCMS')\n    gtDestCms = taskParams:data('/DCMS')\n\n    gtSourceAdc = taskParams:data('/SADC')  -- No \"Dest\" needed for ADC, SSM & DDS; just decommission the Src nodes\n    gtSourceSsm = taskParams:data('/SSMN')\n    gtSourceDds = taskParams:data('/SDDS')\n\n    gtSourceOid = taskParams:data('/EOID')  -- OID for the server\n\n    if gtDestLdr then\n        gtActPc = AtomContainer.new{'AAPC', DNID = {ui32 = gtDestLdr} }\n    end\nend\n"
		END
		CTNL:CONT:
			0001:CSTR:"-- Object Location Indexing Conversion Grid Task\n-- Version 1\n\nfunction abortCTNL()\n\x09-- Helper function to clean up a conversion task\n\x09local res,reas\n\n\x09Debug.log(\"warn\",\"Stopping CMS action\")\n\x09res,reas = stopAction(gtTargetCms,'CNLT',gtActPc)\n\n\x09if(res ~= 1) then\n\x09\x09return 0,reas\n\x09else\n\x09\x09return 1,\"OK\"\n\x09end\nend\n\nfunction gtPrepare()\n\x09-- Called once, the first time that the task is run. \n\x09\n\x09pushAbort(\"taskFinished()\")\n\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09pushAbort(\"getLocks({})\")\n\x09addStage(\"getLocks({['\"..gtTargetCms..\"-TASK-CTNL'] = true})\")\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_STARTING)\")\n\x09Debug.log(\"info\", \"NID = \", gtTargetCms)\n\x09\n\x09pushAbort(\"abortCTNL()\")\n\x09addStage(\"stopAction(\"..gtTargetCms..\",'CNLT',gtActPc)\")\n\x09\x09\n\x09addStage(\"startAction(\"..gtTargetCms..\",'CNLT',gtActPc)\")\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_OBJECT_LOCATION_INDEXING_CONVERSION)\")\n\x09addStage(\"waitDone(gtTargetCms, 'CNLT', gtActPc)\")\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_FINISHING)\")\n\x09addStage(\"stopAction(\"..gtTargetCms..\",'CNLT',gtActPc)\")\n\x09\x09\n\x09addStage(\"getLocks({})\")\n\x09popAbort() -- RLOK\n\x09\n\x09popAbort() -- abortCTNL()\n\x09\n\x09popAbort()\n\x09\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n\x09addStage(\"taskFinished()\")\n\x09\n\x09-- FIXME - Save bundle to GTEN.\nend\n\x09\x09\x09\x09\nfunction gtInit()\n\x09-- Called every time that the task is run (first time, as well as after any CMN restart). \n\n\x09gtTargetCms = taskParams:data('/NOID')\n\x09\n\x09gtActPc = AtomContainer.new{'AAPC'}\nend\n"
		END
		CUPD:CONT:
			0001:CSTR:"-- Certificate Update Task\n-- Version 1\n\nfunction addCert(nid, certpath, adc)\n\x09local cert = taskParams:data(certpath)\n\x09\n\x09local action = AtomContainer.new{'AAPC', NOID = {ui32 = nid}, CERT = {data = cert}}\n\n\x09if adc then\n\x09\x09return executeOnOneActor('BADC', 'CUPD', action)\n\x09else\n\x09\x09return executeOnActors(nid, 'CUPD', action)\n\x09end\nend\n\nfunction shutdownNode(nid)\n\x09return executeOnActors(nid, 'SHDN', AtomContainer.new{'AAPC', DELY = {ui64 = 10000000}})\nend\n\nfunction gtPrepare()\n\x09pushAbort(\"taskFinished()\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_CERT_UPDATE)\")\n\x09\n\x09for node in taskParams:datas(\"/NODS\") do\n\x09\x09local nid = node:data(\"NOID\")\n\x09\x09local cert = \"/NODS/\"..node:name()..\"/CERT\"\n\x09\x09local mode = node:data(\"MODE\") or \"BOTH\"\n\x09\x09\n\x09\x09if mode == \"BOTH\" then\n\x09\x09\x09-- Update cert on target node\n\x09\x09\x09addStage(\"addCert(\"..nid..\",'\"..cert..\"')\")\n\x09\x09\x09\n\x09\x09\x09-- Shutdown (restart) target node\n\x09\x09\x09addStage(\"shutdownNode(\"..nid..\")\")\n\x09\x09end\n\x09\x09\n\x09\x09-- Update cert on ADC\n\x09\x09addStage(\"addCert(\"..nid..\",'\"..cert..\"',true)\")\n\x09\x09\n\x09end\n\x09\n\x09--------------------------------------------------------------------------------\n\x09popAbort()\n\x09\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n\x09addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\nend\n"
		END
		EBUN:CONT:
			0001:CSTR:"-- Edit Bundles Task\n-- Version 1\n\nfunction editBundle(bundleNumber)\n\n\x09return executeOnOneActor('BCMN', 'EBUN',AtomContainer.new{'AAPC', \n\x09EBUN = taskParams:data(\"/EBUN/\"..bundleNumber)} )\nend\n\nfunction gtPrepare()\n\n\x09pushAbort(\"taskFinished()\")\n\n\x09-------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09pushAbort(\"getLocks({})\")\n\x09addStage(\"getLocks({['GRID-BUNDLE'] = true})\")\n\x09\n\x09-------------------------------------------------------------------------\n\x09for bundle in taskParams:datas(\"/EBUN\") do\n\x09\x09local bundleNumber = bundle:name()\n\x09\x09local bundleName = bundle:data(\"/BLNM\")\n\x09\x09\n\x09\x09addStage(\"stageName(OID_GRIDTASK_STAGE_EDIT_BUNDLE..'(\"..bundleName..\")')\")\n\x09\x09addStage(\"editBundle('\"..bundleNumber..\"')\")\n\n\x09end\n\x09-------------------------------------------------------------------------\n\x09addStage(\"getLocks({})\")\n\x09popAbort() -- RLOK\n\x09\n\x09-------------------------------------------------------------------------\n\x09popAbort()\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n\x09addStage(\"taskFinished()\")\n\x09\nend\n\n\nfunction gtInit()\nend\n"
		END
		ENRM:CONT:
			0001:CSTR:"-- Entity Remove Task\n-- Version 1\n\n\nfunction removeEntity(oid)\n\x09return executeOnOneActor('BCMN', 'ANER', AtomContainer.new{'AAPC', EOID = {cstr = oid}})\nend\n\nfunction gtPrepare()\n\x09-- Called once, the first time that the task is run. \n\x09\n\x09pushAbort(\"taskFinished()\")\n\x09\n\x09-----------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09pushAbort(\"getLocks({})\")\n\x09addStage(\"getLocks({['GRID-BUNDLE'] = true})\")\n\n\x09-----------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)\")\n\n\x09for eoid in taskParams:datas(\"/\") do\n\x09\x09addStage(\"removeEntity('\"..eoid..\"')\")\n\x09end\n\n\x09-----------------------------------------------------------\n\x09addStage(\"getLocks({})\")\n\x09popAbort() -- RLOK\n\x09popAbort()\n\x09\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n\x09addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\n\x09-- Called every time that the task is run (first time, as well as after any CMN restart). \n\x09\nend\n"
		END
		GDCM:CONT:
			0001:CSTR:"-- Generic Node Decommissioning/Refresh Task\n-- Version 1\n\n-- Currently supports the following node types: ADC, AMS, CLB, CMN, NMS, SSM\n-- TODO Support LDR, CMS, ARC\n\nfunction revokeCert(nid)\n   return executeOnOneActor('BADC', 'CRVK', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})\nend\n\nfunction removeEntity(oid)\n   return executeOnOneActor('BCMN', 'ANER', AtomContainer.new{'AAPC', EOID = {cstr = oid}})\nend\n\nfunction setServiceState(nid, value)\n   return executeOnActors(nid, 'SVST', AtomContainer.new{'AAPC', SVST={fc32=value}})\nend\n\nfunction setAuditState(nid, value)\n   return executeOnActors(nid, 'AUDT', AtomContainer.new{'AAPC', AUDT={fc32=value}})\nend\n\nfunction removeAuditRepo(nid)\n   -- Tell all relays to stop enqueueing messages for the specified repository\n   return executeOnActors('BADC', 'RMRP', AtomContainer.new{'AAPC', REPO={ui32=nid}})\nend\n\nfunction waitAudit(nid, value)\n   local function checkDone(nid, status)\n      return status:data(\"AQSZ\") == UINT64.new(0)\n   end\n   return waitOnActors(nid, 'AUDQ', AtomContainer.new{'CHPC'}, checkDone)\nend\n\nfunction waitRelayFlush(nid)\n   local function checkDone(nid, status)\n      return status:data(\"AQSZ\") == UINT64.new(0)\n   end\n   return waitOnActors('BADC', 'AURC', AtomContainer.new{'CHPC', REPO={ui32=nid}}, checkDone)\nend\n\nfunction removeNode(nid, device)\n   return executeOnOneActor('BCMN', 'UNOD', AtomContainer.new{'AAPC', NOID = {ui32 = nid}, DTYP = {fc32 = device}})\nend\n\nfunction waitCmnStandby(nid)\n   -- Wait for CMN to be configured as standby\n   local function checkDone(nid, status)\n      return status:data(\"CMNS\") == 'OFLN'\n   end\n   return waitOnActors(nid, 'CMNS', AtomContainer.new{'CHPC'}, checkDone)\nend\n\nfunction modifyBundle(bundleNumber)\n   return executeOnOneActor('BCMN', 'EBUN', AtomContainer.new{'AAPC', EBUN = taskParams:data(\"/EBUN/\"..bundleNumber)} )\nend\n\nfunction deleteBundle(bundleNumber)\n   return executeOnOneActor('BCMN', 'DBUN', AtomContainer.new{'AAPC', DBUN = taskParams:data(\"/DBUN/\"..bundleNumber)} )\nend\n\nfunction nodeId(node)\n   return node:data(\"/NOID\")\nend\n\nfunction nodeOid(node)\n   return node:data(\"/EOID\")\nend\n\nfunction deviceType(node)\n   return node:data(\"/DTYP\")\nend\n\nfunction bundleToString(bundle)\n   return bundleName(bundle)..\".\"..bundle:data(\"/NMSP\")..\"-\"..bundle:data(\"/NSIN\")\nend\n\nfunction bundleNumber(bundle)\n   return bundle:name()\nend\n\nfunction bundleName(bundle)\n   return bundle:data(\"/BLNM\")\nend\n\nfunction gtPrepare()\n   pushAbort(\"taskFinished()\")\n\n   --------------------------------------------------------------------------------\n   -- Check pre-conditions\n   --------------------------------------------------------------------------------\n\n   --------------------------------------------------------------------------------\n   for node in taskParams:datas(\"/NODS\") do\n      local device = deviceType(node)\n      if device == \"BCMN\" then\n         addStage(\"stageName(OID_GRIDTASK_STAGE_CMN_STATE_WAIT)\")\n         addStage(\"waitCmnStandby(\"..nodeId(node)..\")\")\n      end\n   end\n\n   --------------------------------------------------------------------------------\n   -- Acquire an exclusive TOPOLOGY lock on every device type being decommissioned\n   local locks = \"['GRID-BUNDLE'] = true\"\n   for node in taskParams:datas(\"/NODS\") do\n      local device = deviceType(node)\n      if nodeId(node) then\n         locks = locks..\", ['\"..device..\"-TOPOLOGY'] = true\"\n      end\n   end\n\n   addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n   pushAbort(\"getLocks({})\")\n   addStage(\"getLocks({\"..locks..\"})\")\n   popAbort() -- RLOK\n   popAbort() -- Cannot abort past this point\n\n   --------------------------------------------------------------------------------\n   -- If an AMS is decommissioned, all relay queues for it must be flushed before\n   -- its services are disabled.\n   --------------------------------------------------------------------------------\n   for node in taskParams:datas(\"/NODS\") do\n      if deviceType(node) == 'BAMS' then\n         -- NOTE - RMRP action will fail if there is not at least 1 remaining repository, but\n         -- if this happens here then topology locks will prevent the addition of another AMS.\n\n         addStage(\"stageName(OID_GRIDTASK_STAGE_AUDIT_RELAY_FLUSH)\")\n         addStage(\"removeAuditRepo(\"..nodeId(node)..\")\")\n         addStage(\"waitRelayFlush(\"..nodeId(node)..\")\")\n      end\n   end\n\n   --------------------------------------------------------------------------------\n   -- Execute common decommissioning actions\n   --------------------------------------------------------------------------------\n\n   --------------------------------------------------------------------------------\n   addStage(\"stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)\")\n   for node in taskParams:datas(\"/NODS\") do\n      nid = nodeId(node)\n      if nid then\n         addStage(\"setServiceState(\"..nid..\", 'DABL')\")\n      end\n   end\n\n   --------------------------------------------------------------------------------\n   addStage(\"stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)\")\n   for node in taskParams:datas(\"/NODS\") do\n      -- TODO Support this action on the CMS\n      if deviceType(node) ~= 'BCMS' then\n         nid = nodeId(node)\n         if nid then\n            addStage(\"setAuditState(\"..nid..\", 'DABL')\")\n            addStage(\"waitAudit(\"..nodeId(node)..\")\")\n         end\n      end\n   end\n\n   --------------------------------------------------------------------------------\n   addStage(\"stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)\")\n   for node in taskParams:datas(\"/NODS\") do\n      nid = nodeId(node)\n      if nid then\n         addStage(\"revokeCert(\"..nid..\")\")\n      end\n   end\n\n   --------------------------------------------------------------------------------\n   addStage(\"stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)\")\n   for node in taskParams:datas(\"/NODS\") do\n      local oid = nodeOid(node)\n      if oid then  -- Is this ever not set?\n         addStage(\"removeEntity('\"..oid..\"')\")\n      end\n   end\n\n   --------------------------------------------------------------------------------\n   addStage(\"stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)\")\n   for node in taskParams:datas(\"/NODS\") do\n      nid = nodeId(node)\n      if nid then\n         addStage(\"removeNode(\"..nid..\", '\"..deviceType(node)..\"')\")\n      end\n   end\n\n   --------------------------------------------------------------------------------\n   -- Execute node-specific post-decommissioning actions\n   --------------------------------------------------------------------------------\n   for bundle in taskParams:datas(\"/EBUN\") do\n      addStage(\"stageName(OID_GRIDTASK_STAGE_BUNDLE_DELETEROWS..'(\"..bundleName(bundle)..\")')\")\n      addStage(\"modifyBundle('\"..bundleNumber(bundle)..\"')\")\n   end\n\n   for bundle in taskParams:datas(\"/DBUN\") do\n      addStage(\"stageName(OID_GRIDTASK_STAGE_BUNDLE_DELETE..'(\"..bundleToString(bundle)..\")')\")\n      addStage(\"deleteBundle('\"..bundleNumber(bundle)..\"')\")\n   end\n\n   --------------------------------------------------------------------------------\n   addStage(\"getLocks({})\")\n   addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n   addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\nend\n"
		END
		GEXP:CONT:
			0001:CSTR:"-- Grid Expansion Task\n-- Version 1\n\nfunction addGroup(gid, siteName)\n    return executeOnOneActor('BCMN', 'RGRP',\n        AtomContainer.new{'AAPC', GPID = {ui32 = gid}, GNAM = {cstr = siteName}})\nend\n\nfunction addEntity(path)\n    local eoid = taskParams:data(path..\"/EOID\")\n    local eodm = taskParams:data(path..\"/EODM\")\n    local eodv = taskParams:data(path..\"/EODV\")\n    local eona = taskParams:data(path..\"/EONA\")\n    local elng = taskParams:data(path..\"/ELNG\")\n    local eosi = taskParams:data(path..\"/EOSI\")\n    local eohn = taskParams:data(path..\"/EOHN\")\n\n    return executeOnOneActor('BCMN', 'ANEA',\n        AtomContainer.new{'AAPC', EOID = {cstr = eoid}, EODM = {cstr = eodm}, EODV = {cstr = eodv}, EONA = {ustr = eona}, ELNG = {enum = elng}, EOSI = {cstr = eosi}, EOHN = {cstr = eohn}})\nend\n\nfunction addCert(nid, certpath)\n    local cert = taskParams:data(certpath)\n\n    return executeOnOneActor('BADC', 'CUPD',\n        AtomContainer.new{'AAPC', NOID = {ui32 = nid}, CERT = {data = cert}})\nend\n\nfunction addGrade(nid)\n    return executeOnOneActor('BCMN', 'RSTG',\n        AtomContainer.new{'AAPC', NOID = {ui32 = nid}})\nend\n\nfunction addNmsCluster(ncid, path)\n    local name = taskParams:data(path..\"/NMCN\")\n    return executeOnOneActor('BCMN', 'RNMS',\n        AtomContainer.new{'AAPC', NMCI = {ui32 = ncid}, NMCN = {ustr = name}})\nend\n\nfunction addBundles(path)\n    local result = 1\n    local reason = OID_GRIDTASK_MSG_NONE\n\n    for data in taskParams:datas(path) do\n        data:set_name('AAPC')\n        result,reason = executeOnOneActor('BCMN', 'BDLI', data)\n        if(result ~= 1) then\n            Debug.log(\"warn\",\"Exiting bundle-import loop, reason =\",reason)\n            break\n        end\n    end\n\n    return result,reason\nend\n\nfunction modifyBundle(bundleNumber)\n\n    return executeOnOneActor('BCMN', 'EBUN',AtomContainer.new{'AAPC',\n    EBUN = taskParams:data(\"/EBUN/\"..bundleNumber)} )\nend\n\nfunction gtPrepare()\n    --FIXME: is some kind of pre-check necessary?\n\n    pushAbort(\"taskFinished()\")\n\n    --------------------------------------------------------------------------------\n    -- Acquire an exclusive TOPOLOGY lock on every device type being added\n    local locks = \"['GRID-BUNDLE'] = true\"\n    for node in taskParams:datas(\"/NODS\") do\n        local nid = node:data(\"/NOID\")\n        local cert = node:data(\"/CERT\")\n        local device = node:data(\"/EODM\")\n\n        if nid and cert and device then\n            locks = locks..\", ['\"..device..\"-TOPOLOGY'] = true\"\n        end\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n    pushAbort(\"getLocks({})\")\n    addStage(\"getLocks({\"..locks..\"})\")\n\n    --------------------------------------------------------------------------------\n    addStage(\"stageName(OID_GRIDTASK_STAGE_GROUP_ADD)\")\n\n\n\n    local numNewGroups = 0\n    newGroups = {}\n    for group in taskParams:datas(\"/GRPS\") do\n        numNewGroups = numNewGroups + 1\n        newGroups[numNewGroups] = group\n    end\n\n    local numNewEoids = 0\n    entityIds = {}\n    for eoid in taskParams:datas(\"/GEID\") do\n        numNewEoids = numNewEoids + 1\n        entityIds[numNewEoids] = eoid\n    end\n\n    for index=1,numNewGroups do\n        local group = newGroups[index]\n        local entityId = entityIds[index]\n\n        local siteName = \"\"\n        for node in taskParams:datas(\"/NODS\") do\n            if entityId == node:data(\"/EOID\") then\n                siteName = node:data(\"/EONA\")\n                break\n            end\n        end\n\n        addStage(\"addGroup(\"..group..\",'\"..siteName..\"')\")\n    end\n\n    --------------------------------------------------------------------------------\n    addStage(\"stageName(OID_GRIDTASK_STAGE_ENTITY_ADD)\")\n\n    for node in taskParams:datas(\"/NODS\") do\n        addStage(\"addEntity('/NODS/\"..node:name()..\"')\")\n    end\n\n    --------------------------------------------------------------------------------\n    addStage(\"stageName(OID_GRIDTASK_STAGE_CERT_UPDATE)\")\n    -- FIXME? - Could interleave the certs with the NENT updates.\n\n    for node in taskParams:datas(\"/NODS\") do\n        local nid = node:data(\"/NOID\")\n        local cert = node:data(\"/CERT\")\n\n        if nid and cert then\n            addStage(\"addCert(\"..nid..\",'/NODS/\"..node:name()..\"/CERT')\")\n        end\n    end\n\n    --------------------------------------------------------------------------------\n    addStage(\"stageName(OID_GRIDTASK_STAGE_GRADE_ADD)\")\n\n    for node in taskParams:datas(\"/NODS\") do\n        -- FIXME Pass an explicit \"device type\" field (or look in cert)?\n        local nid = node:data(\"/NOID\")\n        local device = node:data(\"/EODM\")\n        if nid and device == \"BLDR\" then\n            addStage(\"addGrade(\"..nid..\")\")\n        end\n    end\n\n    --------------------------------------------------------------------------------\n    addStage(\"stageName(OID_GRIDTASK_STAGE_NMS_CLUSTER_ADD)\")\n\n    for node in taskParams:datas(\"/NODS\") do\n        local nid = node:data(\"/NOID\")\n        local device = node:data(\"/EODM\")\n        local ncid = node:data(\"/NMCI\")\n\n        if nid and device == \"BNMS\" and ncid then\n            addStage(\"addNmsCluster(\"..ncid..\",'/NODS/\"..node:name()..\"')\")\n        end\n    end\n\n    --------------------------------------------------------------------------------\n    addStage(\"stageName(OID_GRIDTASK_STAGE_BUNDLE_IMPORT)\")\n    addStage(\"addBundles('/BDLS')\")\n\n    --------------------------------------------------------------------------------\n    for bundle in taskParams:datas(\"/EBUN\") do\n        local bundleNumber = bundle:name()\n        local bundleName = bundle:data(\"/BLNM\")\n\n        addStage(\"stageName(OID_GRIDTASK_STAGE_BUNDLE_ADDROWS..'(\"..bundleName..\")')\")\n        addStage(\"modifyBundle('\"..bundleNumber..\"')\")\n    end\n\n    --------------------------------------------------------------------------------\n    addStage(\"getLocks({})\")\n    popAbort() -- RLOK\n\n    --------------------------------------------------------------------------------\n    popAbort()\n\n    addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n    addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\nend\n"
		END
		ILME:CONT:
			0001:CSTR:"-- ILM Evaluation Task\n-- Version 1\n\n\nfunction abortILME()\n    -- Helper function to clean up a verification task\n    local res,reas\n\n    Debug.log(\"warn\",\"Stopping DDS actions\")\n    for _,nid in pairs(cmnList) do\n\n        res,reas = stopAction(nid,'ILME',gtActPc)\n        if(res ~= 1) then\n            return 0,reas\n        end\n    end\n\n    if (res ~= 1) then\n        return 0,reas\n    else\n        return 1,\"OK\"\n    end\nend\n\nfunction gtPrepare()\n    -- Called once, the first time that the task is run.\n    pushAbort(\"taskFinished()\")\n\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n    pushAbort(\"getLocks({})\")\n    addStage(\"getLocks({['GRID-ILM'] = true})\")\n\n    pushAbort(\"abortILME()\")\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_STARTING)\")\n\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\"startAction(\"..targetCMN..\",'ILME',gtActPc)\")\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_ILM_EVALUATE)\")\n    addStage(\"waitDone(cmnList, 'ILME', gtActPc)\")\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_FINISHING)\")\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\"stopAction(\"..targetCMN..\",'ILME',gtActPc)\")\n    end\n\n    addStage(\"getLocks({})\")\n    popAbort() -- RLOK\n\n    popAbort() -- abortILME()\n\n    popAbort()\n\n    addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n    addStage(\"taskFinished()\")\n\n    -- FIXME - Save bundle to GTEN.\nend\n\nfunction gtInit()\n    -- Called every time that the task is run (first time, as well as after any CMN restart).\n\n    gtActPc = AtomContainer.new{'AAPC'}\n    gtActPc:set(\"/\", taskParams)\n    cmnList = actorsToList('BCMN', true)\nend\n"
		END
		LCCN:CONT:
			0001:CSTR:"-- Legacy CBID Continuation Task\n-- Version 1\n\nfunction waitLegacyCBID()\n\x09local function checkDone(nid, status)\n\x09\x09return status:data(\"LCSC\") == 'NFND',\n\x09\x09\x09status:data(\"PCPN\"),\n\x09\x09\x09status:data(\"PCPD\")\n\x09end\n\x09\n\x09return waitOnActors('BCMS', 'LCSC', AtomContainer.new{'CHPC'}, checkDone)\nend\n\nfunction gtPrepare()\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LEGACY_CBID)\")\n\x09addStage(\"waitLegacyCBID()\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n\x09addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\nend\n"
		END
		LDCM:CONT:
			0001:CSTR:"-- StorageNODE Decommissioning Task\n\nfunction actionSMNT(ldr,value)\n    return executeOnActors(ldr, 'SMNT', AtomContainer.new{'AAPC', SMNT={fc32=value}})\nend\n\nfunction actionSTDS(ldr,value)\n    return executeOnActors(ldr, 'STDS', AtomContainer.new{'AAPC', STDS={fc32=value}})\nend\n\nfunction revokeCert(nid)\n--  return executeOnOneActor('BADC', 'ADBP', AtomContainer.new{'AAPC', DLVL = 'NOTE', DSTR = \"Revoking cert for \"..nid})\n    return executeOnOneActor('BADC', 'CRVK', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})\nend\n\nfunction removeEntity(nid)\n    return executeOnOneActor('BCMN', 'ANER', AtomContainer.new{'AAPC', EOID = {cstr = nid}})\nend\n\nfunction setServiceState(nid, value)\n    return executeOnActors(nid, 'SVST', AtomContainer.new{'AAPC', SVST={fc32=value}})\nend\n\nfunction setAuditState(nid, value)\n    return executeOnActors(nid, 'AUDT', AtomContainer.new{'AAPC', AUDT={fc32=value}})\nend\n\nfunction waitAudit(nid, value)\n    local function checkDone(nid, status)\n        return status:data(\"AQSZ\") == UINT64.new(0)\n    end\n    return waitOnActors(nid, 'AUDQ', AtomContainer.new{'CHPC'}, checkDone)\nend\n\nfunction removeGrade(nid)\n    return executeOnOneActor('BCMN', 'USTG', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})\nend\n\nfunction removeNode(nid, device)\n    return executeOnOneActor('BCMN', 'UNOD', AtomContainer.new{'AAPC', NOID = {ui32 = nid}, DTYP = {fc32 = device}})\nend\n\nfunction markingLdrDecommissioning(nid)\n    return executeOnOneActor('BDDS', 'LMDC', AtomContainer.new{'AAPC', NODE={ui32=nid}})\nend\n\nfunction filterDdsList(nid)\n    for i=#ddsListReMap,1,-1 do\n        if (nid == ddsListReMap[i]) then\n            table.remove(ddsListReMap, i)\n        end\n    end\nend\n\nfunction filterCmsList(nid)\n    for i=#cmsList,1,-1 do\n        if (nid == cmsList[i]) then\n            table.remove(cmsList, i)\n        end\n    end\nend\n\nfunction setOwnerMapping(onid, nnid)\n    return executeOnOneActor('BDDS', 'COWR', AtomContainer.new{'AAPC', NIDS={ui32=onid},  NIDD={ui32=nnid}})\nend\n\nfunction gtPrepare()\n    -- Called once, the first time that the task is run.\n\n    pushAbort(\"taskFinished()\")\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n    pushAbort(\"getLocks({})\")\n\n    for oldLdr in taskParams:datas('/SLDR') do\n        addStage(\"getLocks({['\"..oldLdr..\"-STORAGE'] = true})\")\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_STARTING)\")\n\n    for oldLdr in taskParams:datas('/SLDR') do\n        pushAbort(\"actionSMNT(\"..oldLdr..\",'DABL')\")\n        addStage(\"actionSMNT(\"..oldLdr..\",'ENBL')\")\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_STARTING)\")\n\n    -- Using this way of creating a list of nodeTypes mapped to nodeIds and using ipairs() because unit tests expect ordering which\n    -- pairs() doesn't guarantee.\n    local sourceNodes = {}\n\n    for oldLdr in taskParams:datas('/SLDR') do\n        popAbort()  -- actionSMNT\n    end\n    popAbort() -- RLOK\n    popAbort()  -- Empty the stack; cannot abort beyond this point\n\n    -- from here,can not roll back\n    addStage(\"getLocks({['GRID-ILM'] = true})\")\n\n    for oldLdr in taskParams:datas('/SLDR') do\n        addStage(\"markingLdrDecommissioning(\"..oldLdr..\")\")\n    end\n\n    -- EC Decommissioning start.\n\n    Debug.log(\"info\",\"Starting EC decommissioning.\")\n    -- Start on one CMN?\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\"startAction(\"..targetCMN..\", 'ECND', ecdcParams)\")\n    end\n    Debug.log(\"info\",\"Started EC decommissioning actions.\")\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_EC_DECOMMISSIONING)\")\n    addStage(\"waitDone(cmnList, 'ECND', ecdcParams)\")\n\n    Debug.log(\"info\",\"EC decommissioning action done.\")\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_FINISHING)\")\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\"stopAction(\"..targetCMN..\", 'ECND', ecdcParams)\")\n    end\n    Debug.log(\"info\",\"Finished EC decommissioning.\")\n\n    -- EC Decommissioning end.\n\n    -- FIXME? This seems wrong; we should only start a single ILM re-evaluation, even if we actually has multiple CMNs\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\"startAction(\"..targetCMN..\", 'ILME', ilmeParams)\")\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_ILM_EVALUATE)\")\n    addStage(\"waitDone(cmnList, 'ILME', ilmeParams)\")\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_FINISHING)\")\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\"stopAction(\"..targetCMN..\", 'ILME', ilmeParams)\")\n    end\n\n    for oldCms in taskParams:datas(\"/SCMS\") do\n        local cmsSource = {nt = 'BCMS', nid = oldCms}\n        table.insert(sourceNodes, cmsSource)\n        filterCmsList(oldCms)\n    end\n\n    if(table.getn(cmsList) > 0) then\n        for oldCms in taskParams:datas('/SCMS') do\n            local newCms = cmsList[ math.random(table.getn(cmsList)) ]\n            addStage(\"setOwnerMapping(\"..oldCms..\", \"..newCms..\" )\")\n        end\n    else\n        Debug.log(\"err\",\"NodeId mapping failed. No running CMS\")\n    end\n\n    for oldDds in taskParams:datas('/SDDS') do\n        filterDdsList(oldDds)\n    end\n\n    if(table.getn(ddsListReMap) > 0) then\n        for oldDds in taskParams:datas('/SDDS') do\n            local newDds = ddsListReMap[ math.random(table.getn(ddsListReMap)) ]\n            addStage(\"setOwnerMapping(\"..oldDds..\", \"..newDds..\" )\")\n        end\n    else\n        Debug.log(\"err\",\"NodeId mapping failed. No running DDS\")\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)\")\n    for oldLdr in taskParams:datas('/SLDR') do\n        addStage(\"actionSTDS(\"..oldLdr..\",'OFLN')\")\n        local ldrSource = {nt = 'BLDR', nid = oldLdr}\n        table.insert(sourceNodes, ldrSource)\n    end\n\n    for oldSsm in taskParams:datas('/SSSM') do\n        local ssmSource = {nt = 'BSSM', nid = oldSsm}\n        table.insert(sourceNodes, ssmSource)\n    end\n\n    for oldAdc in taskParams:datas('/SADC') do\n        local adcSource = {nt = 'BADC', nid = oldAdc}\n        table.insert(sourceNodes, adcSource)\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_CASSANDRA_NODETOOL_DECOMMISSION)\")\n    for oldDds in taskParams:datas('/SDDS') do\n        local ddsSource = {nt = 'BDDS', nid = oldDds}\n        table.insert(sourceNodes, ddsSource)\n        addStage(\"stopAction(\"..oldDds..\", 'CCLE', AtomContainer.new{'AAPC'})\")\n        addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n        addStage(\"getLocks({['\"..oldDds..\"-NODETOOL'] = true, ['NODETOOL_DECOMMISSION'] = true})\")\n        addStage(\"startAction(\"..oldDds..\", 'NDEC', AtomContainer.new{'AAPC', NOID = {ui32 = \"..oldDds..\"}})\")\n        addStage(\"waitDone(\"..oldDds..\", 'NDEC', gtActPc)\")\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_FINISHING)\")\n    for oldDds in taskParams:datas('/SDDS') do\n        addStage(\"stopAction(\"..oldDds..\", 'NDEC', AtomContainer.new{'AAPC', NOID = {ui32 = \"..oldDds..\"}})\")\n    end\n\n    local locks = \"['GRID-BUNDLE'] = true\"\n    for _, data in ipairs(sourceNodes) do\n        locks = locks..\", ['\"..data['nt']..\"-TOPOLOGY'] = true\"\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n    addStage(\"getLocks({\"..locks..\"})\")\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)\")\n    for _, data in ipairs(sourceNodes) do\n        addStage(\"setServiceState(\"..data['nid']..\", 'DABL')\")\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)\")\n    for _, data in ipairs(sourceNodes) do\n        -- TODO: CMS doesn't support these actions/checks yet.\n        --       Uncomment when story B-25861 is implemented.\n        if (data['nt'] ~= 'BCMS') then\n            addStage(\"setAuditState(\"..data['nid']..\", 'DABL')\")\n            addStage(\"waitAudit(\"..data['nid']..\")\")\n        end\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)\")\n    for _, data in ipairs(sourceNodes) do\n        addStage(\"revokeCert(\"..data['nid']..\")\")\n    end\n\n    for eoid in taskParams:datas('/EOID') do\n        addStage(\"removeEntity('\"..eoid..\"')\")\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)\")\n    for _, data in ipairs(sourceNodes) do\n        addStage(\"removeNode(\"..data['nid']..\", '\"..data['nt']..\"')\")\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_GRADE_REMOVE)\")\n    for oldLdr in taskParams:datas('/SLDR') do\n        addStage(\"removeGrade(\"..oldLdr..\")\")\n    end\n\n    addStage(\"getLocks({})\")\n\n    addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n    addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\n    -- Called every time that the task is run (first time, as well as after any CMN restart).\n\n    cmnList = actorsToList('BCMN')\n    cmsList = actorsToList('BCMS', true)\n    ddsList = actorsToList('BDDS', true)\n    ddsListReMap = ddsList\n\n    gtActPc = AtomContainer.new{'AAPC'}\n\n    -- Add ILM re-evaluation filters for all the LDRs being decommissioned\n    ilmeParams = AtomContainer.new{'AAPC'}\n    local index = 1\n    for oldLdr in taskParams:datas('/SLDR') do\n        local filt = AtomContainer.new{'FILT', NOID={ui32=oldLdr}}\n        ilmeParams:set_cont(index, filt)\n        index = index + 1\n    end\n\n    -- Setup EC decommissioning parameters.\n    --  Pass the taskId as part of the parameters.\n    ecdcParams = AtomContainer.new{'AAPC', TKID={ui32=taskId}}\n    local nodes = AtomContainer.new{'NODE'}\n    local i = 1\n    for oldLdr in taskParams:datas('/SLDR') do\n        local path = string.format(\"%04X\", i)\n        nodes:set_ui32(path, oldLdr)\n        i = i + 1\n    end\n    ecdcParams:set_cont('NODE', nodes)\nend\n"
		END
		LMIG:CONT:
			0001:CSTR:"-- LDR Directed Decomissioning (Hardware Refresh) Task\n-- Version 1\n\nfunction actionSMNT(ldr,value)\n\x09return executeOnActors(ldr, 'SMNT', AtomContainer.new{'AAPC', SMNT={fc32=value}})\nend\n\nfunction actionCLDQ(ldr,value)\n\x09return executeOnActors(ldr, 'CLDQ', AtomContainer.new{'AAPC', FRWD={fc32=value}})\nend\n\nfunction disableCLOCLOSTForwarding(ldr)\n\x09return actionCLDQ(ldr, 'DABL')\nend\n\nfunction enableCLOCLOSTForwarding(ldr)\n\x09return actionCLDQ(ldr, 'ENBL')\nend\n\nfunction actionSTDS(ldr,value)\n\x09return executeOnActors(ldr, 'STDS', AtomContainer.new{'AAPC', STDS={fc32=value}})\nend\n\nfunction waitSTCR(ldr,value)\n\x09-- See if Storage is in the expected state\n\x09local function checkDone(nid, status)\n\x09\x09return status:data(\"STUS\") == 'NONE' and\n\x09\x09\x09status:data(\"STCR\") == value\n\x09end\n\x09\n\x09return waitOnActors(ldr, 'STCR', AtomContainer.new{'CHPC'}, checkDone)\nend\n\nfunction cmsRemap(from, to)\n\x09local actPc = AtomContainer.new{'AAPC', SNID = {ui32 = gtSourceLdr} ,DNID = {ui32 = gtDestLdr} }\n\n\x09return executeOnActors(gtCmsList, 'LRMP', actPc)\nend\n\nfunction revokeCert(nid)\n--\x09return executeOnOneActor('BADC', 'ADBP', AtomContainer.new{'AAPC', DLVL = 'NOTE', DSTR = \"Revoking cert for \"..nid})\n\x09return executeOnOneActor('BADC', 'CRVK', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})\nend\n\nfunction removeEntity(oid)\n\x09return executeOnOneActor('BCMN', 'ANER', AtomContainer.new{'AAPC', EOID = {cstr = oid}})\nend\n\nfunction setServiceState(nid, value)\n\x09return executeOnActors(nid, 'SVST', AtomContainer.new{'AAPC', SVST={fc32=value}})\nend\n\nfunction setAuditState(nid, value)\n\x09return executeOnActors(nid, 'AUDT', AtomContainer.new{'AAPC', AUDT={fc32=value}})\nend\n\nfunction waitAudit(nid, value)\n\x09local function checkDone(nid, status)\n\x09\x09return status:data(\"AQSZ\") == UINT64.new(0)\n\x09end\n\x09return waitOnActors(nid, 'AUDQ', AtomContainer.new{'CHPC'}, checkDone)\nend\n\nfunction removeGrade(nid)\n\x09return executeOnOneActor('BCMN', 'USTG', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})\nend\n\nfunction removeNode(nid, device)\n\x09return executeOnOneActor('BCMN', 'UNOD', AtomContainer.new{'AAPC', NOID = {ui32 = nid}, DTYP = {fc32 = device}})\nend\n\nfunction gtPrepare()\n\x09-- Called once, the first time that the task is run. \n\n\x09pushAbort(\"taskFinished()\")\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09pushAbort(\"getLocks({})\")\n\x09addStage(\"getLocks({['\"..gtSourceLdr..\"-STORAGE'] = true, ['\"..gtDestLdr..\"-STORAGE'] = true, ['BCMS-TOPOLOGY'] = false})\")\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)\")\n\x09addStage(\"waitSTCR(\"..gtDestLdr..\",'READ')\")\n\n        pushAbort(\"enableCLOCLOSTForwarding(\"..gtDestLdr..\")\")\n        addStage(\"disableCLOCLOSTForwarding(\"..gtDestLdr..\")\")\n\n\x09pushAbort(\"actionSMNT(\"..gtSourceLdr..\",'DABL')\")\n\x09addStage(\"actionSMNT(\"..gtSourceLdr..\",'ENBL')\")\n\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_CONTENT_MIGRATE)\")\n\x09pushAbort(\"stopAction(\"..gtSourceLdr..\",'LMIG',gtActPc)\")\n\x09addStage(\"startAction(\"..gtSourceLdr..\",'LMIG',gtActPc)\")\n\x09addStage(\"waitDone(\"..gtSourceLdr..\", 'LMIG', gtActPc)\")\n\x09addStage(\"stopAction(\"..gtSourceLdr..\",'LMIG',gtActPc)\")\n\n\x09popAbort()\x09-- stopAction\n\x09popAbort()\x09-- actionSMNT\n\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_CONTENT_REMAP)\")\n\x09addStage(\"cmsRemap(\"..gtSourceLdr..\",\"..gtDestLdr..\")\")\n\n        popAbort()      -- enableCLOCLOSTForwarding\n        addStage(\"enableCLOCLOSTForwarding(\"..gtDestLdr..\")\")\n\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)\")\n\x09addStage(\"actionSTDS(\"..gtDestLdr..\",'RDWR')\")\n\x09addStage(\"actionSTDS(\"..gtSourceLdr..\",'OFLN')\")\n\x09\n\x09local sourceNodes = {BLDR = gtSourceLdr, BSSM = gtSourceSsm}\n\x09local locks = \"['GRID-BUNDLE'] = true, ['\"..gtSourceLdr..\"-STORAGE'] = true\"\n\x09for nodeType, nid in pairs(sourceNodes) do\n\x09\x09locks = locks..\", ['\"..nodeType..\"-TOPOLOGY'] = true\"\n\x09end\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09addStage(\"getLocks({\"..locks..\"})\")\n\x09popAbort() -- RLOK\n\x09\n\x09popAbort()\x09-- Empty the stack; cannot abort beyond this point\n\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)\")\n\x09for nodeType, nid in pairs(sourceNodes) do\n\x09\x09addStage(\"setServiceState(\"..nid..\", 'DABL')\")\n\x09end\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)\")\n\x09for nodeType, nid in pairs(sourceNodes) do\n\x09\x09addStage(\"setAuditState(\"..nid..\", 'DABL')\")\n\x09\x09addStage(\"waitAudit(\"..nid..\")\")\n\x09end\n\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)\")\n\x09for nodeType, nid in pairs(sourceNodes) do\n\x09\x09addStage(\"revokeCert(\"..nid..\")\")\n\x09end\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)\")\n\x09addStage(\"removeEntity('\"..gtSourceLdrOid..\"')\")\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)\")\n\x09for nodeType, nid in pairs(sourceNodes) do\n\x09\x09addStage(\"removeNode(\"..nid..\", '\"..nodeType..\"')\")\n\x09end\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_GRADE_REMOVE)\")\n\x09addStage(\"removeGrade(\"..gtSourceLdr..\")\")\n\x09\n\x09addStage(\"getLocks({})\")\n\x09\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n    addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\n\x09-- Called every time that the task is run (first time, as well as after any CMN restart). \n\n\x09gtSourceLdr = taskParams:data('/SNID')\n\x09gtDestLdr = taskParams:data('/DNID')\n\x09gtSourceSsm = taskParams:data('/SSMN')\n\x09\n\x09gtSourceLdrOid = taskParams:data('/EOID')\n\n\x09gtCmsList = cacheLoadList('CMSL')\n\x09\n\x09if(gtCmsList == nil) then\n\x09\x09gtCmsList  = coFindActors('BCMS')\n\x09\x09cacheStoreList('CMSL',gtCmsList)\n\x09end\n\x09\n\x09gtActPc = AtomContainer.new{'AAPC', DNID = {ui32 = gtDestLdr} }\nend\n"
		END
		LOCO:CONT:
			0001:CSTR:"-- Verify Locations\n-- Version 1\n\n\nfunction abortMVFY()\n\x09local res,reas\n\n\x09Debug.log(\"warn\",\"Stopping CMS actions\")\n\x09for _,nid in pairs(cmsList) do\n\x09\x09res,reas = stopAction(nid,'MVFY',gtActPc)\n\x09\x09if(res ~= 1) then\n\x09\x09\x09return 0,reas\n\x09\x09end\n\x09end\n\n\x09if (res ~= 1) then\n\x09\x09return 0,reas\n\x09else\n\x09\x09return 1,\"OK\"\n\x09end\nend\n\nfunction gtPrepare()\n\x09pushAbort(\"taskFinished()\")\n\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09pushAbort(\"getLocks({})\")\n\x09addStage(\"getLocks({['BCMS-TOPOLOGY'] = false})\")\n\n\x09pushAbort(\"abortMVFY()\")\n\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_STARTING)\")\n\x09for _,targetCMS in pairs(cmsList) do\n\x09\x09addStage(\"stopAction(\"..targetCMS..\",'MVFY',gtActPc)\")\n\x09end\n\x09\n\x09for _,targetCMS in pairs(cmsList) do\n\x09\x09addStage(\"startAction(\"..targetCMS..\",'MVFY',gtActPc)\")\n\x09end\n\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_VERIFY_LOCATIONS)\")\n\x09addStage(\"waitDone(cmsList, 'MVFY', gtActPc)\")\n\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_FINISHING)\")\n\x09for _,targetCMS in pairs(cmsList) do\n\x09\x09addStage(\"stopAction(\"..targetCMS..\",'MVFY',gtActPc)\")\n\x09end\n\n\x09addStage(\"getLocks({})\")\n\x09popAbort() -- RLOK\n\x09popAbort() -- abortMVFY()\n\x09popAbort()\n\x09\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n\x09addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\n\x09gtActPc = AtomContainer.new{'AAPC'}\n\x09cmsList = actorsToList('BCMS')\nend\n"
		END
		MVFY:CONT:
			0001:CSTR:"-- CMS Metadata Background Verification Task\n-- Version 1\n\n\nfunction abortMVFY()\n\x09-- Helper function to clean up a verification task\n\x09local res,reas\n\n\x09Debug.log(\"warn\",\"Stopping CMS actions\")\n\x09res,reas = stopAction(gtTargetCMS,'MVFY',gtActPc)\n\x09if(res ~= 1) then\n\x09\x09return 0,reas\n\x09else\n\x09\x09return 1,\"OK\"\n\x09end\nend\n\nfunction gtPrepare()\n\x09-- Called once, the first time that the task is run. \n\x09\n\x09local targetCMS = gtTargetCMS\n\n\x09pushAbort(\"taskFinished()\")\n\x09\n\x09pushAbort(\"abortMVFY()\")\n\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09pushAbort(\"getLocks({})\")\n\x09addStage(\"getLocks({['\"..targetCMS..\"-STORAGE'] = true})\")\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_STARTING)\")\n\x09addStage(\"stopAction(\"..gtTargetCMS..\",'MVFY',gtActPc)\")\n\x09\n\x09addStage(\"startAction(\"..gtTargetCMS..\",'MVFY',gtActPc)\")\n\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_VERIFY_LOCATIONS)\")\n\x09addStage(\"waitDone(\"..gtTargetCMS..\", 'MVFY', gtActPc)\")\n\x09addStage(\"stopAction(\"..gtTargetCMS..\",'MVFY',gtActPc)\")\n\n\x09addStage(\"getLocks({})\")\n\x09popAbort() -- RLOK\n\x09\n\x09popAbort() -- abortMVFY()\n\x09\n\x09popAbort()\n\x09\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n\x09addStage(\"taskFinished()\")\n\x09\n\x09-- FIXME - Save bundle to GTEN.\nend\n\nfunction gtInit()\n\x09-- Called every time that the task is run (first time, as well as after any CMN restart). \n\n\x09gtTargetCMS = taskParams:data('/NOID')\n\x09\n\x09startCbid = taskParams:data('/SBID')\n\x09endCbid = taskParams:data('/EBID')\n\x09\n\x09gtActPc = AtomContainer.new{'AAPC', NOID = {ui32 = gtTargetCMS}, SBID = {ui64 = startCbid}, EBID = {ui64 = endCbid}}\n\nend\n"
		END
		NREP:CONT:
			0001:CSTR:"-- Nodetool repair task\n-- Version 1\n\nfunction abortNREP()\n    -- Helper function to clean up a verification task\n    local res,reas\n\n    Debug.log(\"warn\",\"Stopping DDS(NREP) actions\")\n\n    res,reas = stopAction(gtTargetDDSNid,'NREP',gtActPc)\n\n    if (res ~= 1) then\n        return 0,reas\n    else\n        return 1,\"OK\"\n    end\nend\n\nfunction gtPrepare()\n    pushAbort(\"taskFinished()\")\n    addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n    pushAbort(\"getLocks({})\")\n    addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n    locks = \"['\"..gtTargetDDSNid..\"-NODETOOL'] = true\"\n    addStage(\"getLocks({\"..locks..\"})\")\n\n    pushAbort(\"abortNREP()\")\n    addStage(\"stageName(OID_GRIDTASK_STAGE_STARTING)\")\n    addStage(\"startAction(\"..gtTargetDDSNid..\",'NREP',gtActPc)\")\n    addStage(\"stageName(OID_GRIDTASK_STAGE_RUNNING_CASSANDRA_NODE_REPAIR)\")\n    addStage(\"waitDone(gtTargetDDSNid, 'NREP', gtActPc)\")\n    addStage(\"getLocks({})\")\n    popAbort() -- RLOK\n    popAbort() -- abortNREP()\n    popAbort()\n    addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n    addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\n    gtTargetDDSNid = taskParams:data('/NOID')\n    gtActPc = AtomContainer.new{'AAPC'}\nend\n\n"
		END
		RNMC:CONT:
			0001:CSTR:"-- Remove NMS Cluster Bindings\n-- Version 1\n\nfunction unbindCluster(clusterId)\n\x09return executeOnOneActor('BCMN', 'RNMC', AtomContainer.new{'AAPC', NCID = {ui32 = clusterId}})\nend\n\nfunction gtPrepare()\n\x09pushAbort(\"taskFinished()\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09pushAbort(\"getLocks({})\")\n\x09addStage(\"getLocks({['GRID-BUNDLE'] = true})\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_BUNDLE_COMMIT)\")\n\x09\n\x09clusterId = taskParams:data('/NCID')\n\x09addStage(\"unbindCluster(\"..clusterId..\")\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"getLocks({})\")\n\x09popAbort() -- RLOK\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n\x09addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\nend\n"
		END
		SWUP:CONT:
			0001:CSTR:"-- Software Upgrade Task\n-- Version 1\n\nfunction addBundles(path)\n\x09local result = 1\n\x09local reason = OID_GRIDTASK_MSG_NONE\n\x09\n\x09for data in taskParams:datas(path) do\n\x09\x09data:set_name('AAPC')\n\x09\x09result,reason = executeOnOneActor('BCMN', 'BDLI', data)\n\x09\x09if(result ~= 1) then\n\x09\x09\x09Debug.log(\"warn\",\"Exiting bundle-import loop, reason =\",reason)\n\x09\x09\x09break\n\x09\x09end\n\x09end\n\n\x09return result,reason\nend\n\nfunction commitBundles(path)\n\x09local result = 1\n\x09local reason = OID_GRIDTASK_MSG_NONE\n\x09\n\x09for data in taskParams:datas(path) do\n\x09\x09data:set_name('AAPC')\n\x09\x09result,reason = executeOnOneActor('BCMN', 'BCMT', data)\n\x09\x09if(result ~= 1) then\n\x09\x09\x09Debug.log(\"warn\",\"Exiting bundle-commit loop, reason =\",reason)\n\x09\x09\x09break\n\x09\x09end\n\x09end\n\n\x09return result,reason\nend\n\nfunction preloadResources(nodeType, version, update)\n\x09return executeOnActors(nodeType, 'ARPL',\n\x09\x09AtomContainer.new{'AAPC', NVER = {ui32 = version}, UPDT = taskParams:data(update)})\nend\n\nfunction unloadResources(nodeType)\n\x09return executeOnActors(nodeType, 'ARUL', AtomContainer.new{'AAPC'})\nend\n\nfunction waitUnloadResources(nodeType)\n\x09local function checkDone(nid, status)\n\x09\x09return status:data(\"STAT\") == \"NFND\"\n\x09end\n\x09\n\x09return waitOnActors(nodeType, 'CRUL', AtomContainer.new{'CHPC'}, checkDone)\nend\n\nfunction waitVersion(path, adeVersion, cmsVersion)\n\x09local function checkDone(nid, status, node)\n\x09\x09local version = adeVersion\n\x09\x09if node:data(\"DTYP\") == 'BCMS' then\n\x09\x09\x09version = cmsVersion\n\x09\x09end\n\x09\x09return status:data(\"VERS\") >= version\n\x09end\n\x09\n\x09return waitOnIncompleteActors(path, 'BALL', 'CSWV', AtomContainer.new{'CHPC'}, checkDone)\nend\n\nfunction clearCache(path)\n\x09gtInfoCache:clear(path)\n\x09updateInfo()\n\x09return 1, OID_GRIDTASK_MSG_NONE\nend\n\n-- ------------------------------------------------------------------------------\n-- Helper function to create an atom container populated with the list of nodes\n-- requested in actorTable, which may be \"BALL\" to request all nodes.\n-- ------------------------------------------------------------------------------\n--  2010-04-12 KJ : Updated\n-- ------------------------------------------------------------------------------\nfunction actorTableToContainer(actorTable)\n\x09local container = AtomContainer.new{'NODS'}\n\x09\n\x09if actorTable == \"BALL\" then\n\x09\x09local nodeTypes = {'BADC', 'BLDR', 'BCMS', 'BNMS', 'BAMS', 'BSSM', 'BCLB', 'BCMN', 'BARC'}\n\x09\x09local i = 1\n\x09\x09for _, nodeType in pairs(nodeTypes) do\n\x09\x09\x09local nodes = actorsToList(nodeType)\n\x09\x09\x09for _,nid in pairs(nodes) do\n\x09\x09\x09\x09local path = string.format(\"%04X\", i)\n\x09\x09\x09\x09container:set_ui32(path..\"/NOID\", nid)\n\x09\x09\x09\x09container:set_fc32(path..\"/DTYP\", nodeType)\n\x09\x09\x09\x09i = i + 1\n\x09\x09\x09end\n\x09\x09end\n\x09else\n\x09\x09local nodes = actorsToList(actorTable)\n\x09\x09local i = 1\n\x09\x09for _,nid in pairs(nodes) do\n\x09\x09\x09local path = string.format(\"%04X\", i)\n\x09\x09\x09container:set_ui32(path..\"/NOID\", nid)\n\x09\x09\x09i = i + 1\n\x09\x09end\n\x09end\n\x09\n\x09return container\nend\n\n-- ------------------------------------------------------------------------------\n-- Helper function similar to waitOnActors() to wait for a check on all members\n-- of a specified table of actors to meet some condition.\n-- Unlike waitOnActors(), this function does not re-check any actors that have\n-- successfully completed the check (through caching of the list of actors).\n-- ------------------------------------------------------------------------------\n--  2010-04-12 KJ : Updated\n-- ------------------------------------------------------------------------------\nfunction waitOnIncompleteActors(actorCachePath, actorTable, checkType, checkPc, checkDoneFn, abortOnError)\n\x09-- Load or create the cached container of nodes\n\x09local actorCont = cacheLoad(actorCachePath) or actorTableToContainer(actorTable)\n\x09local done = true\n\x09local totN = UINT64.new(0)\n\x09local totD = UINT64.new(0)\n\x09\n\x09for nodeCont in actorCont:datas() do\n\x09\x09local nid = nodeCont:data('NOID')\n\x09\x09local nodeDone = nodeCont:data('DONE')\n\x09\x09local nodeN = nodeCont:data('NODN') or 0\n\x09\x09local nodeD = nodeCont:data('NODD') or 1\n\x09\x09\n\x09\x09if nodeDone then\n\x09\x09\x09-- Skip any node on which the check has already been completed\n\x09\x09\x09Debug.log(\"info\",\"Check\", checkType, \"on node\", nid, \"already done\", \"progress\", nodeN, \"/\", nodeD)\n\x09\x09else\n\x09\x09\x09local resp = postCheckAsk(nid, checkType, checkPc)\n\x09\x09\n\x09\x09\x09if resp:data('/RSLT') == 'SUCS' then\n\x09\x09\x09\x09nodeDone, nodeN, nodeD = checkDoneFn(nid, resp:data('/CSTC'), nodeCont)\n\x09\x09\x09\x09nodeN = nodeN or ((nodeDone and 1) or 0)\n\x09\x09\x09\x09nodeD = nodeD or 1\n\x09\x09\x09\x09\n\x09\x09\x09\x09Debug.log(\"info\",\"Check\", checkType, \"on node\", nid, \"done\", nodeDone, \"progress\", nodeN, \"/\", nodeD)\n\x09\x09\x09\x09\n\x09\x09\x09\x09if nodeDone then\n\x09\x09\x09\x09\x09actorCont:set_ui32(nodeCont:name()..'/DONE', 1)\n\x09\x09\x09\x09end\n\x09\x09\x09\x09\n\x09\x09\x09\x09actorCont:set_ui64(nodeCont:name()..'/NODN', nodeN)\n\x09\x09\x09\x09actorCont:set_ui64(nodeCont:name()..'/NODD', nodeD)\n\x09\x09\x09else\n\x09\x09\x09\x09Debug.log(\"warn\",\"Check\", checkType, \"failed on node\", nid)\n\x09\x09\x09end\n\x09\x09end\n\x09\x09\n\x09\x09done = done and nodeDone\n\x09\x09totN = totN + nodeN\n\x09\x09totD = totD + nodeD\n\x09end\n\x09\n\x09Debug.log(\"info\",\"Overall check\", checkType, \"done\", done, \"progress\", totN, \"/\", totD)\n\x09\n\x09-- Update NMS attributes\n\x09stageReport(gtStageString, totN, totD)\n\x09\n\x09-- Update the cached data table\n\x09gtInfoCache:clear(actorCachePath)\n\x09cacheStore(actorCachePath, actorCont)\n\x09\n\x09if(not done) then\n\x09\x09if(abortOnError) then\n\x09\x09\x09return 0, OID_GRIDTASK_MSG_WAITING\n\x09\x09end\n\x09\x09return 4, \"Again\"\n\x09end\n\n\x09return 1, \"OK\"\nend\n\nfunction gtPrepare()\n\x09--FIXME: is some kind of pre-check necessary?\n\n\x09pushAbort(\"taskFinished()\")\n\n\x09local adeVersion = taskParams:data(\"NAVR\")\n\x09local cmsVersion = taskParams:data(\"NCVR\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09pushAbort(\"getLocks({})\")\n\x09addStage(\"getLocks({['GRID-UPGRADE'] = true})\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_RESOURCE_PRELOAD)\")\n\x09\n\x09for node in taskParams:datas(\"/RUPD\") do\n\x09\x09local nodeType = node:name()\n\x09\x09local update = \"/RUPD/\"..nodeType..\"/UPDT\"\n\x09\x09\n\x09\x09addStage(\"getLocks({['GRID-UPGRADE'] = true, ['\"..nodeType..\"-RESOURCES'] = true})\")\n\x09\x09pushAbort(\"unloadResources('\"..nodeType..\"')\")\n\x09\x09addStage(\"preloadResources('\"..nodeType..\"',\"..adeVersion..\",'\"..update..\"')\")\n\x09end\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_BUNDLE_IMPORT..' 1')\")\n\x09addStage(\"getLocks({['GRID-UPGRADE'] = true, ['GRID-BUNDLE'] = true})\")\n\x09addStage(\"addBundles('/BDL1')\")\n\x09addStage(\"getLocks({['GRID-UPGRADE'] = true})\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_VERSION_WAIT)\")\n\x09addStage(\"waitVersion('NODS', \"..adeVersion..\",\"..cmsVersion..\")\")\n\x09addStage(\"clearCache('NODS')\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_RESOURCE_UNLOAD_WAIT)\")\n\x09\n\x09for node in taskParams:datas(\"/RUPD\") do\n\x09\x09local nodeType = node:name()\n\x09\x09\n\x09\x09addStage(\"waitUnloadResources('\"..nodeType..\"')\")\n\x09end\n\n\x09--------------------------------------------------------------------------------\n\x09for node in taskParams:datas(\"/RUPD\") do\n\x09\x09popAbort()\n\x09end\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_BUNDLE_COMMIT)\")\n\x09addStage(\"getLocks({['GRID-UPGRADE'] = true, ['GRID-BUNDLE'] = true})\")\n\x09addStage(\"commitBundles('/BCMT')\")\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_BUNDLE_IMPORT..' 2')\")\n\x09addStage(\"addBundles('/BDL2')\")\n\x09--------------------------------------------------------------------------------\n\x09-- Transfer S3 Accounts from S3AC bundle to Account Server\n\x09addStage(\"getLocks({['GRID-UPGRADE'] = true})\")\n\x09-- Use first DDS, as only a single DDS needs to run this task.\n\x09local targetDdsNid = taskParams:data(\"TDDS\")\n\x09addStage(\"startAction(\"..targetDdsNid..\", 'TS3A', AtomContainer.new{'AAPC'})\")\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_TRANSFER_S3_ACCOUNTS)\")\n\x09addStage(\"waitDone(\"..targetDdsNid..\", 'TS3A', AtomContainer.new{'AAPC'})\")\n\n\x09--------------------------------------------------------------------------------\n\x09addStage(\"getLocks({})\")\n\x09popAbort() -- RLOK\n\x09\n\x09--------------------------------------------------------------------------------\n\x09popAbort()\n\x09\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n\x09addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\nend\n"
		END
		UFLT:CONT:
			0001:CSTR:"-- Update Flags Task\n-- Version 1\n\n\nfunction updateNodeResources(nid, update)\n\x09return executeOnActor(nid, 'UPRE',\n\x09\x09AtomContainer.new{'AAPC', UPDT = taskParams:data(update)})\nend\n\nfunction shutdownNode(nid)\n\x09local resp = postCheckAsk(nid, 'CSTT', AtomContainer.new{'CHPC'})\n\n\x09if(resp:data('/RSLT') == 'SUCS') then\n\x09\x09initTime = resp:data('/CSTC/CSTT')\n\x09\x09cacheStore(\"ITME\", initTime)\n\x09else\n\x09     return 0,\"Error\"\n\x09end\n\n\x09return executeOnActor(nid, 'SHDN', AtomContainer.new{'AAPC', DELY = {ui64 = 1000000 }})\n\nend\n\nfunction checkRestartTime(nid)\n\x09local function checkDone(nid, status)\n\x09\x09-- TODO This assumes monotonically increasing clock after node restart, which isn't guaranteed\n\x09\x09return initTime < status:data(\"CSTT\")\n\x09end\n\x09return waitOnActors(nid, 'CSTT', AtomContainer.new{'CHPC'}, checkDone, true)\nend\n\nfunction executeUPDT(nid, update, restart)\n\x09numNodes = numNodes + 1\n\x09\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_RESOURCE_UPDATE..' (\"..numNodes..\"/'..numNodes..'): '..OID_GRIDTASK_MSG_NID..' \"..nid..\"')\")\n\x09addStage(\"updateNodeResources('\"..nid..\"','\"..update..\"')\")\n\x09\n\x09if (restart == 1) then\n\x09\x09addStage(\"stageName(OID_GRIDTASK_STAGE_RESOURCE_UPDATE..' (\"..numNodes..\"/'..numNodes..'): '..OID_GRIDTASK_MSG_NID..' \"..nid..\"')\")\n\x09\x09addStage(\"shutdownNode('\"..nid..\"')\")\n\x09\x09\n\x09\x09addStage(\"stageName(OID_GRIDTASK_STAGE_RESTART_WAIT..' (\"..numNodes..\"/'..numNodes..'): '..OID_GRIDTASK_MSG_NID..' \"..nid..\"')\")\n\x09\x09addStage(\"checkRestartTime('\"..nid..\"')\")\n\x09end\nend\n\nfunction gtPrepare()\n\n\x09pushAbort(\"taskFinished()\")\n\n\x09-------------------------------------------------------------------------\n\x09addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n\x09pushAbort(\"getLocks({})\")\n\x09\n\x09-------------------------------------------------------------------------\n\x09for node in taskParams:datas(\"/UFLT\") do\n\x09\x09local nodeType = node:name()\n\x09\x09local update = \"/UFLT/\"..nodeType..\"/UPDT\"\n\x09\x09local restart = node:data(\"REST\")\n\x09\x09local targets = node:data(\"TRGT\")\n\n\x09\x09for name,_,value in targets:tuples() do\n\x09\x09\x09if (name == \"NTYP\") then\n\x09\x09\x09\x09addStage(\"getLocks({['\"..value..\"-RESOURCES'] = true})\")\n\x09\x09\n\x09\x09\x09\x09if(restart == 1) then\n\x09\x09\x09\x09\x09addStage(\"stageName(OID_GRIDTASK_STAGE_RESOURCE_UPDATE)\")\n\x09\x09\x09\x09\x09addStage(\"waitUser(OID_GRIDTASK_MSG_UFLTWAIT_TYPE..' \"..value..\"')\")\n\x09\x09\x09\x09end\n\x09\x09\x09\x09\n\x09\x09\x09\x09local nodes = actorsToList(value)\n\x09\x09\x09\x09table.sort(nodes)\x09-- As of 8.2, this task is specified to process nodes in ascending numerical NID order\n\x09\x09\x09\x09for _,nid in pairs(nodes) do\n\x09\x09\x09\x09\x09executeUPDT(nid, update, restart)\n\x09\x09\x09\x09end\n\x09\x09\x09elseif (name == \"NOID\") then\n\x09\x09\x09\x09if(restart == 1) then\n\x09\x09\x09\x09\x09addStage(\"stageName(OID_GRIDTASK_STAGE_RESOURCE_UPDATE)\")\n\x09\x09\x09\x09\x09addStage(\"waitUser(OID_GRIDTASK_MSG_UFLTWAIT_NODE..' \"..value..\"')\")\n\x09\x09\x09\x09end\n\x09\x09\x09\x09\n\x09\x09\x09\x09executeUPDT(value, update, restart)\n\x09\x09\x09end\n\x09\x09end\n\x09end\n\x09-------------------------------------------------------------------------\n\x09addStage(\"getLocks({})\")\n\x09popAbort() -- RLOK\n\x09\n\x09-------------------------------------------------------------------------\n\x09popAbort()\n\x09addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n\x09addStage(\"taskFinished()\")\n\x09\n\x09cacheStore(\"NUMN\", numNodes)\nend\n\n\nfunction gtInit()\n\x09-- Count the number of nodes to be updated, for status reporting\n\x09numNodes = cacheLoad(\"NUMN\") or 0\n\x09\n\x09-- Last init time for node restart check\n\x09initTime = cacheLoad(\"ITME\") or UINT64.new(0)\nend\n"
		END
		VFGV:CONT:
			0001:CSTR:"-- Volume Foreground Verification Task\n-- Version 1\n\n\nfunction abortVFGV()\n    -- Helper function to clean up a verification task\n    local res,reas\n\n    Debug.log(\"warn\",\"Stopping VFGV actions\")\n    for _,nid in pairs(cmnList) do\n\n        res,reas = stopAction(nid,'VFGV',gtActPc)\n        if(res ~= 1) then\n            return 0,reas\n        end\n    end\n\n    if (res ~= 1) then\n        return 0,reas\n    else\n        return 1,\"OK\"\n    end\nend\n\nfunction resetAttributes(nid)\n    return executeOnActor(nid, 'SVRA', gtActPc)\nend\n\nfunction gtPrepare()\n    -- Called once, the first time that the task is run.\n    pushAbort(\"taskFinished()\")\n    for ldr in taskParams:datas('/SLDR') do\n        pushAbort(\"resetAttributes(\"..ldr..\")\")\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\")\n    pushAbort(\"getLocks({})\")\n    addStage(\"getLocks({['GRID-FGV'] = true})\")\n\n    pushAbort(\"abortVFGV()\")\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_STARTING)\")\n\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\"startAction(\"..targetCMN..\",'VFGV',gtActPcStart)\")\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_DESC_LDR_VERIFY)\")\n    addStage(\"waitDone(cmnList, 'VFGV', gtActPcCheck)\")\n\n    addStage(\"stageName(OID_GRIDTASK_STAGE_FINISHING)\")\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\"stopAction(\"..targetCMN..\",'VFGV',gtActPc)\")\n    end\n\n    addStage(\"stageName(OID_GRIDTASK_ACTION_VERIFY_ATTR_RESET)\")\n    for ldr in taskParams:datas('/SLDR') do\n        addStage(\"resetAttributes(\"..ldr..\")\")\n    end\n\n    addStage(\"getLocks({})\")\n    popAbort() -- RLOK\n    popAbort() -- abortVFGV()\n    for ldr in taskParams:datas('/SLDR') do\n        popAbort() -- resetAttributes\n    end\n\n    popAbort()\n\n    addStage(\"stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\")\n    addStage(\"taskFinished()\")\nend\n\nfunction gtInit()\n    -- Called every time that the task is run (first time, as well as after any CMN restart).\n\n    gtActPc = AtomContainer.new{'AAPC'}\n    cmnList = actorsToList('BCMN', true)\n\n    local idx = 1\n    local noidTable = {}\n    local volIdTable = {}\n\n    for ldr in taskParams:datas('/SLDR') do\n        table.insert(noidTable, ldr)\n    end\n    for vid in taskParams:datas('/SVOL') do\n        table.insert(volIdTable, vid)\n    end\n\n    if (table.getn(noidTable) ~= table.getn(volIdTable)) then\n        Debug.log(\"err\",\"Noid and VolId pair does not match\")\n    end\n\n    local atomTableStart = {}\n    local atomTableCheck = {}\n    atomTableStart[1] = 'AAPC'\n    atomTableCheck[1] = 'CHPC'\n    for key,noid in ipairs(noidTable) do\n        local idxStr = string.format(\"%04X\", idx)\n        local volId = volIdTable[key]\n        atomTableStart[idxStr] = AtomContainer.new{idxStr, NOID={ui32 = noid}, VOID ={ui64 = volId}}\n        atomTableCheck[idxStr] = AtomContainer.new{idxStr, NOID={ui32 = noid}, VOID ={ui64 = volId}}\n        idx = idx + 1\n    end\n\n    gtActPcStart = AtomContainer.new(atomTableStart)\n    gtActPcCheck = AtomContainer.new(atomTableCheck)\nend\n"
		END
	END
END
