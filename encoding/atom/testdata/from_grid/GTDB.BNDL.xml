<?xml version="1.0" encoding="UTF-8"?>
<containerxml version="1" xmlns="http://www.bycast.com/schemas/XML-container-1.0.0">
	<container name="GTDB">
		<atom name="BVER" type="UI32" value="1"/>
		<atom name="BTIM" type="UI64" value="1484723612385978"/>
		<container name="TSKS">
			<container name="BCMT">
				<atom name="0001" type="CSTR" value="-- Bundle Commit Task&#10;-- Version 1&#10;&#10;function commitBundles(path)&#10;&#9;local result = 1&#10;&#9;local reason = OID_GRIDTASK_MSG_NONE&#10;&#9;&#10;&#9;for data in taskParams:datas(path) do&#10;&#9;&#9;data:set_name('AAPC')&#10;&#9;&#9;result,reason = executeOnOneActor('BCMN', 'BCMT', data)&#10;&#9;&#9;if(result ~= 1) then&#10;&#9;&#9;&#9;Debug.log(&quot;warn&quot;,&quot;Exiting bundle-commit loop, reason =&quot;,reason)&#10;&#9;&#9;&#9;break&#10;&#9;&#9;end&#10;&#9;end&#10;&#10;&#9;return result,reason&#10;end&#10;&#10;function gtPrepare()&#10;&#9;pushAbort(&quot;taskFinished()&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;pushAbort(&quot;getLocks({})&quot;)&#10;&#9;addStage(&quot;getLocks({['GRID-BUNDLE'] = true})&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_BUNDLE_COMMIT)&quot;)&#10;&#9;addStage(&quot;commitBundles('/')&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;getLocks({})&quot;)&#10;&#9;popAbort() -- RLOK&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;popAbort()&#10;&#9;&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;&#9;addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;end&#10;"/>
			</container>
			<container name="BDLI">
				<atom name="0001" type="CSTR" value="-- Bundle Import Task&#10;-- Version 1&#10;&#10;function addBundles(path)&#10;&#9;local result = 1&#10;&#9;local reason = OID_GRIDTASK_MSG_NONE&#10;&#9;&#10;&#9;for data in taskParams:datas(path) do&#10;&#9;&#9;data:set_name('AAPC')&#10;&#9;&#9;result,reason = executeOnOneActor('BCMN', 'BDLI', data)&#10;&#9;&#9;if(result ~= 1) then&#10;&#9;&#9;&#9;Debug.log(&quot;warn&quot;,&quot;Exiting bundle-import loop, reason =&quot;,reason)&#10;&#9;&#9;&#9;break&#10;&#9;&#9;end&#10;&#9;end&#10;&#10;&#9;return result,reason&#10;end&#10;&#10;function gtPrepare()&#10;&#9;pushAbort(&quot;taskFinished()&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;pushAbort(&quot;getLocks({})&quot;)&#10;&#9;addStage(&quot;getLocks({['GRID-BUNDLE'] = true})&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_BUNDLE_IMPORT)&quot;)&#10;&#9;addStage(&quot;addBundles('/')&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;getLocks({})&quot;)&#10;&#9;popAbort() -- RLOK&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;popAbort()&#10;&#9;&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;&#9;addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;end&#10;"/>
			</container>
			<container name="CCLE">
				<atom name="0001" type="CSTR" value="-- Nodetool cleanup task&#10;-- Version 1&#10;&#10;function waitForNewDDS(nid, value)&#10;        -- See if DDS is in the expected state&#10;        local function checkDone(nid, status)&#10;            return status:data(&quot;STCR&quot;) == value&#10;        end&#10;        return waitOnActors(nid, 'DDSS', AtomContainer.new{'CHPC'}, checkDone, true)&#10;end&#10;&#10;function gtPrepare()&#10;    pushAbort(&quot;taskFinished()&quot;)&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;    pushAbort(&quot;getLocks({})&quot;)&#10;&#10;    ---------------------------------------------------------------------------&#10;    --Check whether the new DDSs are in the expected state: cassandra up running&#10;    for nid in taskParams:datas(&quot;/NDDS&quot;) do&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_CHECKING_CASSANDRA_STATUS..': '..OID_GRIDTASK_MSG_NID..' &quot;..nid..&quot;')&quot;)&#10;        addStage(&quot;waitForNewDDS(&quot;..nid..&quot;, 'REDY')&quot;)&#10;    end&#10;&#10;    ---------------------------------------------------------------------------&#10;    -- Perform Cassandra node cleanup sequentially in old DDS nodes.&#10;    for nid in taskParams:datas(&quot;/ODDS&quot;) do&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;        addStage(&quot;getLocks({['&quot;..nid..&quot;-NODETOOL'] = true})&quot;)&#10;        pushAbort(&quot;stopAction(&quot;..nid..&quot;, 'CCLE', gtActPc)&quot;)&#10;        addStage(&quot;startAction(&quot;..nid..&quot;, 'CCLE', gtActPc)&quot;)&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_RUNNING_NODETOOL_CLEAN_UP..': '..OID_GRIDTASK_MSG_NID..' &quot;..nid..&quot;')&quot;)&#10;        addStage(&quot;waitDone(&quot;..nid..&quot;, 'CCLE', gtActPc)&quot;)&#10;    end&#10;    ---------------------------------------------------------------------------&#10;    addStage(&quot;getLocks({})&quot;)&#10;    popAbort() -- RLOK&#10;&#10;    for nid in taskParams:datas(&quot;/ODDS&quot;) do&#10;        popAbort() -- stopAction abortCCLE&#10;    end&#10;&#10;    popAbort()&#10;&#10;    addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;    addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;&#9;gtActPc = AtomContainer.new{'AAPC', TKID={ui32=taskId}}&#10;end&#10;"/>
			</container>
			<container name="CDBR">
				<atom name="0001" type="CSTR" value="-- CMS Database Recovery Grid Task&#10;-- Version 1&#10;&#10;function abortCDBR()&#10;&#9;-- Helper function to clean up a recovery task&#10;&#9;local res,reas&#10;&#10;&#9;Debug.log(&quot;warn&quot;,&quot;Stopping CMS action&quot;)&#10;&#9;for _,nid in pairs(gtCmsList) do&#10;&#9;&#9;res,reas = stopAction(nid,'CDBA',gtActPc)&#10;&#9;&#9;if(res ~= 1) then&#10;&#9;&#9;&#9;return 0,reas&#10;&#9;&#9;end&#10;&#9;end&#10;&#10;&#9;return 1,&quot;OK&quot;&#10;end&#10;&#10;function gtPrepare()&#10;&#9;-- Called once, the first time that the task is run. &#10;&#9;&#10;&#9;pushAbort(&quot;taskFinished()&quot;)&#10;&#10;&#9;pushAbort(&quot;abortCDBR()&quot;)&#10;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;pushAbort(&quot;getLocks({})&quot;)&#10;&#9;addStage(&quot;getLocks({['&quot;..gtTargetCms..&quot;-TASK-CDBR'] = true})&quot;)&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_STARTING)&quot;)&#10;&#9;Debug.log(&quot;info&quot;, &quot;NID = &quot;, gtTargetCms)&#10;&#9;&#9;&#10;&#9;for _,nid in pairs(gtCmsList) do&#10;&#9;&#9;Debug.log(&quot;info&quot;, &quot;NID = &quot;, nid)&#10;&#9;&#9;addStage(&quot;stopAction(&quot;..nid..&quot;,'CDBA',gtActPc)&quot;)&#10;&#9;end&#10;&#9;&#9;&#10;&#9;for _,nid in pairs(gtCmsList) do&#10;&#9;&#9;addStage(&quot;startAction(&quot;..nid..&quot;,'CDBA',gtActPc)&quot;)&#10;&#9;end&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_CMS_DATABASE_RECOVERY..': '..OID_GRIDTASK_MSG_NID..' &quot;..gtTargetCms..&quot;')&quot;)&#10;&#9;addStage(&quot;waitDone(gtCmsList, 'CDBA', gtActPc)&quot;)&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_FINISHING)&quot;)&#10;&#9;for _,nid in pairs(gtCmsList) do&#10;&#9;&#9;addStage(&quot;stopAction(&quot;..nid..&quot;,'CDBA',gtActPc)&quot;)&#10;&#9;end&#10;&#9;&#9;&#10;&#9;addStage(&quot;getLocks({})&quot;)&#10;&#9;popAbort() -- RLOK&#10;&#9;&#10;&#9;popAbort() -- abortCDBR()&#10;&#9;&#10;&#9;popAbort()&#10;&#9;&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;&#9;addStage(&quot;taskFinished()&quot;)&#10;&#9;&#10;&#9;-- FIXME - Save bundle to GTEN.&#10;end&#10;&#9;&#9;&#9;&#9;&#10;function gtInit()&#10;&#9;-- Called every time that the task is run (first time, as well as after any CMN restart). &#10;&#10;&#9;gtTargetCms = taskParams:data('/NOID')&#10;&#9;&#10;&#9;gtActPc = AtomContainer.new{'AAPC', NOID = {ui32 = gtTargetCms} }&#10;&#9;gtCmsList = cacheLoadList('CMSL')&#10;&#9;&#10;&#9;if(gtCmsList == nil) then&#10;&#9;&#9;gtCmsList  = coFindActors('BCMS')&#10;&#9;&#9;cacheStoreList('CMSL',gtCmsList)&#10;&#9;end&#10;end&#10;"/>
			</container>
			<container name="CDCM">
				<atom name="0001" type="CSTR" value="-- CMS Decommissioning Task&#10;-- Version 1&#10;function revokeCert(nid)&#10;--  return executeOnOneActor('BADC', 'ADBP', AtomContainer.new{'AAPC', DLVL = 'NOTE', DSTR = &quot;Revoking cert for &quot;..nid})&#10;    return executeOnOneActor('BADC', 'CRVK', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})&#10;end&#10;&#10;function removeEntity(oid)&#10;    return executeOnOneActor('BCMN', 'ANER', AtomContainer.new{'AAPC', EOID = {cstr = oid}})&#10;end&#10;&#10;function setOwnerMapping(ocms, ncms)&#10;    return executeOnOneActor('BDDS', 'COWR', AtomContainer.new{'AAPC', NIDS={ui32=ocms},  NIDD={ui32=ncms}})&#10;end&#10;&#10;function setServiceState(nid, value)&#10;    return executeOnActors(nid, 'SVST', AtomContainer.new{'AAPC', SVST={fc32=value}})&#10;end&#10;&#10;function setAuditState(nid, value)&#10;    return executeOnActors(nid, 'AUDT', AtomContainer.new{'AAPC', AUDT={fc32=value}})&#10;end&#10;&#10;function waitAudit(nid, value)&#10;    local function checkDone(nid, status)&#10;        return status:data(&quot;AQSZ&quot;) == UINT64.new(0)&#10;    end&#10;    return waitOnActors(nid, 'AUDQ', AtomContainer.new{'CHPC'}, checkDone)&#10;end&#10;&#10;function removeNode(nid, device)&#10;    return executeOnOneActor('BCMN', 'UNOD', AtomContainer.new{'AAPC', NOID = {ui32 = nid}, DTYP = {fc32 = device}})&#10;end&#10;&#10;function filterCmsList(nid)&#10;    for i=#cmsList,1,-1 do&#10;        if (nid == cmsList[i]) then&#10;            table.remove(cmsList, i)&#10;        end&#10;    end&#10;end&#10;&#10;function gtPrepare()&#10;    -- Called once, the first time that the task is run.&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;    addStage(&quot;getLocks({['BCMS-TOPOLOGY'] = true})&quot;)&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_STARTING)&quot;)&#10;&#10;    for nid in taskParams:datas(&quot;/NOID&quot;) do&#10;        filterCmsList(nid)&#10;    end&#10;&#10;    if(table.getn(cmsList) &gt; 0) then&#10;&#10;        for nid in taskParams:datas(&quot;/NOID&quot;) do&#10;            local newCms = cmsList[ math.random(table.getn(cmsList)) ]&#10;            addStage(&quot;setOwnerMapping(&quot;..nid..&quot;, &quot;..newCms..&quot; )&quot;)&#10;        end&#10;&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)&quot;)&#10;        for nid in taskParams:datas(&quot;/NOID&quot;) do&#10;            addStage(&quot;setServiceState(&quot;..nid..&quot;, 'DABL')&quot;)&#10;        end&#10;&#10;        -- TODO: CMS doesn't support these actions/checks yet.&#10;        --       Uncomment when story B-25861 is implemented.&#10;        -- addStage(&quot;stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)&quot;)&#10;        -- for nid in taskParams:datas(&quot;/NOID&quot;) do&#10;        --     addStage(&quot;setAuditState(&quot;..nid..&quot;, 'DABL')&quot;)&#10;        --     addStage(&quot;waitAudit(&quot;..nid..&quot;, 'DABL')&quot;)&#10;        -- end&#10;&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)&quot;)&#10;        for nid in taskParams:datas(&quot;/NOID&quot;) do&#10;            addStage(&quot;revokeCert(&quot;..nid..&quot;)&quot;)&#10;        end&#10;&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)&quot;)&#10;        for eoid in taskParams:datas(&quot;/EOID&quot;) do&#10;            addStage(&quot;removeEntity('&quot;..eoid..&quot;')&quot;)&#10;        end&#10;&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)&quot;)&#10;        for nid in taskParams:datas(&quot;/NOID&quot;) do&#10;            addStage(&quot;removeNode(&quot;..nid..&quot;, 'BCMS')&quot;)&#10;        end&#10;&#10;        addStage(&quot;getLocks({})&quot;)&#10;&#10;        addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;        addStage(&quot;taskFinished()&quot;)&#10;    else&#10;        Debug.log(&quot;err&quot;,&quot;Owner mapping failed. No running CMS&quot;)&#10;    end&#10;end&#10;&#10;function gtInit()&#10;    -- Called every time that the task is run (first time, as well as after any CMN restart).&#10;    gtActPc = AtomContainer.new{'AAPC'}&#10;    cmsList = actorsToList('BCMS', true)&#10;end&#10;"/>
			</container>
			<container name="CEXP">
				<atom name="0001" type="CSTR" value="-- Cassandra Site Expansion task&#10;-- Version 1&#10;function alterKeyspace(grps)&#10;    return executeOnOneActor('BDDS', 'AKEY', AtomContainer.new{'AAPC', GRPS = {ui32 = grps}})&#10;end&#10;&#10;function gtPrepare()&#10;    pushAbort(&quot;taskFinished()&quot;)&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;    pushAbort(&quot;getLocks({})&quot;)&#10;    ---------------------------------------------------------------------------&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;    addStage(&quot;getLocks({['GRID-CEXP'] = true})&quot;)&#10;&#10;    for grps in taskParams:datas(&quot;/GRPS&quot;) do&#10;        if grps then&#10;            addStage(&quot;stageName(OID_GRIDTASK_STAGE_ALTER_KEYSPACE..' Group(&quot;..grps..&quot;)')&quot;)&#10;            addStage(&quot;alterKeyspace('&quot;..grps..&quot;')&quot;)&#10;        end&#10;    end&#10;    ---------------------------------------------------------------------------&#10;    addStage(&quot;getLocks({})&quot;)&#10;    popAbort() -- RLOK&#10;    popAbort()&#10;&#10;    addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;    addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;    gtActPc = AtomContainer.new{'AAPC'}&#10;end&#10;"/>
			</container>
			<container name="CSRC">
				<atom name="0001" type="CSTR" value="-- Content Migration Cleanup Task&#10;-- Used to clean up after a corrupted volume is detected during a content migration stage of a hardware refresh task.&#10;-- Based on CSRF-1 task. Does all it does, except doesn't do the content migrate, &#10;--   and instead sends a CLOC_LOST for all objects on the source LDR&#10;-- Version 1&#10;&#10;--Storage Maintenance Mode&#10;function actionSMNT(ldr,value)&#10;&#9;return executeOnActors(ldr, 'SMNT', AtomContainer.new{'AAPC', SMNT={fc32=value}})&#10;end&#10;&#10;function actionCLDQ(ldr,value)&#10;&#9;return executeOnActors(ldr, 'CLDQ', AtomContainer.new{'AAPC', FRWD={fc32=value}})&#10;end&#10;&#10;function disableCLOCLOSTForwarding(ldr)&#10;&#9;return actionCLDQ(ldr, 'DABL')&#10;end&#10;&#10;function enableCLOCLOSTForwarding(ldr)&#10;&#9;return actionCLDQ(ldr, 'ENBL')&#10;end&#10;&#10;--Set Storage State&#10;function actionSTDS(ldr,value)&#10;&#9;return executeOnActors(ldr, 'STDS', AtomContainer.new{'AAPC', STDS={fc32=value}})&#10;end&#10;&#10;--Storage State&#10;function waitSTCR(ldr,value)&#10;&#9;-- See if Storage is in the expected state&#10;&#9;local function checkDone(nid, status)&#10;&#9;&#9;return status:data(&quot;STUS&quot;) == 'NONE' and&#10;&#9;&#9;&#9;status:data(&quot;STCR&quot;) == value&#10;&#9;end&#10;&#9;&#10;&#9;return waitOnActors(ldr, 'STCR', AtomContainer.new{'CHPC'}, checkDone)&#10;end&#10;&#10;function cmsRemap(from, to, action, skipNode)&#10;&#9;-- Called for both the LDR-remapping and CMS-remapping actions.&#10;&#9;&#10;&#9;local actPc = AtomContainer.new{'AAPC', SNID = {ui32 = from} ,DNID = {ui32 = to} }&#10;&#9;&#10;&#9;local cmsList = { }&#10;&#9;local tmpList = coFindActors('BCMS')&#10;&#9;&#10;&#9;local seq = 1&#10;&#9;for _,nid in pairs(tmpList) do&#10;&#9;&#9;-- The now-revoked gtSourceCms node ID may still show up in the coFindActors query response, and must be filtered here.&#10;&#9;&#9;&#10;&#9;&#9;if(nid ~= skipNode) then&#10;&#9;&#9;&#9;cmsList[seq] = nid&#10;&#9;&#9;&#9;seq = seq + 1&#10;&#9;&#9;else&#10;&#9;&#9;&#9;Debug.log(&quot;note&quot;,&quot;Excluding NID &quot;..skipNode..&quot;from coFindActors() response&quot;)&#10;&#9;&#9;end&#10;&#9;end&#10;&#10;&#9;return executeOnActors(cmsList, action, actPc)&#10;end&#10;&#10;function revokeCert(nid)&#10;&#9;return executeOnOneActor('BADC', 'CRVK', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})&#10;end&#10;&#10;function removeEntity(oid)&#10;&#9;return executeOnOneActor('BCMN', 'ANER', AtomContainer.new{'AAPC', EOID = {cstr = oid}})&#10;end&#10;&#10;function setServiceState(nid, value)&#10;&#9;return executeOnActors(nid, 'SVST', AtomContainer.new{'AAPC', SVST={fc32=value}})&#10;end&#10;&#10;function setAuditState(nid, value)&#10;&#9;return executeOnActors(nid, 'AUDT', AtomContainer.new{'AAPC', AUDT={fc32=value}})&#10;end&#10;&#10;function waitAudit(nid, value)&#10;&#9;local function checkDone(nid, status)&#10;&#9;&#9;return status:data(&quot;AQSZ&quot;) == UINT64.new(0)&#10;&#9;end&#10;&#9;return waitOnActors(nid, 'AUDQ', AtomContainer.new{'CHPC'}, checkDone)&#10;end&#10;&#10;function removeGrade(nid)&#10;&#9;return executeOnOneActor('BCMN', 'USTG', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})&#10;end&#10;&#10;function removeNode(nid, device)&#10;&#9;return executeOnOneActor('BCMN', 'UNOD', AtomContainer.new{'AAPC', NOID = {ui32 = nid}, DTYP = {fc32 = device}})&#10;end&#10;&#10;function checkOnline(nid)&#10;&#9;-- Uses the &quot;Version Check&quot; check to make sure that the target node is reachable. Doesn't care about the actual version.&#10;&#9;&#10;&#9;local resp = postCheckAsk(nid, 'CSWV', AtomContainer.new{'CHPC'})&#10;&#10;&#9;if(resp:data('/RSLT') == 'SUCS') then&#10;&#9;&#9;return 1, &quot;OK&quot;&#10;&#9;else&#10;&#9;&#9;return 0, OID_GRIDTASK_MSG_CHECK_FAILED..&quot; - &quot;..OID_GRIDTASK_MSG_NID..&quot; &quot;..nid&#10;&#9;end&#10;&#10;end&#10;&#10;function checkTargetExists(nid, dtype)&#10;&#9;-- FIXME - This is inefficient; replace with a direct &quot;certificate lookup&quot; check once a proper Certificate grid service has been implemented.&#10;&#9;&#10;&#9;exists = false&#10;&#9;&#10;&#9;tmpList = coFindActors(dtype)&#10;&#9;&#10;&#9;for _,foundnid in pairs(tmpList) do&#10;&#9;&#9;if(nid == foundnid) then&#10;&#9;&#9;&#9;exists = true&#10;&#9;&#9;end&#10;&#9;end&#10;&#9;&#10;&#9;if(exists) then&#10;&#9;&#9;return 1, &quot;OK&quot;&#10;&#9;else&#10;&#9;&#9;return 0, OID_GRIDTASK_MSG_NOID_NOT_FOUND..nid&#9;&#10;&#9;end&#10;end&#10;&#10;function sendObjectLost(ldr)&#10;&#9;return executeOnOneActor('BLDR', 'OLOA', AtomContainer.new{'AAPC', SNID = {ui32 = ldr}})&#10;end&#10;&#10;function gtPrepare()&#10;&#9;-- Called once, the first time that the task is run. &#10;&#10;&#9;pushAbort(&quot;taskFinished()&quot;)&#10;&#9;&#10;&#9;-- Make sure that DLDR and DCMS (if specified) exist in the grid. This is done before the topology lock&#10;&#9;-- is acquired, so that it's still possible for the user to recover if he/she forgot to run the expansion tasks&#10;&#9;-- before starting this Cleanup task.&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_VERIFY_TARGETS_EXIST)&quot;)&#10;&#9;&#10;&#9;if (gtDestCms) then&#10;&#9;&#9;addStage(&quot;checkTargetExists(&quot;..gtDestCms..&quot;,'BCMS')&quot;)&#10;&#9;end&#10;&#9;&#10;&#9;if (gtDestLdr) then&#10;&#9;&#9;addStage(&quot;checkTargetExists(&quot;..gtDestLdr..&quot;,'BLDR')&quot;)&#10;&#9;end&#10;&#9;&#10;&#9;popAbort()&#9;-- Abort not permitted beyond this point&#10;&#9;&#9;&#10;&#9;if gtSourceLdr then&#10;&#9;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;&#9;addStage(&quot;getLocks({['&quot;..gtDestLdr..&quot;-STORAGE'] = true})&quot;)&#10;&#9;&#9;&#10;&#9;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_STORAGE_STATE_WAIT)&quot;)&#10;&#9;&#9;addStage(&quot;waitSTCR(&quot;..gtDestLdr..&quot;,'READ')&quot;)&#10;&#10;&#9;&#9;addStage(&quot;disableCLOCLOSTForwarding(&quot;..gtDestLdr..&quot;)&quot;)&#10;&#10;&#9;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_SEND_OBJECT_LOST)&quot;)&#10;&#9;&#9;addStage(&quot;sendObjectLost(&quot;..gtSourceLdr..&quot;)&quot;)&#10;&#9;&#9;&#10;&#9;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;&#9;addStage(&quot;getLocks({['&quot;..gtDestLdr..&quot;-STORAGE'] = true, ['BCMS-TOPOLOGY'] = false})&quot;)&#10;&#10;&#9;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_CONTENT_REMAP)&quot;)&#10;&#9;&#9;addStage(&quot;cmsRemap(&quot;..gtSourceLdr..&quot;,&quot;..gtDestLdr..&quot;, 'LRMP', gtSourceCms)&quot;)&#10;&#9;&#9;addStage(&quot;getLocks({['&quot;..gtDestLdr..&quot;-STORAGE'] = true})&quot;)&#10;&#10;&#9;&#9;addStage(&quot;enableCLOCLOSTForwarding(&quot;..gtDestLdr..&quot;)&quot;)&#10;&#10;&#9;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)&quot;)&#10;&#9;&#9;addStage(&quot;actionSTDS(&quot;..gtDestLdr..&quot;,'RDWR')&quot;)&#10;&#9;end&#10;&#9;&#10;&#9;local sourceNodes = {BADC = gtSourceAdc, BSSM = gtSourceSsm}&#10;&#9;&#10;&#9;local locks = &quot;['GRID-BUNDLE'] = true&quot;&#10;&#9;for nodeType, nid in pairs(sourceNodes) do&#10;&#9;&#9;locks = locks..&quot;, ['&quot;..nodeType..&quot;-TOPOLOGY'] = true&quot;&#10;&#9;end&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;addStage(&quot;getLocks({&quot;..locks..&quot;})&quot;)&#10;&#9;&#10;&#9;for nodeType, nid in pairs(sourceNodes) do&#10;&#9;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)&quot;)&#10;&#9;&#9;addStage(&quot;setServiceState(&quot;..nid..&quot;, 'DABL')&quot;)&#10;&#9;&#9;&#10;&#9;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)&quot;)&#10;&#9;&#9;addStage(&quot;setAuditState(&quot;..nid..&quot;, 'DABL')&quot;)&#10;&#9;&#9;addStage(&quot;waitAudit(&quot;..nid..&quot;)&quot;)&#10;&#9;end&#10;&#9;&#10;&#9;local revokeNodes = {BLDR = gtSourceLdr, BADC = gtSourceAdc, BSSM = gtSourceSsm}&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)&quot;)&#10;&#9;for nodeType, nid in pairs(revokeNodes) do&#10;&#9;&#9;addStage(&quot;revokeCert(&quot;..nid..&quot;)&quot;)&#10;&#9;end&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)&quot;)&#10;&#9;addStage(&quot;removeEntity('&quot;..gtSourceOid..&quot;')&quot;)&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)&quot;)&#10;&#9;&#10;&#9;for nodeType, nid in pairs(revokeNodes) do&#10;&#9;&#9;addStage(&quot;removeNode(&quot;..nid..&quot;, '&quot;..nodeType..&quot;')&quot;)&#10;&#9;end&#10;&#9;&#10;&#9;if gtSourceLdr then&#10;&#9;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_GRADE_REMOVE)&quot;)&#10;&#9;&#9;addStage(&quot;removeGrade(&quot;..gtSourceLdr..&quot;)&quot;)&#10;&#9;end&#10;&#9;&#10;&#9;addStage(&quot;getLocks({})&quot;)&#10;&#9;&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;&#9;addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;&#9;-- Called every time that the task is run (first time, as well as after any CMN restart). &#10;&#10;&#9;-- Depending on the node type, some of these may be null. &#10;&#9;gtSourceLdr = taskParams:data('/SLDR')&#10;&#9;gtDestLdr = taskParams:data('/DLDR')&#10;&#9;gtSourceCms = taskParams:data('/SCMS')&#10;&#9;gtDestCms = taskParams:data('/DCMS')&#10;&#9;&#10;&#9;gtSourceAdc = taskParams:data('/SADC')&#9;-- No &quot;Dest&quot; needed for ADC and SSM; just decommission the Src nodes&#10;&#9;gtSourceSsm = taskParams:data('/SSMN')&#10;&#9;&#10;&#9;gtSourceOid = taskParams:data('/EOID')&#9;-- OID for the server&#10;&#9;&#10;&#9;if gtDestLdr then&#10;&#9;&#9;gtActPc = AtomContainer.new{'AAPC', DNID = {ui32 = gtDestLdr} }&#10;&#9;end&#10;end&#10;"/>
			</container>
			<container name="CSRF">
				<atom name="0001" type="CSTR" value="-- Control/Storage Hardware Refresh Task (replaces LMIG)&#10;-- When splitting a combo-node ([A]GCSN) this task must be run after the Admin/Gateway ones.&#10;-- Version 1&#10;&#10;function actionSMNT(ldr,value)&#10;    return executeOnActors(ldr, 'SMNT', AtomContainer.new{'AAPC', SMNT={fc32=value}})&#10;end&#10;&#10;function actionCLDQ(ldr,value)&#10;    return executeOnActors(ldr, 'CLDQ', AtomContainer.new{'AAPC', FRWD={fc32=value}})&#10;end&#10;&#10;function disableCLOCLOSTForwarding(ldr)&#10;    return actionCLDQ(ldr, 'DABL')&#10;end&#10;&#10;function enableCLOCLOSTForwarding(ldr)&#10;    return actionCLDQ(ldr, 'ENBL')&#10;end&#10;&#10;function actionSTDS(ldr,value)&#10;    return executeOnActors(ldr, 'STDS', AtomContainer.new{'AAPC', STDS={fc32=value}})&#10;end&#10;&#10;function waitSTCR(ldr,value)&#10;    -- See if Storage is in the expected state&#10;    local function checkDone(nid, status)&#10;        return status:data(&quot;STUS&quot;) == 'NONE' and&#10;            status:data(&quot;STCR&quot;) == value&#10;    end&#10;&#10;    return waitOnActors(ldr, 'STCR', AtomContainer.new{'CHPC'}, checkDone)&#10;end&#10;&#10;function getCMSnodeIDs(gndsAtomContainer)&#10;    if gndsAtomContainer == nil then&#10;&#10;        -- Don't core dump. Just return an empty CMS node ID list.&#10;        Debug.log(&quot;warn&quot;, &quot;Error: gndsAtomContainer is nil.&quot;)&#10;        return {}&#10;    end&#10;&#10;    local nids = gndsAtomContainer:data(&quot;/GNID/AVAL&quot;)&#10;    local types = gndsAtomContainer:data(&quot;/GNTP/AVAL&quot;)&#10;&#10;    if nids == nil or types == nil then&#10;        Debug.log(&quot;warn&quot;, &quot;Error: Node ID and/or node type information missing from cached GNDS bundle.&quot;)&#10;        return {}&#10;    end&#10;&#10;    local numNids = nids:length()&#10;    local numTypes = types:length()&#10;&#10;    if numNids ~= numTypes then&#10;        Debug.log(&quot;warn&quot;,&quot;Error: Number of node IDs does not match number of node types.&quot;)&#10;        return nil&#10;    end&#10;&#10;    local cmsids = {}&#10;&#10;    for num = 2,numNids do&#10;        local nid = gndsAtomContainer:data(&quot;/GNID/AVAL&quot;):data(num)&#10;        local typ = gndsAtomContainer:data(&quot;/GNTP/AVAL&quot;):data(num)&#10;&#10;        if typ == &quot;BCMS&quot; then&#10;            table.insert(cmsids, nid)&#10;        end&#10;    end&#10;&#10;    return cmsids&#10;end&#10;&#10;function elementInTable(element, table)&#10;    if element == nil or table == nil then&#10;        return false&#10;    end&#10;&#10;    for _,v in pairs(table) do&#10;        if v == element then&#10;            return true&#10;        end&#10;    end&#10;&#10;    return false&#10;end&#10;&#10;function cmsRemap(from, to, action, skipNode)&#10;    -- Called for both the LDR-remapping and CMS-remapping actions.&#10;    &#10;    local actPc = AtomContainer.new{'AAPC', SNID = {ui32 = from} ,DNID = {ui32 = to} }&#10;&#10;    local cmsList = { }&#10;    local tmpList = coFindActors('BCMS')&#10;&#10;    local gndsAtomCont = Module.getatom():data(&quot;/conf/GNDS&quot;)&#10;&#10;    local gndsCMSids = getCMSnodeIDs(gndsAtomCont)&#10;&#10;    local seq = 1&#10;    for _,nid in pairs(tmpList) do&#10;        -- The now-revoked gtSourceCms node ID may still show up in the coFindActors query response, and must be filtered here.&#10;&#10;        if(nid ~= skipNode and elementInTable(nid, gndsCMSids)) then&#10;            cmsList[seq] = nid&#10;            seq = seq + 1&#10;        else&#10;            Debug.log(&quot;note&quot;,&quot;Excluding NID &quot;..skipNode..&quot;from coFindActors() response&quot;)&#10;        end&#10;    end&#10;&#10;    return executeOnActors(cmsList, action, actPc)&#10;end&#10;&#10;function revokeCert(nid)&#10;    return executeOnOneActor('BADC', 'CRVK', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})&#10;end&#10;&#10;function removeEntity(oid)&#10;    return executeOnOneActor('BCMN', 'ANER', AtomContainer.new{'AAPC', EOID = {cstr = oid}})&#10;end&#10;&#10;function setServiceState(nid, value)&#10;    return executeOnActors(nid, 'SVST', AtomContainer.new{'AAPC', SVST={fc32=value}})&#10;end&#10;&#10;function setAuditState(nid, value)&#10;    return executeOnActors(nid, 'AUDT', AtomContainer.new{'AAPC', AUDT={fc32=value}})&#10;end&#10;&#10;function waitAudit(nid, value)&#10;    local function checkDone(nid, status)&#10;        return status:data(&quot;AQSZ&quot;) == UINT64.new(0)&#10;    end&#10;    return waitOnActors(nid, 'AUDQ', AtomContainer.new{'CHPC'}, checkDone)&#10;end&#10;&#10;function removeGrade(nid)&#10;    return executeOnOneActor('BCMN', 'USTG', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})&#10;end&#10;&#10;function removeNode(nid, device)&#10;    return executeOnOneActor('BCMN', 'UNOD', AtomContainer.new{'AAPC', NOID = {ui32 = nid}, DTYP = {fc32 = device}})&#10;end&#10;&#10;function checkOnline(nid)&#10;    -- Uses the &quot;Version Check&quot; check to make sure that the target node is reachable. Doesn't care about the actual version.&#10;&#10;    local resp = postCheckAsk(nid, 'CSWV', AtomContainer.new{'CHPC'})&#10;&#10;    if(resp:data('/RSLT') == 'SUCS') then&#10;        return 1, &quot;OK&quot;&#10;    else&#10;        return 0, OID_GRIDTASK_MSG_CHECK_FAILED..&quot; - &quot;..OID_GRIDTASK_MSG_NID..&quot; &quot;..nid&#10;    end&#10;&#10;end&#10;&#10;function checkTargetExists(nid, dtype)&#10;    -- FIXME - This is inefficient; replace with a direct &quot;certificate lookup&quot; check once a proper Certificate grid service has been implemented.&#10;&#10;    exists = false&#10;&#10;    tmpList = coFindActors(dtype)&#10;&#10;    for _,foundnid in pairs(tmpList) do&#10;        if(nid == foundnid) then&#10;            exists = true&#10;        end&#10;    end&#10;&#10;    if(exists) then&#10;        return 1, &quot;OK&quot;&#10;    else&#10;        return 0, OID_GRIDTASK_MSG_NOID_NOT_FOUND..nid&#10;    end&#10;end&#10;&#10;function gtPrepare()&#10;    -- Called once, the first time that the task is run.&#10;&#10;    pushAbort(&quot;taskFinished()&quot;)&#10;&#10;    -- Make sure that DLDR and DCMS (if specified) exist in the grid. This is done before the topology lock&#10;    -- is acquired, so that it's still possible for the user to recover if he/she forgot to run the expansion tasks&#10;    -- before starting this Refresh task.&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_VERIFY_TARGETS_EXIST)&quot;)&#10;&#10;    if (gtDestCms) then&#10;        addStage(&quot;checkTargetExists(&quot;..gtDestCms..&quot;,'BCMS')&quot;)&#10;    end&#10;&#10;    if (gtDestLdr) then&#10;        addStage(&quot;checkTargetExists(&quot;..gtDestLdr..&quot;,'BLDR')&quot;)&#10;    end&#10;&#10;    popAbort()  -- Abort not permitted during CMS migration&#10;&#10;    if gtSourceCms then&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;        addStage(&quot;getLocks({['&quot;..gtSourceCms..&quot;-STORAGE'] = true, ['&quot;..gtDestCms..&quot;-STORAGE'] = true, ['BCMS-TOPOLOGY'] = true, ['CMS-REMAP'] = true})&quot;)&#10;        &#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)&quot;)&#10;        addStage(&quot;setServiceState(&quot;..gtSourceCms..&quot;, 'DABL')&quot;)  -- Stop client services&#10;        addStage(&quot;cmsRemap(&quot;..gtSourceCms..&quot;,&quot;..gtDestCms..&quot;, 'CRMP', gtDestCms)&quot;)&#10;        addStage(&quot;getLocks({['&quot;..gtSourceCms..&quot;-STORAGE'] = true, ['&quot;..gtDestCms..&quot;-STORAGE'] = true, ['BCMS-TOPOLOGY'] = true})&quot;)&#10;&#10;        -- Note - Audit is not flushed because database gets migrated to DestCMS. Expected that any queued audit&#10;        -- messages will be flushed by the new node, even if they were generated by the old node.&#10;&#10;        -- Pause the task and instruct the user to run the cms-refresh.sh script &#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_CMS_MIGRATION)&quot;)     &#10;        addStage(&quot;waitUser(OID_GRIDTASK_MSG_CLONE_CMS_DB)&quot;) &#10;        &#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_FINISH_CMS_MIGRATION)&quot;)  &#10;        addStage(&quot;checkOnline(&quot;..gtDestCms..&quot;)&quot;)&#10;        addStage(&quot;checkIfIdInGNDS(&quot;..gtDestCms..&quot;)&quot;)&#10;&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;        addStage(&quot;getLocks({['&quot;..gtSourceCms..&quot;-STORAGE'] = true, ['BCMS-TOPOLOGY'] = true, ['GRID-BUNDLE'] = true})&quot;)&#10;&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)&quot;)&#10;        addStage(&quot;revokeCert(&quot;..gtSourceCms..&quot;)&quot;) -- Revoked here so that it is not targeted in the following cmsRemap action&#10;&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)&quot;)&#10;        addStage(&quot;removeNode(&quot;..gtSourceCms..&quot;, 'BCMS')&quot;)&#10;    end&#10;&#10;    if gtSourceLdr then&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;        addStage(&quot;getLocks({['&quot;..gtSourceLdr..&quot;-STORAGE'] = true, ['&quot;..gtDestLdr..&quot;-STORAGE'] = true})&quot;)&#10;&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_STORAGE_STATE_WAIT)&quot;)&#10;        addStage(&quot;waitSTCR(&quot;..gtDestLdr..&quot;,'READ')&quot;)&#10;&#10;        pushAbort(&quot;taskFinished()&quot;)&#10;        pushAbort(&quot;enableCLOCLOSTForwarding(&quot;..gtDestLdr..&quot;)&quot;)&#10;        addStage(&quot;disableCLOCLOSTForwarding(&quot;..gtDestLdr..&quot;)&quot;)&#10;&#10;        addStage(&quot;actionSMNT(&quot;..gtSourceLdr..&quot;,'ENBL')&quot;)&#10;&#10;        pushAbort(&quot;getLocks({})&quot;)&#10;        &#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_CONTENT_MIGRATE)&quot;)&#10;        pushAbort(&quot;stopAction(&quot;..gtSourceLdr..&quot;,'LMIG',gtActPc)&quot;)&#10;        addStage(&quot;startAction(&quot;..gtSourceLdr..&quot;,'LMIG',gtActPc)&quot;)&#10;        addStage(&quot;waitDone(&quot;..gtSourceLdr..&quot;, 'LMIG', gtActPc)&quot;)&#10;        addStage(&quot;stopAction(&quot;..gtSourceLdr..&quot;,'LMIG',gtActPc)&quot;)&#10;&#10;        popAbort() -- remove locks&#10;        popAbort() -- enableCLOCLOSTForwarding&#10;        popAbort() -- abort not permitted beyond this point. &#10;&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;        addStage(&quot;getLocks({['&quot;..gtSourceLdr..&quot;-STORAGE'] = true, ['&quot;..gtDestLdr..&quot;-STORAGE'] = true, ['BCMS-TOPOLOGY'] = false, ['CMS-REMAP'] = true})&quot;)&#10;&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_CONTENT_REMAP)&quot;)&#10;        addStage(&quot;cmsRemap(&quot;..gtSourceLdr..&quot;,&quot;..gtDestLdr..&quot;, 'LRMP', gtSourceCms)&quot;)&#10;        addStage(&quot;getLocks({['&quot;..gtSourceLdr..&quot;-STORAGE'] = true, ['&quot;..gtDestLdr..&quot;-STORAGE'] = true})&quot;)&#10;&#10;        -- enableCLOCLOSTForwarding&#10;        addStage(&quot;enableCLOCLOSTForwarding(&quot;..gtDestLdr..&quot;)&quot;)&#10;&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)&quot;)&#10;        addStage(&quot;actionSTDS(&quot;..gtDestLdr..&quot;,'RDWR')&quot;)&#10;        addStage(&quot;actionSTDS(&quot;..gtSourceLdr..&quot;,'OFLN')&quot;)&#10;    end&#10;&#10;    -- Using this way of creating a list of nodeTypes mapped to nodeIds and using ipairs() because unit tests expect ordering which&#10;    -- pairs() doesn't guarantee.&#10;    local ldrSource = {nt = 'BLDR', nid = gtSourceLdr}&#10;    local adcSource = {nt = 'BADC', nid = gtSourceAdc}&#10;    local ssmSource = {nt = 'BSSM', nid = gtSourceSsm}&#10;    local ddsSource = {nt = 'BDDS', nid = gtSourceDds}&#10;&#10;    local sourceNodes = {}&#10;&#10;    if(gtSourceLdr) then&#10;        table.insert(sourceNodes, ldrSource)&#10;    end&#10;    if(gtSourceAdc) then&#10;        table.insert(sourceNodes, adcSource)&#10;    end&#10;    if(gtSourceSsm) then&#10;        table.insert(sourceNodes, ssmSource)&#10;    end&#10;    if(gtSourceDds) then&#10;        table.insert(sourceNodes, ddsSource)&#10;    end&#10;&#10;    if (gtSourceDds) then&#10;        addStage(&quot;stopAction(&quot;..gtSourceDds..&quot;, 'CCLE', AtomContainer.new{'AAPC'})&quot;)&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;        addStage(&quot;getLocks({['&quot;..gtSourceDds..&quot;-NODETOOL'] = true, ['NODETOOL_DECOMMISSION'] = true})&quot;)&#10;&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_CASSANDRA_NODETOOL_DECOMMISSION)&quot;)&#10;        addStage(&quot;startAction(&quot;..gtSourceDds..&quot;, 'NDEC', AtomContainer.new{'AAPC', NOID = {ui32 = &quot;..gtSourceDds..&quot;}})&quot;)&#10;        addStage(&quot;waitDone(&quot;..gtSourceDds..&quot;, 'NDEC', gtActPc)&quot;)&#10;    end&#10;&#10;&#10;    local locks = &quot;['GRID-BUNDLE'] = true&quot;&#10;    for _,data in ipairs(sourceNodes) do&#10;        locks = locks..&quot;, ['&quot;..data['nt']..&quot;-TOPOLOGY'] = true&quot;&#10;    end&#10;    if gtSourceLdr then&#10;        locks = locks..&quot;, ['&quot;..gtSourceLdr..&quot;-STORAGE'] = true&quot;&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;    addStage(&quot;getLocks({&quot;..locks..&quot;})&quot;)&#10;&#10;    for _,data in ipairs(sourceNodes) do&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)&quot;)&#10;        addStage(&quot;setServiceState(&quot;..data['nid']..&quot;, 'DABL')&quot;)&#10;&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)&quot;)&#10;        addStage(&quot;setAuditState(&quot;..data['nid']..&quot;, 'DABL')&quot;)&#10;        addStage(&quot;waitAudit(&quot;..data['nid']..&quot;)&quot;)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)&quot;)&#10;    for _,data in ipairs(sourceNodes) do&#10;        addStage(&quot;revokeCert(&quot;..data['nid']..&quot;)&quot;)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)&quot;)&#10;    addStage(&quot;removeEntity('&quot;..gtSourceOid..&quot;')&quot;)&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)&quot;)&#10;&#10;    for _,data in ipairs(sourceNodes) do&#10;        addStage(&quot;removeNode(&quot;..data['nid']..&quot;, '&quot;..data['nt']..&quot;')&quot;)&#10;    end&#10;&#10;    if gtSourceLdr then&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_GRADE_REMOVE)&quot;)&#10;        addStage(&quot;removeGrade(&quot;..gtSourceLdr..&quot;)&quot;)&#10;    end&#10;&#10;    addStage(&quot;getLocks({})&quot;)&#10;&#10;    addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;    addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;    -- Called every time that the task is run (first time, as well as after any CMN restart). &#10;&#10;    -- Depending on the node type, some of these may be null. &#10;    gtSourceLdr = taskParams:data('/SLDR')&#10;    gtDestLdr = taskParams:data('/DLDR')&#10;    gtSourceCms = taskParams:data('/SCMS')&#10;    gtDestCms = taskParams:data('/DCMS')&#10;&#10;    gtSourceAdc = taskParams:data('/SADC')  -- No &quot;Dest&quot; needed for ADC, SSM &amp; DDS; just decommission the Src nodes&#10;    gtSourceSsm = taskParams:data('/SSMN')&#10;    gtSourceDds = taskParams:data('/SDDS')&#10;&#10;    gtSourceOid = taskParams:data('/EOID')  -- OID for the server&#10;&#10;    if gtDestLdr then&#10;        gtActPc = AtomContainer.new{'AAPC', DNID = {ui32 = gtDestLdr} }&#10;    end&#10;end&#10;"/>
			</container>
			<container name="CTNL">
				<atom name="0001" type="CSTR" value="-- Object Location Indexing Conversion Grid Task&#10;-- Version 1&#10;&#10;function abortCTNL()&#10;&#9;-- Helper function to clean up a conversion task&#10;&#9;local res,reas&#10;&#10;&#9;Debug.log(&quot;warn&quot;,&quot;Stopping CMS action&quot;)&#10;&#9;res,reas = stopAction(gtTargetCms,'CNLT',gtActPc)&#10;&#10;&#9;if(res ~= 1) then&#10;&#9;&#9;return 0,reas&#10;&#9;else&#10;&#9;&#9;return 1,&quot;OK&quot;&#10;&#9;end&#10;end&#10;&#10;function gtPrepare()&#10;&#9;-- Called once, the first time that the task is run. &#10;&#9;&#10;&#9;pushAbort(&quot;taskFinished()&quot;)&#10;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;pushAbort(&quot;getLocks({})&quot;)&#10;&#9;addStage(&quot;getLocks({['&quot;..gtTargetCms..&quot;-TASK-CTNL'] = true})&quot;)&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_STARTING)&quot;)&#10;&#9;Debug.log(&quot;info&quot;, &quot;NID = &quot;, gtTargetCms)&#10;&#9;&#10;&#9;pushAbort(&quot;abortCTNL()&quot;)&#10;&#9;addStage(&quot;stopAction(&quot;..gtTargetCms..&quot;,'CNLT',gtActPc)&quot;)&#10;&#9;&#9;&#10;&#9;addStage(&quot;startAction(&quot;..gtTargetCms..&quot;,'CNLT',gtActPc)&quot;)&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_OBJECT_LOCATION_INDEXING_CONVERSION)&quot;)&#10;&#9;addStage(&quot;waitDone(gtTargetCms, 'CNLT', gtActPc)&quot;)&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_FINISHING)&quot;)&#10;&#9;addStage(&quot;stopAction(&quot;..gtTargetCms..&quot;,'CNLT',gtActPc)&quot;)&#10;&#9;&#9;&#10;&#9;addStage(&quot;getLocks({})&quot;)&#10;&#9;popAbort() -- RLOK&#10;&#9;&#10;&#9;popAbort() -- abortCTNL()&#10;&#9;&#10;&#9;popAbort()&#10;&#9;&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;&#9;addStage(&quot;taskFinished()&quot;)&#10;&#9;&#10;&#9;-- FIXME - Save bundle to GTEN.&#10;end&#10;&#9;&#9;&#9;&#9;&#10;function gtInit()&#10;&#9;-- Called every time that the task is run (first time, as well as after any CMN restart). &#10;&#10;&#9;gtTargetCms = taskParams:data('/NOID')&#10;&#9;&#10;&#9;gtActPc = AtomContainer.new{'AAPC'}&#10;end&#10;"/>
			</container>
			<container name="CUPD">
				<atom name="0001" type="CSTR" value="-- Certificate Update Task&#10;-- Version 1&#10;&#10;function addCert(nid, certpath, adc)&#10;&#9;local cert = taskParams:data(certpath)&#10;&#9;&#10;&#9;local action = AtomContainer.new{'AAPC', NOID = {ui32 = nid}, CERT = {data = cert}}&#10;&#10;&#9;if adc then&#10;&#9;&#9;return executeOnOneActor('BADC', 'CUPD', action)&#10;&#9;else&#10;&#9;&#9;return executeOnActors(nid, 'CUPD', action)&#10;&#9;end&#10;end&#10;&#10;function shutdownNode(nid)&#10;&#9;return executeOnActors(nid, 'SHDN', AtomContainer.new{'AAPC', DELY = {ui64 = 10000000}})&#10;end&#10;&#10;function gtPrepare()&#10;&#9;pushAbort(&quot;taskFinished()&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_CERT_UPDATE)&quot;)&#10;&#9;&#10;&#9;for node in taskParams:datas(&quot;/NODS&quot;) do&#10;&#9;&#9;local nid = node:data(&quot;NOID&quot;)&#10;&#9;&#9;local cert = &quot;/NODS/&quot;..node:name()..&quot;/CERT&quot;&#10;&#9;&#9;local mode = node:data(&quot;MODE&quot;) or &quot;BOTH&quot;&#10;&#9;&#9;&#10;&#9;&#9;if mode == &quot;BOTH&quot; then&#10;&#9;&#9;&#9;-- Update cert on target node&#10;&#9;&#9;&#9;addStage(&quot;addCert(&quot;..nid..&quot;,'&quot;..cert..&quot;')&quot;)&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;-- Shutdown (restart) target node&#10;&#9;&#9;&#9;addStage(&quot;shutdownNode(&quot;..nid..&quot;)&quot;)&#10;&#9;&#9;end&#10;&#9;&#9;&#10;&#9;&#9;-- Update cert on ADC&#10;&#9;&#9;addStage(&quot;addCert(&quot;..nid..&quot;,'&quot;..cert..&quot;',true)&quot;)&#10;&#9;&#9;&#10;&#9;end&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;popAbort()&#10;&#9;&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;&#9;addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;end&#10;"/>
			</container>
			<container name="EBUN">
				<atom name="0001" type="CSTR" value="-- Edit Bundles Task&#10;-- Version 1&#10;&#10;function editBundle(bundleNumber)&#10;&#10;&#9;return executeOnOneActor('BCMN', 'EBUN',AtomContainer.new{'AAPC', &#10;&#9;EBUN = taskParams:data(&quot;/EBUN/&quot;..bundleNumber)} )&#10;end&#10;&#10;function gtPrepare()&#10;&#10;&#9;pushAbort(&quot;taskFinished()&quot;)&#10;&#10;&#9;-------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;pushAbort(&quot;getLocks({})&quot;)&#10;&#9;addStage(&quot;getLocks({['GRID-BUNDLE'] = true})&quot;)&#10;&#9;&#10;&#9;-------------------------------------------------------------------------&#10;&#9;for bundle in taskParams:datas(&quot;/EBUN&quot;) do&#10;&#9;&#9;local bundleNumber = bundle:name()&#10;&#9;&#9;local bundleName = bundle:data(&quot;/BLNM&quot;)&#10;&#9;&#9;&#10;&#9;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_EDIT_BUNDLE..'(&quot;..bundleName..&quot;)')&quot;)&#10;&#9;&#9;addStage(&quot;editBundle('&quot;..bundleNumber..&quot;')&quot;)&#10;&#10;&#9;end&#10;&#9;-------------------------------------------------------------------------&#10;&#9;addStage(&quot;getLocks({})&quot;)&#10;&#9;popAbort() -- RLOK&#10;&#9;&#10;&#9;-------------------------------------------------------------------------&#10;&#9;popAbort()&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;&#9;addStage(&quot;taskFinished()&quot;)&#10;&#9;&#10;end&#10;&#10;&#10;function gtInit()&#10;end&#10;"/>
			</container>
			<container name="ENRM">
				<atom name="0001" type="CSTR" value="-- Entity Remove Task&#10;-- Version 1&#10;&#10;&#10;function removeEntity(oid)&#10;&#9;return executeOnOneActor('BCMN', 'ANER', AtomContainer.new{'AAPC', EOID = {cstr = oid}})&#10;end&#10;&#10;function gtPrepare()&#10;&#9;-- Called once, the first time that the task is run. &#10;&#9;&#10;&#9;pushAbort(&quot;taskFinished()&quot;)&#10;&#9;&#10;&#9;-----------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;pushAbort(&quot;getLocks({})&quot;)&#10;&#9;addStage(&quot;getLocks({['GRID-BUNDLE'] = true})&quot;)&#10;&#10;&#9;-----------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)&quot;)&#10;&#10;&#9;for eoid in taskParams:datas(&quot;/&quot;) do&#10;&#9;&#9;addStage(&quot;removeEntity('&quot;..eoid..&quot;')&quot;)&#10;&#9;end&#10;&#10;&#9;-----------------------------------------------------------&#10;&#9;addStage(&quot;getLocks({})&quot;)&#10;&#9;popAbort() -- RLOK&#10;&#9;popAbort()&#10;&#9;&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;&#9;addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;&#9;-- Called every time that the task is run (first time, as well as after any CMN restart). &#10;&#9;&#10;end&#10;"/>
			</container>
			<container name="GDCM">
				<atom name="0001" type="CSTR" value="-- Generic Node Decommissioning/Refresh Task&#10;-- Version 1&#10;&#10;-- Currently supports the following node types: ADC, AMS, CLB, CMN, NMS, SSM&#10;-- TODO Support LDR, CMS, ARC&#10;&#10;function revokeCert(nid)&#10;   return executeOnOneActor('BADC', 'CRVK', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})&#10;end&#10;&#10;function removeEntity(oid)&#10;   return executeOnOneActor('BCMN', 'ANER', AtomContainer.new{'AAPC', EOID = {cstr = oid}})&#10;end&#10;&#10;function setServiceState(nid, value)&#10;   return executeOnActors(nid, 'SVST', AtomContainer.new{'AAPC', SVST={fc32=value}})&#10;end&#10;&#10;function setAuditState(nid, value)&#10;   return executeOnActors(nid, 'AUDT', AtomContainer.new{'AAPC', AUDT={fc32=value}})&#10;end&#10;&#10;function removeAuditRepo(nid)&#10;   -- Tell all relays to stop enqueueing messages for the specified repository&#10;   return executeOnActors('BADC', 'RMRP', AtomContainer.new{'AAPC', REPO={ui32=nid}})&#10;end&#10;&#10;function waitAudit(nid, value)&#10;   local function checkDone(nid, status)&#10;      return status:data(&quot;AQSZ&quot;) == UINT64.new(0)&#10;   end&#10;   return waitOnActors(nid, 'AUDQ', AtomContainer.new{'CHPC'}, checkDone)&#10;end&#10;&#10;function waitRelayFlush(nid)&#10;   local function checkDone(nid, status)&#10;      return status:data(&quot;AQSZ&quot;) == UINT64.new(0)&#10;   end&#10;   return waitOnActors('BADC', 'AURC', AtomContainer.new{'CHPC', REPO={ui32=nid}}, checkDone)&#10;end&#10;&#10;function removeNode(nid, device)&#10;   return executeOnOneActor('BCMN', 'UNOD', AtomContainer.new{'AAPC', NOID = {ui32 = nid}, DTYP = {fc32 = device}})&#10;end&#10;&#10;function waitCmnStandby(nid)&#10;   -- Wait for CMN to be configured as standby&#10;   local function checkDone(nid, status)&#10;      return status:data(&quot;CMNS&quot;) == 'OFLN'&#10;   end&#10;   return waitOnActors(nid, 'CMNS', AtomContainer.new{'CHPC'}, checkDone)&#10;end&#10;&#10;function modifyBundle(bundleNumber)&#10;   return executeOnOneActor('BCMN', 'EBUN', AtomContainer.new{'AAPC', EBUN = taskParams:data(&quot;/EBUN/&quot;..bundleNumber)} )&#10;end&#10;&#10;function deleteBundle(bundleNumber)&#10;   return executeOnOneActor('BCMN', 'DBUN', AtomContainer.new{'AAPC', DBUN = taskParams:data(&quot;/DBUN/&quot;..bundleNumber)} )&#10;end&#10;&#10;function nodeId(node)&#10;   return node:data(&quot;/NOID&quot;)&#10;end&#10;&#10;function nodeOid(node)&#10;   return node:data(&quot;/EOID&quot;)&#10;end&#10;&#10;function deviceType(node)&#10;   return node:data(&quot;/DTYP&quot;)&#10;end&#10;&#10;function bundleToString(bundle)&#10;   return bundleName(bundle)..&quot;.&quot;..bundle:data(&quot;/NMSP&quot;)..&quot;-&quot;..bundle:data(&quot;/NSIN&quot;)&#10;end&#10;&#10;function bundleNumber(bundle)&#10;   return bundle:name()&#10;end&#10;&#10;function bundleName(bundle)&#10;   return bundle:data(&quot;/BLNM&quot;)&#10;end&#10;&#10;function gtPrepare()&#10;   pushAbort(&quot;taskFinished()&quot;)&#10;&#10;   --------------------------------------------------------------------------------&#10;   -- Check pre-conditions&#10;   --------------------------------------------------------------------------------&#10;&#10;   --------------------------------------------------------------------------------&#10;   for node in taskParams:datas(&quot;/NODS&quot;) do&#10;      local device = deviceType(node)&#10;      if device == &quot;BCMN&quot; then&#10;         addStage(&quot;stageName(OID_GRIDTASK_STAGE_CMN_STATE_WAIT)&quot;)&#10;         addStage(&quot;waitCmnStandby(&quot;..nodeId(node)..&quot;)&quot;)&#10;      end&#10;   end&#10;&#10;   --------------------------------------------------------------------------------&#10;   -- Acquire an exclusive TOPOLOGY lock on every device type being decommissioned&#10;   local locks = &quot;['GRID-BUNDLE'] = true&quot;&#10;   for node in taskParams:datas(&quot;/NODS&quot;) do&#10;      local device = deviceType(node)&#10;      if nodeId(node) then&#10;         locks = locks..&quot;, ['&quot;..device..&quot;-TOPOLOGY'] = true&quot;&#10;      end&#10;   end&#10;&#10;   addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;   pushAbort(&quot;getLocks({})&quot;)&#10;   addStage(&quot;getLocks({&quot;..locks..&quot;})&quot;)&#10;   popAbort() -- RLOK&#10;   popAbort() -- Cannot abort past this point&#10;&#10;   --------------------------------------------------------------------------------&#10;   -- If an AMS is decommissioned, all relay queues for it must be flushed before&#10;   -- its services are disabled.&#10;   --------------------------------------------------------------------------------&#10;   for node in taskParams:datas(&quot;/NODS&quot;) do&#10;      if deviceType(node) == 'BAMS' then&#10;         -- NOTE - RMRP action will fail if there is not at least 1 remaining repository, but&#10;         -- if this happens here then topology locks will prevent the addition of another AMS.&#10;&#10;         addStage(&quot;stageName(OID_GRIDTASK_STAGE_AUDIT_RELAY_FLUSH)&quot;)&#10;         addStage(&quot;removeAuditRepo(&quot;..nodeId(node)..&quot;)&quot;)&#10;         addStage(&quot;waitRelayFlush(&quot;..nodeId(node)..&quot;)&quot;)&#10;      end&#10;   end&#10;&#10;   --------------------------------------------------------------------------------&#10;   -- Execute common decommissioning actions&#10;   --------------------------------------------------------------------------------&#10;&#10;   --------------------------------------------------------------------------------&#10;   addStage(&quot;stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)&quot;)&#10;   for node in taskParams:datas(&quot;/NODS&quot;) do&#10;      nid = nodeId(node)&#10;      if nid then&#10;         addStage(&quot;setServiceState(&quot;..nid..&quot;, 'DABL')&quot;)&#10;      end&#10;   end&#10;&#10;   --------------------------------------------------------------------------------&#10;   addStage(&quot;stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)&quot;)&#10;   for node in taskParams:datas(&quot;/NODS&quot;) do&#10;      -- TODO Support this action on the CMS&#10;      if deviceType(node) ~= 'BCMS' then&#10;         nid = nodeId(node)&#10;         if nid then&#10;            addStage(&quot;setAuditState(&quot;..nid..&quot;, 'DABL')&quot;)&#10;            addStage(&quot;waitAudit(&quot;..nodeId(node)..&quot;)&quot;)&#10;         end&#10;      end&#10;   end&#10;&#10;   --------------------------------------------------------------------------------&#10;   addStage(&quot;stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)&quot;)&#10;   for node in taskParams:datas(&quot;/NODS&quot;) do&#10;      nid = nodeId(node)&#10;      if nid then&#10;         addStage(&quot;revokeCert(&quot;..nid..&quot;)&quot;)&#10;      end&#10;   end&#10;&#10;   --------------------------------------------------------------------------------&#10;   addStage(&quot;stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)&quot;)&#10;   for node in taskParams:datas(&quot;/NODS&quot;) do&#10;      local oid = nodeOid(node)&#10;      if oid then  -- Is this ever not set?&#10;         addStage(&quot;removeEntity('&quot;..oid..&quot;')&quot;)&#10;      end&#10;   end&#10;&#10;   --------------------------------------------------------------------------------&#10;   addStage(&quot;stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)&quot;)&#10;   for node in taskParams:datas(&quot;/NODS&quot;) do&#10;      nid = nodeId(node)&#10;      if nid then&#10;         addStage(&quot;removeNode(&quot;..nid..&quot;, '&quot;..deviceType(node)..&quot;')&quot;)&#10;      end&#10;   end&#10;&#10;   --------------------------------------------------------------------------------&#10;   -- Execute node-specific post-decommissioning actions&#10;   --------------------------------------------------------------------------------&#10;   for bundle in taskParams:datas(&quot;/EBUN&quot;) do&#10;      addStage(&quot;stageName(OID_GRIDTASK_STAGE_BUNDLE_DELETEROWS..'(&quot;..bundleName(bundle)..&quot;)')&quot;)&#10;      addStage(&quot;modifyBundle('&quot;..bundleNumber(bundle)..&quot;')&quot;)&#10;   end&#10;&#10;   for bundle in taskParams:datas(&quot;/DBUN&quot;) do&#10;      addStage(&quot;stageName(OID_GRIDTASK_STAGE_BUNDLE_DELETE..'(&quot;..bundleToString(bundle)..&quot;)')&quot;)&#10;      addStage(&quot;deleteBundle('&quot;..bundleNumber(bundle)..&quot;')&quot;)&#10;   end&#10;&#10;   --------------------------------------------------------------------------------&#10;   addStage(&quot;getLocks({})&quot;)&#10;   addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;   addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;end&#10;"/>
			</container>
			<container name="GEXP">
				<atom name="0001" type="CSTR" value="-- Grid Expansion Task&#10;-- Version 1&#10;&#10;function addGroup(gid, siteName)&#10;    return executeOnOneActor('BCMN', 'RGRP',&#10;        AtomContainer.new{'AAPC', GPID = {ui32 = gid}, GNAM = {cstr = siteName}})&#10;end&#10;&#10;function addEntity(path)&#10;    local eoid = taskParams:data(path..&quot;/EOID&quot;)&#10;    local eodm = taskParams:data(path..&quot;/EODM&quot;)&#10;    local eodv = taskParams:data(path..&quot;/EODV&quot;)&#10;    local eona = taskParams:data(path..&quot;/EONA&quot;)&#10;    local elng = taskParams:data(path..&quot;/ELNG&quot;)&#10;    local eosi = taskParams:data(path..&quot;/EOSI&quot;)&#10;    local eohn = taskParams:data(path..&quot;/EOHN&quot;)&#10;&#10;    return executeOnOneActor('BCMN', 'ANEA',&#10;        AtomContainer.new{'AAPC', EOID = {cstr = eoid}, EODM = {cstr = eodm}, EODV = {cstr = eodv}, EONA = {ustr = eona}, ELNG = {enum = elng}, EOSI = {cstr = eosi}, EOHN = {cstr = eohn}})&#10;end&#10;&#10;function addCert(nid, certpath)&#10;    local cert = taskParams:data(certpath)&#10;&#10;    return executeOnOneActor('BADC', 'CUPD',&#10;        AtomContainer.new{'AAPC', NOID = {ui32 = nid}, CERT = {data = cert}})&#10;end&#10;&#10;function addGrade(nid)&#10;    return executeOnOneActor('BCMN', 'RSTG',&#10;        AtomContainer.new{'AAPC', NOID = {ui32 = nid}})&#10;end&#10;&#10;function addNmsCluster(ncid, path)&#10;    local name = taskParams:data(path..&quot;/NMCN&quot;)&#10;    return executeOnOneActor('BCMN', 'RNMS',&#10;        AtomContainer.new{'AAPC', NMCI = {ui32 = ncid}, NMCN = {ustr = name}})&#10;end&#10;&#10;function addBundles(path)&#10;    local result = 1&#10;    local reason = OID_GRIDTASK_MSG_NONE&#10;&#10;    for data in taskParams:datas(path) do&#10;        data:set_name('AAPC')&#10;        result,reason = executeOnOneActor('BCMN', 'BDLI', data)&#10;        if(result ~= 1) then&#10;            Debug.log(&quot;warn&quot;,&quot;Exiting bundle-import loop, reason =&quot;,reason)&#10;            break&#10;        end&#10;    end&#10;&#10;    return result,reason&#10;end&#10;&#10;function modifyBundle(bundleNumber)&#10;&#10;    return executeOnOneActor('BCMN', 'EBUN',AtomContainer.new{'AAPC',&#10;    EBUN = taskParams:data(&quot;/EBUN/&quot;..bundleNumber)} )&#10;end&#10;&#10;function gtPrepare()&#10;    --FIXME: is some kind of pre-check necessary?&#10;&#10;    pushAbort(&quot;taskFinished()&quot;)&#10;&#10;    --------------------------------------------------------------------------------&#10;    -- Acquire an exclusive TOPOLOGY lock on every device type being added&#10;    local locks = &quot;['GRID-BUNDLE'] = true&quot;&#10;    for node in taskParams:datas(&quot;/NODS&quot;) do&#10;        local nid = node:data(&quot;/NOID&quot;)&#10;        local cert = node:data(&quot;/CERT&quot;)&#10;        local device = node:data(&quot;/EODM&quot;)&#10;&#10;        if nid and cert and device then&#10;            locks = locks..&quot;, ['&quot;..device..&quot;-TOPOLOGY'] = true&quot;&#10;        end&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;    pushAbort(&quot;getLocks({})&quot;)&#10;    addStage(&quot;getLocks({&quot;..locks..&quot;})&quot;)&#10;&#10;    --------------------------------------------------------------------------------&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_GROUP_ADD)&quot;)&#10;&#10;&#10;&#10;    local numNewGroups = 0&#10;    newGroups = {}&#10;    for group in taskParams:datas(&quot;/GRPS&quot;) do&#10;        numNewGroups = numNewGroups + 1&#10;        newGroups[numNewGroups] = group&#10;    end&#10;&#10;    local numNewEoids = 0&#10;    entityIds = {}&#10;    for eoid in taskParams:datas(&quot;/GEID&quot;) do&#10;        numNewEoids = numNewEoids + 1&#10;        entityIds[numNewEoids] = eoid&#10;    end&#10;&#10;    for index=1,numNewGroups do&#10;        local group = newGroups[index]&#10;        local entityId = entityIds[index]&#10;&#10;        local siteName = &quot;&quot;&#10;        for node in taskParams:datas(&quot;/NODS&quot;) do&#10;            if entityId == node:data(&quot;/EOID&quot;) then&#10;                siteName = node:data(&quot;/EONA&quot;)&#10;                break&#10;            end&#10;        end&#10;&#10;        addStage(&quot;addGroup(&quot;..group..&quot;,'&quot;..siteName..&quot;')&quot;)&#10;    end&#10;&#10;    --------------------------------------------------------------------------------&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_ENTITY_ADD)&quot;)&#10;&#10;    for node in taskParams:datas(&quot;/NODS&quot;) do&#10;        addStage(&quot;addEntity('/NODS/&quot;..node:name()..&quot;')&quot;)&#10;    end&#10;&#10;    --------------------------------------------------------------------------------&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_CERT_UPDATE)&quot;)&#10;    -- FIXME? - Could interleave the certs with the NENT updates.&#10;&#10;    for node in taskParams:datas(&quot;/NODS&quot;) do&#10;        local nid = node:data(&quot;/NOID&quot;)&#10;        local cert = node:data(&quot;/CERT&quot;)&#10;&#10;        if nid and cert then&#10;            addStage(&quot;addCert(&quot;..nid..&quot;,'/NODS/&quot;..node:name()..&quot;/CERT')&quot;)&#10;        end&#10;    end&#10;&#10;    --------------------------------------------------------------------------------&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_GRADE_ADD)&quot;)&#10;&#10;    for node in taskParams:datas(&quot;/NODS&quot;) do&#10;        -- FIXME Pass an explicit &quot;device type&quot; field (or look in cert)?&#10;        local nid = node:data(&quot;/NOID&quot;)&#10;        local device = node:data(&quot;/EODM&quot;)&#10;        if nid and device == &quot;BLDR&quot; then&#10;            addStage(&quot;addGrade(&quot;..nid..&quot;)&quot;)&#10;        end&#10;    end&#10;&#10;    --------------------------------------------------------------------------------&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_NMS_CLUSTER_ADD)&quot;)&#10;&#10;    for node in taskParams:datas(&quot;/NODS&quot;) do&#10;        local nid = node:data(&quot;/NOID&quot;)&#10;        local device = node:data(&quot;/EODM&quot;)&#10;        local ncid = node:data(&quot;/NMCI&quot;)&#10;&#10;        if nid and device == &quot;BNMS&quot; and ncid then&#10;            addStage(&quot;addNmsCluster(&quot;..ncid..&quot;,'/NODS/&quot;..node:name()..&quot;')&quot;)&#10;        end&#10;    end&#10;&#10;    --------------------------------------------------------------------------------&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_BUNDLE_IMPORT)&quot;)&#10;    addStage(&quot;addBundles('/BDLS')&quot;)&#10;&#10;    --------------------------------------------------------------------------------&#10;    for bundle in taskParams:datas(&quot;/EBUN&quot;) do&#10;        local bundleNumber = bundle:name()&#10;        local bundleName = bundle:data(&quot;/BLNM&quot;)&#10;&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_BUNDLE_ADDROWS..'(&quot;..bundleName..&quot;)')&quot;)&#10;        addStage(&quot;modifyBundle('&quot;..bundleNumber..&quot;')&quot;)&#10;    end&#10;&#10;    --------------------------------------------------------------------------------&#10;    addStage(&quot;getLocks({})&quot;)&#10;    popAbort() -- RLOK&#10;&#10;    --------------------------------------------------------------------------------&#10;    popAbort()&#10;&#10;    addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;    addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;end&#10;"/>
			</container>
			<container name="ILME">
				<atom name="0001" type="CSTR" value="-- ILM Evaluation Task&#10;-- Version 1&#10;&#10;&#10;function abortILME()&#10;    -- Helper function to clean up a verification task&#10;    local res,reas&#10;&#10;    Debug.log(&quot;warn&quot;,&quot;Stopping DDS actions&quot;)&#10;    for _,nid in pairs(cmnList) do&#10;&#10;        res,reas = stopAction(nid,'ILME',gtActPc)&#10;        if(res ~= 1) then&#10;            return 0,reas&#10;        end&#10;    end&#10;&#10;    if (res ~= 1) then&#10;        return 0,reas&#10;    else&#10;        return 1,&quot;OK&quot;&#10;    end&#10;end&#10;&#10;function gtPrepare()&#10;    -- Called once, the first time that the task is run.&#10;    pushAbort(&quot;taskFinished()&quot;)&#10;&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;    pushAbort(&quot;getLocks({})&quot;)&#10;    addStage(&quot;getLocks({['GRID-ILM'] = true})&quot;)&#10;&#10;    pushAbort(&quot;abortILME()&quot;)&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_STARTING)&quot;)&#10;&#10;    for _,targetCMN in pairs(cmnList) do&#10;        addStage(&quot;startAction(&quot;..targetCMN..&quot;,'ILME',gtActPc)&quot;)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_ILM_EVALUATE)&quot;)&#10;    addStage(&quot;waitDone(cmnList, 'ILME', gtActPc)&quot;)&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_FINISHING)&quot;)&#10;    for _,targetCMN in pairs(cmnList) do&#10;        addStage(&quot;stopAction(&quot;..targetCMN..&quot;,'ILME',gtActPc)&quot;)&#10;    end&#10;&#10;    addStage(&quot;getLocks({})&quot;)&#10;    popAbort() -- RLOK&#10;&#10;    popAbort() -- abortILME()&#10;&#10;    popAbort()&#10;&#10;    addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;    addStage(&quot;taskFinished()&quot;)&#10;&#10;    -- FIXME - Save bundle to GTEN.&#10;end&#10;&#10;function gtInit()&#10;    -- Called every time that the task is run (first time, as well as after any CMN restart).&#10;&#10;    gtActPc = AtomContainer.new{'AAPC'}&#10;    gtActPc:set(&quot;/&quot;, taskParams)&#10;    cmnList = actorsToList('BCMN', true)&#10;end&#10;"/>
			</container>
			<container name="LCCN">
				<atom name="0001" type="CSTR" value="-- Legacy CBID Continuation Task&#10;-- Version 1&#10;&#10;function waitLegacyCBID()&#10;&#9;local function checkDone(nid, status)&#10;&#9;&#9;return status:data(&quot;LCSC&quot;) == 'NFND',&#10;&#9;&#9;&#9;status:data(&quot;PCPN&quot;),&#10;&#9;&#9;&#9;status:data(&quot;PCPD&quot;)&#10;&#9;end&#10;&#9;&#10;&#9;return waitOnActors('BCMS', 'LCSC', AtomContainer.new{'CHPC'}, checkDone)&#10;end&#10;&#10;function gtPrepare()&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LEGACY_CBID)&quot;)&#10;&#9;addStage(&quot;waitLegacyCBID()&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;&#9;addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;end&#10;"/>
			</container>
			<container name="LDCM">
				<atom name="0001" type="CSTR" value="-- StorageNODE Decommissioning Task&#10;&#10;function actionSMNT(ldr,value)&#10;    return executeOnActors(ldr, 'SMNT', AtomContainer.new{'AAPC', SMNT={fc32=value}})&#10;end&#10;&#10;function actionSTDS(ldr,value)&#10;    return executeOnActors(ldr, 'STDS', AtomContainer.new{'AAPC', STDS={fc32=value}})&#10;end&#10;&#10;function revokeCert(nid)&#10;--  return executeOnOneActor('BADC', 'ADBP', AtomContainer.new{'AAPC', DLVL = 'NOTE', DSTR = &quot;Revoking cert for &quot;..nid})&#10;    return executeOnOneActor('BADC', 'CRVK', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})&#10;end&#10;&#10;function removeEntity(nid)&#10;    return executeOnOneActor('BCMN', 'ANER', AtomContainer.new{'AAPC', EOID = {cstr = nid}})&#10;end&#10;&#10;function setServiceState(nid, value)&#10;    return executeOnActors(nid, 'SVST', AtomContainer.new{'AAPC', SVST={fc32=value}})&#10;end&#10;&#10;function setAuditState(nid, value)&#10;    return executeOnActors(nid, 'AUDT', AtomContainer.new{'AAPC', AUDT={fc32=value}})&#10;end&#10;&#10;function waitAudit(nid, value)&#10;    local function checkDone(nid, status)&#10;        return status:data(&quot;AQSZ&quot;) == UINT64.new(0)&#10;    end&#10;    return waitOnActors(nid, 'AUDQ', AtomContainer.new{'CHPC'}, checkDone)&#10;end&#10;&#10;function removeGrade(nid)&#10;    return executeOnOneActor('BCMN', 'USTG', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})&#10;end&#10;&#10;function removeNode(nid, device)&#10;    return executeOnOneActor('BCMN', 'UNOD', AtomContainer.new{'AAPC', NOID = {ui32 = nid}, DTYP = {fc32 = device}})&#10;end&#10;&#10;function markingLdrDecommissioning(nid)&#10;    return executeOnOneActor('BDDS', 'LMDC', AtomContainer.new{'AAPC', NODE={ui32=nid}})&#10;end&#10;&#10;function filterDdsList(nid)&#10;    for i=#ddsListReMap,1,-1 do&#10;        if (nid == ddsListReMap[i]) then&#10;            table.remove(ddsListReMap, i)&#10;        end&#10;    end&#10;end&#10;&#10;function filterCmsList(nid)&#10;    for i=#cmsList,1,-1 do&#10;        if (nid == cmsList[i]) then&#10;            table.remove(cmsList, i)&#10;        end&#10;    end&#10;end&#10;&#10;function setOwnerMapping(onid, nnid)&#10;    return executeOnOneActor('BDDS', 'COWR', AtomContainer.new{'AAPC', NIDS={ui32=onid},  NIDD={ui32=nnid}})&#10;end&#10;&#10;function gtPrepare()&#10;    -- Called once, the first time that the task is run.&#10;&#10;    pushAbort(&quot;taskFinished()&quot;)&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;    pushAbort(&quot;getLocks({})&quot;)&#10;&#10;    for oldLdr in taskParams:datas('/SLDR') do&#10;        addStage(&quot;getLocks({['&quot;..oldLdr..&quot;-STORAGE'] = true})&quot;)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_STARTING)&quot;)&#10;&#10;    for oldLdr in taskParams:datas('/SLDR') do&#10;        pushAbort(&quot;actionSMNT(&quot;..oldLdr..&quot;,'DABL')&quot;)&#10;        addStage(&quot;actionSMNT(&quot;..oldLdr..&quot;,'ENBL')&quot;)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_STARTING)&quot;)&#10;&#10;    -- Using this way of creating a list of nodeTypes mapped to nodeIds and using ipairs() because unit tests expect ordering which&#10;    -- pairs() doesn't guarantee.&#10;    local sourceNodes = {}&#10;&#10;    for oldLdr in taskParams:datas('/SLDR') do&#10;        popAbort()  -- actionSMNT&#10;    end&#10;    popAbort() -- RLOK&#10;    popAbort()  -- Empty the stack; cannot abort beyond this point&#10;&#10;    -- from here,can not roll back&#10;    addStage(&quot;getLocks({['GRID-ILM'] = true})&quot;)&#10;&#10;    for oldLdr in taskParams:datas('/SLDR') do&#10;        addStage(&quot;markingLdrDecommissioning(&quot;..oldLdr..&quot;)&quot;)&#10;    end&#10;&#10;    -- EC Decommissioning start.&#10;&#10;    Debug.log(&quot;info&quot;,&quot;Starting EC decommissioning.&quot;)&#10;    -- Start on one CMN?&#10;    for _,targetCMN in pairs(cmnList) do&#10;        addStage(&quot;startAction(&quot;..targetCMN..&quot;, 'ECND', ecdcParams)&quot;)&#10;    end&#10;    Debug.log(&quot;info&quot;,&quot;Started EC decommissioning actions.&quot;)&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_EC_DECOMMISSIONING)&quot;)&#10;    addStage(&quot;waitDone(cmnList, 'ECND', ecdcParams)&quot;)&#10;&#10;    Debug.log(&quot;info&quot;,&quot;EC decommissioning action done.&quot;)&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_FINISHING)&quot;)&#10;    for _,targetCMN in pairs(cmnList) do&#10;        addStage(&quot;stopAction(&quot;..targetCMN..&quot;, 'ECND', ecdcParams)&quot;)&#10;    end&#10;    Debug.log(&quot;info&quot;,&quot;Finished EC decommissioning.&quot;)&#10;&#10;    -- EC Decommissioning end.&#10;&#10;    -- FIXME? This seems wrong; we should only start a single ILM re-evaluation, even if we actually has multiple CMNs&#10;    for _,targetCMN in pairs(cmnList) do&#10;        addStage(&quot;startAction(&quot;..targetCMN..&quot;, 'ILME', ilmeParams)&quot;)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_ILM_EVALUATE)&quot;)&#10;    addStage(&quot;waitDone(cmnList, 'ILME', ilmeParams)&quot;)&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_FINISHING)&quot;)&#10;    for _,targetCMN in pairs(cmnList) do&#10;        addStage(&quot;stopAction(&quot;..targetCMN..&quot;, 'ILME', ilmeParams)&quot;)&#10;    end&#10;&#10;    for oldCms in taskParams:datas(&quot;/SCMS&quot;) do&#10;        local cmsSource = {nt = 'BCMS', nid = oldCms}&#10;        table.insert(sourceNodes, cmsSource)&#10;        filterCmsList(oldCms)&#10;    end&#10;&#10;    if(table.getn(cmsList) &gt; 0) then&#10;        for oldCms in taskParams:datas('/SCMS') do&#10;            local newCms = cmsList[ math.random(table.getn(cmsList)) ]&#10;            addStage(&quot;setOwnerMapping(&quot;..oldCms..&quot;, &quot;..newCms..&quot; )&quot;)&#10;        end&#10;    else&#10;        Debug.log(&quot;err&quot;,&quot;NodeId mapping failed. No running CMS&quot;)&#10;    end&#10;&#10;    for oldDds in taskParams:datas('/SDDS') do&#10;        filterDdsList(oldDds)&#10;    end&#10;&#10;    if(table.getn(ddsListReMap) &gt; 0) then&#10;        for oldDds in taskParams:datas('/SDDS') do&#10;            local newDds = ddsListReMap[ math.random(table.getn(ddsListReMap)) ]&#10;            addStage(&quot;setOwnerMapping(&quot;..oldDds..&quot;, &quot;..newDds..&quot; )&quot;)&#10;        end&#10;    else&#10;        Debug.log(&quot;err&quot;,&quot;NodeId mapping failed. No running DDS&quot;)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)&quot;)&#10;    for oldLdr in taskParams:datas('/SLDR') do&#10;        addStage(&quot;actionSTDS(&quot;..oldLdr..&quot;,'OFLN')&quot;)&#10;        local ldrSource = {nt = 'BLDR', nid = oldLdr}&#10;        table.insert(sourceNodes, ldrSource)&#10;    end&#10;&#10;    for oldSsm in taskParams:datas('/SSSM') do&#10;        local ssmSource = {nt = 'BSSM', nid = oldSsm}&#10;        table.insert(sourceNodes, ssmSource)&#10;    end&#10;&#10;    for oldAdc in taskParams:datas('/SADC') do&#10;        local adcSource = {nt = 'BADC', nid = oldAdc}&#10;        table.insert(sourceNodes, adcSource)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_CASSANDRA_NODETOOL_DECOMMISSION)&quot;)&#10;    for oldDds in taskParams:datas('/SDDS') do&#10;        local ddsSource = {nt = 'BDDS', nid = oldDds}&#10;        table.insert(sourceNodes, ddsSource)&#10;        addStage(&quot;stopAction(&quot;..oldDds..&quot;, 'CCLE', AtomContainer.new{'AAPC'})&quot;)&#10;        addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;        addStage(&quot;getLocks({['&quot;..oldDds..&quot;-NODETOOL'] = true, ['NODETOOL_DECOMMISSION'] = true})&quot;)&#10;        addStage(&quot;startAction(&quot;..oldDds..&quot;, 'NDEC', AtomContainer.new{'AAPC', NOID = {ui32 = &quot;..oldDds..&quot;}})&quot;)&#10;        addStage(&quot;waitDone(&quot;..oldDds..&quot;, 'NDEC', gtActPc)&quot;)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_FINISHING)&quot;)&#10;    for oldDds in taskParams:datas('/SDDS') do&#10;        addStage(&quot;stopAction(&quot;..oldDds..&quot;, 'NDEC', AtomContainer.new{'AAPC', NOID = {ui32 = &quot;..oldDds..&quot;}})&quot;)&#10;    end&#10;&#10;    local locks = &quot;['GRID-BUNDLE'] = true&quot;&#10;    for _, data in ipairs(sourceNodes) do&#10;        locks = locks..&quot;, ['&quot;..data['nt']..&quot;-TOPOLOGY'] = true&quot;&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;    addStage(&quot;getLocks({&quot;..locks..&quot;})&quot;)&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)&quot;)&#10;    for _, data in ipairs(sourceNodes) do&#10;        addStage(&quot;setServiceState(&quot;..data['nid']..&quot;, 'DABL')&quot;)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)&quot;)&#10;    for _, data in ipairs(sourceNodes) do&#10;        -- TODO: CMS doesn't support these actions/checks yet.&#10;        --       Uncomment when story B-25861 is implemented.&#10;        if (data['nt'] ~= 'BCMS') then&#10;            addStage(&quot;setAuditState(&quot;..data['nid']..&quot;, 'DABL')&quot;)&#10;            addStage(&quot;waitAudit(&quot;..data['nid']..&quot;)&quot;)&#10;        end&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)&quot;)&#10;    for _, data in ipairs(sourceNodes) do&#10;        addStage(&quot;revokeCert(&quot;..data['nid']..&quot;)&quot;)&#10;    end&#10;&#10;    for eoid in taskParams:datas('/EOID') do&#10;        addStage(&quot;removeEntity('&quot;..eoid..&quot;')&quot;)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)&quot;)&#10;    for _, data in ipairs(sourceNodes) do&#10;        addStage(&quot;removeNode(&quot;..data['nid']..&quot;, '&quot;..data['nt']..&quot;')&quot;)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_GRADE_REMOVE)&quot;)&#10;    for oldLdr in taskParams:datas('/SLDR') do&#10;        addStage(&quot;removeGrade(&quot;..oldLdr..&quot;)&quot;)&#10;    end&#10;&#10;    addStage(&quot;getLocks({})&quot;)&#10;&#10;    addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;    addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;    -- Called every time that the task is run (first time, as well as after any CMN restart).&#10;&#10;    cmnList = actorsToList('BCMN')&#10;    cmsList = actorsToList('BCMS', true)&#10;    ddsList = actorsToList('BDDS', true)&#10;    ddsListReMap = ddsList&#10;&#10;    gtActPc = AtomContainer.new{'AAPC'}&#10;&#10;    -- Add ILM re-evaluation filters for all the LDRs being decommissioned&#10;    ilmeParams = AtomContainer.new{'AAPC'}&#10;    local index = 1&#10;    for oldLdr in taskParams:datas('/SLDR') do&#10;        local filt = AtomContainer.new{'FILT', NOID={ui32=oldLdr}}&#10;        ilmeParams:set_cont(index, filt)&#10;        index = index + 1&#10;    end&#10;&#10;    -- Setup EC decommissioning parameters.&#10;    --  Pass the taskId as part of the parameters.&#10;    ecdcParams = AtomContainer.new{'AAPC', TKID={ui32=taskId}}&#10;    local nodes = AtomContainer.new{'NODE'}&#10;    local i = 1&#10;    for oldLdr in taskParams:datas('/SLDR') do&#10;        local path = string.format(&quot;%04X&quot;, i)&#10;        nodes:set_ui32(path, oldLdr)&#10;        i = i + 1&#10;    end&#10;    ecdcParams:set_cont('NODE', nodes)&#10;end&#10;"/>
			</container>
			<container name="LMIG">
				<atom name="0001" type="CSTR" value="-- LDR Directed Decomissioning (Hardware Refresh) Task&#10;-- Version 1&#10;&#10;function actionSMNT(ldr,value)&#10;&#9;return executeOnActors(ldr, 'SMNT', AtomContainer.new{'AAPC', SMNT={fc32=value}})&#10;end&#10;&#10;function actionCLDQ(ldr,value)&#10;&#9;return executeOnActors(ldr, 'CLDQ', AtomContainer.new{'AAPC', FRWD={fc32=value}})&#10;end&#10;&#10;function disableCLOCLOSTForwarding(ldr)&#10;&#9;return actionCLDQ(ldr, 'DABL')&#10;end&#10;&#10;function enableCLOCLOSTForwarding(ldr)&#10;&#9;return actionCLDQ(ldr, 'ENBL')&#10;end&#10;&#10;function actionSTDS(ldr,value)&#10;&#9;return executeOnActors(ldr, 'STDS', AtomContainer.new{'AAPC', STDS={fc32=value}})&#10;end&#10;&#10;function waitSTCR(ldr,value)&#10;&#9;-- See if Storage is in the expected state&#10;&#9;local function checkDone(nid, status)&#10;&#9;&#9;return status:data(&quot;STUS&quot;) == 'NONE' and&#10;&#9;&#9;&#9;status:data(&quot;STCR&quot;) == value&#10;&#9;end&#10;&#9;&#10;&#9;return waitOnActors(ldr, 'STCR', AtomContainer.new{'CHPC'}, checkDone)&#10;end&#10;&#10;function cmsRemap(from, to)&#10;&#9;local actPc = AtomContainer.new{'AAPC', SNID = {ui32 = gtSourceLdr} ,DNID = {ui32 = gtDestLdr} }&#10;&#10;&#9;return executeOnActors(gtCmsList, 'LRMP', actPc)&#10;end&#10;&#10;function revokeCert(nid)&#10;--&#9;return executeOnOneActor('BADC', 'ADBP', AtomContainer.new{'AAPC', DLVL = 'NOTE', DSTR = &quot;Revoking cert for &quot;..nid})&#10;&#9;return executeOnOneActor('BADC', 'CRVK', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})&#10;end&#10;&#10;function removeEntity(oid)&#10;&#9;return executeOnOneActor('BCMN', 'ANER', AtomContainer.new{'AAPC', EOID = {cstr = oid}})&#10;end&#10;&#10;function setServiceState(nid, value)&#10;&#9;return executeOnActors(nid, 'SVST', AtomContainer.new{'AAPC', SVST={fc32=value}})&#10;end&#10;&#10;function setAuditState(nid, value)&#10;&#9;return executeOnActors(nid, 'AUDT', AtomContainer.new{'AAPC', AUDT={fc32=value}})&#10;end&#10;&#10;function waitAudit(nid, value)&#10;&#9;local function checkDone(nid, status)&#10;&#9;&#9;return status:data(&quot;AQSZ&quot;) == UINT64.new(0)&#10;&#9;end&#10;&#9;return waitOnActors(nid, 'AUDQ', AtomContainer.new{'CHPC'}, checkDone)&#10;end&#10;&#10;function removeGrade(nid)&#10;&#9;return executeOnOneActor('BCMN', 'USTG', AtomContainer.new{'AAPC', NOID = {ui32 = nid}})&#10;end&#10;&#10;function removeNode(nid, device)&#10;&#9;return executeOnOneActor('BCMN', 'UNOD', AtomContainer.new{'AAPC', NOID = {ui32 = nid}, DTYP = {fc32 = device}})&#10;end&#10;&#10;function gtPrepare()&#10;&#9;-- Called once, the first time that the task is run. &#10;&#10;&#9;pushAbort(&quot;taskFinished()&quot;)&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;pushAbort(&quot;getLocks({})&quot;)&#10;&#9;addStage(&quot;getLocks({['&quot;..gtSourceLdr..&quot;-STORAGE'] = true, ['&quot;..gtDestLdr..&quot;-STORAGE'] = true, ['BCMS-TOPOLOGY'] = false})&quot;)&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)&quot;)&#10;&#9;addStage(&quot;waitSTCR(&quot;..gtDestLdr..&quot;,'READ')&quot;)&#10;&#10;        pushAbort(&quot;enableCLOCLOSTForwarding(&quot;..gtDestLdr..&quot;)&quot;)&#10;        addStage(&quot;disableCLOCLOSTForwarding(&quot;..gtDestLdr..&quot;)&quot;)&#10;&#10;&#9;pushAbort(&quot;actionSMNT(&quot;..gtSourceLdr..&quot;,'DABL')&quot;)&#10;&#9;addStage(&quot;actionSMNT(&quot;..gtSourceLdr..&quot;,'ENBL')&quot;)&#10;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_CONTENT_MIGRATE)&quot;)&#10;&#9;pushAbort(&quot;stopAction(&quot;..gtSourceLdr..&quot;,'LMIG',gtActPc)&quot;)&#10;&#9;addStage(&quot;startAction(&quot;..gtSourceLdr..&quot;,'LMIG',gtActPc)&quot;)&#10;&#9;addStage(&quot;waitDone(&quot;..gtSourceLdr..&quot;, 'LMIG', gtActPc)&quot;)&#10;&#9;addStage(&quot;stopAction(&quot;..gtSourceLdr..&quot;,'LMIG',gtActPc)&quot;)&#10;&#10;&#9;popAbort()&#9;-- stopAction&#10;&#9;popAbort()&#9;-- actionSMNT&#10;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_CONTENT_REMAP)&quot;)&#10;&#9;addStage(&quot;cmsRemap(&quot;..gtSourceLdr..&quot;,&quot;..gtDestLdr..&quot;)&quot;)&#10;&#10;        popAbort()      -- enableCLOCLOSTForwarding&#10;        addStage(&quot;enableCLOCLOSTForwarding(&quot;..gtDestLdr..&quot;)&quot;)&#10;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)&quot;)&#10;&#9;addStage(&quot;actionSTDS(&quot;..gtDestLdr..&quot;,'RDWR')&quot;)&#10;&#9;addStage(&quot;actionSTDS(&quot;..gtSourceLdr..&quot;,'OFLN')&quot;)&#10;&#9;&#10;&#9;local sourceNodes = {BLDR = gtSourceLdr, BSSM = gtSourceSsm}&#10;&#9;local locks = &quot;['GRID-BUNDLE'] = true, ['&quot;..gtSourceLdr..&quot;-STORAGE'] = true&quot;&#10;&#9;for nodeType, nid in pairs(sourceNodes) do&#10;&#9;&#9;locks = locks..&quot;, ['&quot;..nodeType..&quot;-TOPOLOGY'] = true&quot;&#10;&#9;end&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;addStage(&quot;getLocks({&quot;..locks..&quot;})&quot;)&#10;&#9;popAbort() -- RLOK&#10;&#9;&#10;&#9;popAbort()&#9;-- Empty the stack; cannot abort beyond this point&#10;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)&quot;)&#10;&#9;for nodeType, nid in pairs(sourceNodes) do&#10;&#9;&#9;addStage(&quot;setServiceState(&quot;..nid..&quot;, 'DABL')&quot;)&#10;&#9;end&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)&quot;)&#10;&#9;for nodeType, nid in pairs(sourceNodes) do&#10;&#9;&#9;addStage(&quot;setAuditState(&quot;..nid..&quot;, 'DABL')&quot;)&#10;&#9;&#9;addStage(&quot;waitAudit(&quot;..nid..&quot;)&quot;)&#10;&#9;end&#10;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)&quot;)&#10;&#9;for nodeType, nid in pairs(sourceNodes) do&#10;&#9;&#9;addStage(&quot;revokeCert(&quot;..nid..&quot;)&quot;)&#10;&#9;end&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)&quot;)&#10;&#9;addStage(&quot;removeEntity('&quot;..gtSourceLdrOid..&quot;')&quot;)&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)&quot;)&#10;&#9;for nodeType, nid in pairs(sourceNodes) do&#10;&#9;&#9;addStage(&quot;removeNode(&quot;..nid..&quot;, '&quot;..nodeType..&quot;')&quot;)&#10;&#9;end&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_GRADE_REMOVE)&quot;)&#10;&#9;addStage(&quot;removeGrade(&quot;..gtSourceLdr..&quot;)&quot;)&#10;&#9;&#10;&#9;addStage(&quot;getLocks({})&quot;)&#10;&#9;&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;    addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;&#9;-- Called every time that the task is run (first time, as well as after any CMN restart). &#10;&#10;&#9;gtSourceLdr = taskParams:data('/SNID')&#10;&#9;gtDestLdr = taskParams:data('/DNID')&#10;&#9;gtSourceSsm = taskParams:data('/SSMN')&#10;&#9;&#10;&#9;gtSourceLdrOid = taskParams:data('/EOID')&#10;&#10;&#9;gtCmsList = cacheLoadList('CMSL')&#10;&#9;&#10;&#9;if(gtCmsList == nil) then&#10;&#9;&#9;gtCmsList  = coFindActors('BCMS')&#10;&#9;&#9;cacheStoreList('CMSL',gtCmsList)&#10;&#9;end&#10;&#9;&#10;&#9;gtActPc = AtomContainer.new{'AAPC', DNID = {ui32 = gtDestLdr} }&#10;end&#10;"/>
			</container>
			<container name="LOCO">
				<atom name="0001" type="CSTR" value="-- Verify Locations&#10;-- Version 1&#10;&#10;&#10;function abortMVFY()&#10;&#9;local res,reas&#10;&#10;&#9;Debug.log(&quot;warn&quot;,&quot;Stopping CMS actions&quot;)&#10;&#9;for _,nid in pairs(cmsList) do&#10;&#9;&#9;res,reas = stopAction(nid,'MVFY',gtActPc)&#10;&#9;&#9;if(res ~= 1) then&#10;&#9;&#9;&#9;return 0,reas&#10;&#9;&#9;end&#10;&#9;end&#10;&#10;&#9;if (res ~= 1) then&#10;&#9;&#9;return 0,reas&#10;&#9;else&#10;&#9;&#9;return 1,&quot;OK&quot;&#10;&#9;end&#10;end&#10;&#10;function gtPrepare()&#10;&#9;pushAbort(&quot;taskFinished()&quot;)&#10;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;pushAbort(&quot;getLocks({})&quot;)&#10;&#9;addStage(&quot;getLocks({['BCMS-TOPOLOGY'] = false})&quot;)&#10;&#10;&#9;pushAbort(&quot;abortMVFY()&quot;)&#10;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_STARTING)&quot;)&#10;&#9;for _,targetCMS in pairs(cmsList) do&#10;&#9;&#9;addStage(&quot;stopAction(&quot;..targetCMS..&quot;,'MVFY',gtActPc)&quot;)&#10;&#9;end&#10;&#9;&#10;&#9;for _,targetCMS in pairs(cmsList) do&#10;&#9;&#9;addStage(&quot;startAction(&quot;..targetCMS..&quot;,'MVFY',gtActPc)&quot;)&#10;&#9;end&#10;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_VERIFY_LOCATIONS)&quot;)&#10;&#9;addStage(&quot;waitDone(cmsList, 'MVFY', gtActPc)&quot;)&#10;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_FINISHING)&quot;)&#10;&#9;for _,targetCMS in pairs(cmsList) do&#10;&#9;&#9;addStage(&quot;stopAction(&quot;..targetCMS..&quot;,'MVFY',gtActPc)&quot;)&#10;&#9;end&#10;&#10;&#9;addStage(&quot;getLocks({})&quot;)&#10;&#9;popAbort() -- RLOK&#10;&#9;popAbort() -- abortMVFY()&#10;&#9;popAbort()&#10;&#9;&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;&#9;addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;&#9;gtActPc = AtomContainer.new{'AAPC'}&#10;&#9;cmsList = actorsToList('BCMS')&#10;end&#10;"/>
			</container>
			<container name="MVFY">
				<atom name="0001" type="CSTR" value="-- CMS Metadata Background Verification Task&#10;-- Version 1&#10;&#10;&#10;function abortMVFY()&#10;&#9;-- Helper function to clean up a verification task&#10;&#9;local res,reas&#10;&#10;&#9;Debug.log(&quot;warn&quot;,&quot;Stopping CMS actions&quot;)&#10;&#9;res,reas = stopAction(gtTargetCMS,'MVFY',gtActPc)&#10;&#9;if(res ~= 1) then&#10;&#9;&#9;return 0,reas&#10;&#9;else&#10;&#9;&#9;return 1,&quot;OK&quot;&#10;&#9;end&#10;end&#10;&#10;function gtPrepare()&#10;&#9;-- Called once, the first time that the task is run. &#10;&#9;&#10;&#9;local targetCMS = gtTargetCMS&#10;&#10;&#9;pushAbort(&quot;taskFinished()&quot;)&#10;&#9;&#10;&#9;pushAbort(&quot;abortMVFY()&quot;)&#10;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;pushAbort(&quot;getLocks({})&quot;)&#10;&#9;addStage(&quot;getLocks({['&quot;..targetCMS..&quot;-STORAGE'] = true})&quot;)&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_STARTING)&quot;)&#10;&#9;addStage(&quot;stopAction(&quot;..gtTargetCMS..&quot;,'MVFY',gtActPc)&quot;)&#10;&#9;&#10;&#9;addStage(&quot;startAction(&quot;..gtTargetCMS..&quot;,'MVFY',gtActPc)&quot;)&#10;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_VERIFY_LOCATIONS)&quot;)&#10;&#9;addStage(&quot;waitDone(&quot;..gtTargetCMS..&quot;, 'MVFY', gtActPc)&quot;)&#10;&#9;addStage(&quot;stopAction(&quot;..gtTargetCMS..&quot;,'MVFY',gtActPc)&quot;)&#10;&#10;&#9;addStage(&quot;getLocks({})&quot;)&#10;&#9;popAbort() -- RLOK&#10;&#9;&#10;&#9;popAbort() -- abortMVFY()&#10;&#9;&#10;&#9;popAbort()&#10;&#9;&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;&#9;addStage(&quot;taskFinished()&quot;)&#10;&#9;&#10;&#9;-- FIXME - Save bundle to GTEN.&#10;end&#10;&#10;function gtInit()&#10;&#9;-- Called every time that the task is run (first time, as well as after any CMN restart). &#10;&#10;&#9;gtTargetCMS = taskParams:data('/NOID')&#10;&#9;&#10;&#9;startCbid = taskParams:data('/SBID')&#10;&#9;endCbid = taskParams:data('/EBID')&#10;&#9;&#10;&#9;gtActPc = AtomContainer.new{'AAPC', NOID = {ui32 = gtTargetCMS}, SBID = {ui64 = startCbid}, EBID = {ui64 = endCbid}}&#10;&#10;end&#10;"/>
			</container>
			<container name="NREP">
				<atom name="0001" type="CSTR" value="-- Nodetool repair task&#10;-- Version 1&#10;&#10;function abortNREP()&#10;    -- Helper function to clean up a verification task&#10;    local res,reas&#10;&#10;    Debug.log(&quot;warn&quot;,&quot;Stopping DDS(NREP) actions&quot;)&#10;&#10;    res,reas = stopAction(gtTargetDDSNid,'NREP',gtActPc)&#10;&#10;    if (res ~= 1) then&#10;        return 0,reas&#10;    else&#10;        return 1,&quot;OK&quot;&#10;    end&#10;end&#10;&#10;function gtPrepare()&#10;    pushAbort(&quot;taskFinished()&quot;)&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;    pushAbort(&quot;getLocks({})&quot;)&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;    locks = &quot;['&quot;..gtTargetDDSNid..&quot;-NODETOOL'] = true&quot;&#10;    addStage(&quot;getLocks({&quot;..locks..&quot;})&quot;)&#10;&#10;    pushAbort(&quot;abortNREP()&quot;)&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_STARTING)&quot;)&#10;    addStage(&quot;startAction(&quot;..gtTargetDDSNid..&quot;,'NREP',gtActPc)&quot;)&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_RUNNING_CASSANDRA_NODE_REPAIR)&quot;)&#10;    addStage(&quot;waitDone(gtTargetDDSNid, 'NREP', gtActPc)&quot;)&#10;    addStage(&quot;getLocks({})&quot;)&#10;    popAbort() -- RLOK&#10;    popAbort() -- abortNREP()&#10;    popAbort()&#10;    addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;    addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;    gtTargetDDSNid = taskParams:data('/NOID')&#10;    gtActPc = AtomContainer.new{'AAPC'}&#10;end&#10;&#10;"/>
			</container>
			<container name="RNMC">
				<atom name="0001" type="CSTR" value="-- Remove NMS Cluster Bindings&#10;-- Version 1&#10;&#10;function unbindCluster(clusterId)&#10;&#9;return executeOnOneActor('BCMN', 'RNMC', AtomContainer.new{'AAPC', NCID = {ui32 = clusterId}})&#10;end&#10;&#10;function gtPrepare()&#10;&#9;pushAbort(&quot;taskFinished()&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;pushAbort(&quot;getLocks({})&quot;)&#10;&#9;addStage(&quot;getLocks({['GRID-BUNDLE'] = true})&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_BUNDLE_COMMIT)&quot;)&#10;&#9;&#10;&#9;clusterId = taskParams:data('/NCID')&#10;&#9;addStage(&quot;unbindCluster(&quot;..clusterId..&quot;)&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;getLocks({})&quot;)&#10;&#9;popAbort() -- RLOK&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;&#9;addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;end&#10;"/>
			</container>
			<container name="SWUP">
				<atom name="0001" type="CSTR" value="-- Software Upgrade Task&#10;-- Version 1&#10;&#10;function addBundles(path)&#10;&#9;local result = 1&#10;&#9;local reason = OID_GRIDTASK_MSG_NONE&#10;&#9;&#10;&#9;for data in taskParams:datas(path) do&#10;&#9;&#9;data:set_name('AAPC')&#10;&#9;&#9;result,reason = executeOnOneActor('BCMN', 'BDLI', data)&#10;&#9;&#9;if(result ~= 1) then&#10;&#9;&#9;&#9;Debug.log(&quot;warn&quot;,&quot;Exiting bundle-import loop, reason =&quot;,reason)&#10;&#9;&#9;&#9;break&#10;&#9;&#9;end&#10;&#9;end&#10;&#10;&#9;return result,reason&#10;end&#10;&#10;function commitBundles(path)&#10;&#9;local result = 1&#10;&#9;local reason = OID_GRIDTASK_MSG_NONE&#10;&#9;&#10;&#9;for data in taskParams:datas(path) do&#10;&#9;&#9;data:set_name('AAPC')&#10;&#9;&#9;result,reason = executeOnOneActor('BCMN', 'BCMT', data)&#10;&#9;&#9;if(result ~= 1) then&#10;&#9;&#9;&#9;Debug.log(&quot;warn&quot;,&quot;Exiting bundle-commit loop, reason =&quot;,reason)&#10;&#9;&#9;&#9;break&#10;&#9;&#9;end&#10;&#9;end&#10;&#10;&#9;return result,reason&#10;end&#10;&#10;function preloadResources(nodeType, version, update)&#10;&#9;return executeOnActors(nodeType, 'ARPL',&#10;&#9;&#9;AtomContainer.new{'AAPC', NVER = {ui32 = version}, UPDT = taskParams:data(update)})&#10;end&#10;&#10;function unloadResources(nodeType)&#10;&#9;return executeOnActors(nodeType, 'ARUL', AtomContainer.new{'AAPC'})&#10;end&#10;&#10;function waitUnloadResources(nodeType)&#10;&#9;local function checkDone(nid, status)&#10;&#9;&#9;return status:data(&quot;STAT&quot;) == &quot;NFND&quot;&#10;&#9;end&#10;&#9;&#10;&#9;return waitOnActors(nodeType, 'CRUL', AtomContainer.new{'CHPC'}, checkDone)&#10;end&#10;&#10;function waitVersion(path, adeVersion, cmsVersion)&#10;&#9;local function checkDone(nid, status, node)&#10;&#9;&#9;local version = adeVersion&#10;&#9;&#9;if node:data(&quot;DTYP&quot;) == 'BCMS' then&#10;&#9;&#9;&#9;version = cmsVersion&#10;&#9;&#9;end&#10;&#9;&#9;return status:data(&quot;VERS&quot;) &gt;= version&#10;&#9;end&#10;&#9;&#10;&#9;return waitOnIncompleteActors(path, 'BALL', 'CSWV', AtomContainer.new{'CHPC'}, checkDone)&#10;end&#10;&#10;function clearCache(path)&#10;&#9;gtInfoCache:clear(path)&#10;&#9;updateInfo()&#10;&#9;return 1, OID_GRIDTASK_MSG_NONE&#10;end&#10;&#10;-- ------------------------------------------------------------------------------&#10;-- Helper function to create an atom container populated with the list of nodes&#10;-- requested in actorTable, which may be &quot;BALL&quot; to request all nodes.&#10;-- ------------------------------------------------------------------------------&#10;--  2010-04-12 KJ : Updated&#10;-- ------------------------------------------------------------------------------&#10;function actorTableToContainer(actorTable)&#10;&#9;local container = AtomContainer.new{'NODS'}&#10;&#9;&#10;&#9;if actorTable == &quot;BALL&quot; then&#10;&#9;&#9;local nodeTypes = {'BADC', 'BLDR', 'BCMS', 'BNMS', 'BAMS', 'BSSM', 'BCLB', 'BCMN', 'BARC'}&#10;&#9;&#9;local i = 1&#10;&#9;&#9;for _, nodeType in pairs(nodeTypes) do&#10;&#9;&#9;&#9;local nodes = actorsToList(nodeType)&#10;&#9;&#9;&#9;for _,nid in pairs(nodes) do&#10;&#9;&#9;&#9;&#9;local path = string.format(&quot;%04X&quot;, i)&#10;&#9;&#9;&#9;&#9;container:set_ui32(path..&quot;/NOID&quot;, nid)&#10;&#9;&#9;&#9;&#9;container:set_fc32(path..&quot;/DTYP&quot;, nodeType)&#10;&#9;&#9;&#9;&#9;i = i + 1&#10;&#9;&#9;&#9;end&#10;&#9;&#9;end&#10;&#9;else&#10;&#9;&#9;local nodes = actorsToList(actorTable)&#10;&#9;&#9;local i = 1&#10;&#9;&#9;for _,nid in pairs(nodes) do&#10;&#9;&#9;&#9;local path = string.format(&quot;%04X&quot;, i)&#10;&#9;&#9;&#9;container:set_ui32(path..&quot;/NOID&quot;, nid)&#10;&#9;&#9;&#9;i = i + 1&#10;&#9;&#9;end&#10;&#9;end&#10;&#9;&#10;&#9;return container&#10;end&#10;&#10;-- ------------------------------------------------------------------------------&#10;-- Helper function similar to waitOnActors() to wait for a check on all members&#10;-- of a specified table of actors to meet some condition.&#10;-- Unlike waitOnActors(), this function does not re-check any actors that have&#10;-- successfully completed the check (through caching of the list of actors).&#10;-- ------------------------------------------------------------------------------&#10;--  2010-04-12 KJ : Updated&#10;-- ------------------------------------------------------------------------------&#10;function waitOnIncompleteActors(actorCachePath, actorTable, checkType, checkPc, checkDoneFn, abortOnError)&#10;&#9;-- Load or create the cached container of nodes&#10;&#9;local actorCont = cacheLoad(actorCachePath) or actorTableToContainer(actorTable)&#10;&#9;local done = true&#10;&#9;local totN = UINT64.new(0)&#10;&#9;local totD = UINT64.new(0)&#10;&#9;&#10;&#9;for nodeCont in actorCont:datas() do&#10;&#9;&#9;local nid = nodeCont:data('NOID')&#10;&#9;&#9;local nodeDone = nodeCont:data('DONE')&#10;&#9;&#9;local nodeN = nodeCont:data('NODN') or 0&#10;&#9;&#9;local nodeD = nodeCont:data('NODD') or 1&#10;&#9;&#9;&#10;&#9;&#9;if nodeDone then&#10;&#9;&#9;&#9;-- Skip any node on which the check has already been completed&#10;&#9;&#9;&#9;Debug.log(&quot;info&quot;,&quot;Check&quot;, checkType, &quot;on node&quot;, nid, &quot;already done&quot;, &quot;progress&quot;, nodeN, &quot;/&quot;, nodeD)&#10;&#9;&#9;else&#10;&#9;&#9;&#9;local resp = postCheckAsk(nid, checkType, checkPc)&#10;&#9;&#9;&#10;&#9;&#9;&#9;if resp:data('/RSLT') == 'SUCS' then&#10;&#9;&#9;&#9;&#9;nodeDone, nodeN, nodeD = checkDoneFn(nid, resp:data('/CSTC'), nodeCont)&#10;&#9;&#9;&#9;&#9;nodeN = nodeN or ((nodeDone and 1) or 0)&#10;&#9;&#9;&#9;&#9;nodeD = nodeD or 1&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;Debug.log(&quot;info&quot;,&quot;Check&quot;, checkType, &quot;on node&quot;, nid, &quot;done&quot;, nodeDone, &quot;progress&quot;, nodeN, &quot;/&quot;, nodeD)&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;if nodeDone then&#10;&#9;&#9;&#9;&#9;&#9;actorCont:set_ui32(nodeCont:name()..'/DONE', 1)&#10;&#9;&#9;&#9;&#9;end&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;actorCont:set_ui64(nodeCont:name()..'/NODN', nodeN)&#10;&#9;&#9;&#9;&#9;actorCont:set_ui64(nodeCont:name()..'/NODD', nodeD)&#10;&#9;&#9;&#9;else&#10;&#9;&#9;&#9;&#9;Debug.log(&quot;warn&quot;,&quot;Check&quot;, checkType, &quot;failed on node&quot;, nid)&#10;&#9;&#9;&#9;end&#10;&#9;&#9;end&#10;&#9;&#9;&#10;&#9;&#9;done = done and nodeDone&#10;&#9;&#9;totN = totN + nodeN&#10;&#9;&#9;totD = totD + nodeD&#10;&#9;end&#10;&#9;&#10;&#9;Debug.log(&quot;info&quot;,&quot;Overall check&quot;, checkType, &quot;done&quot;, done, &quot;progress&quot;, totN, &quot;/&quot;, totD)&#10;&#9;&#10;&#9;-- Update NMS attributes&#10;&#9;stageReport(gtStageString, totN, totD)&#10;&#9;&#10;&#9;-- Update the cached data table&#10;&#9;gtInfoCache:clear(actorCachePath)&#10;&#9;cacheStore(actorCachePath, actorCont)&#10;&#9;&#10;&#9;if(not done) then&#10;&#9;&#9;if(abortOnError) then&#10;&#9;&#9;&#9;return 0, OID_GRIDTASK_MSG_WAITING&#10;&#9;&#9;end&#10;&#9;&#9;return 4, &quot;Again&quot;&#10;&#9;end&#10;&#10;&#9;return 1, &quot;OK&quot;&#10;end&#10;&#10;function gtPrepare()&#10;&#9;--FIXME: is some kind of pre-check necessary?&#10;&#10;&#9;pushAbort(&quot;taskFinished()&quot;)&#10;&#10;&#9;local adeVersion = taskParams:data(&quot;NAVR&quot;)&#10;&#9;local cmsVersion = taskParams:data(&quot;NCVR&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;pushAbort(&quot;getLocks({})&quot;)&#10;&#9;addStage(&quot;getLocks({['GRID-UPGRADE'] = true})&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_RESOURCE_PRELOAD)&quot;)&#10;&#9;&#10;&#9;for node in taskParams:datas(&quot;/RUPD&quot;) do&#10;&#9;&#9;local nodeType = node:name()&#10;&#9;&#9;local update = &quot;/RUPD/&quot;..nodeType..&quot;/UPDT&quot;&#10;&#9;&#9;&#10;&#9;&#9;addStage(&quot;getLocks({['GRID-UPGRADE'] = true, ['&quot;..nodeType..&quot;-RESOURCES'] = true})&quot;)&#10;&#9;&#9;pushAbort(&quot;unloadResources('&quot;..nodeType..&quot;')&quot;)&#10;&#9;&#9;addStage(&quot;preloadResources('&quot;..nodeType..&quot;',&quot;..adeVersion..&quot;,'&quot;..update..&quot;')&quot;)&#10;&#9;end&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_BUNDLE_IMPORT..' 1')&quot;)&#10;&#9;addStage(&quot;getLocks({['GRID-UPGRADE'] = true, ['GRID-BUNDLE'] = true})&quot;)&#10;&#9;addStage(&quot;addBundles('/BDL1')&quot;)&#10;&#9;addStage(&quot;getLocks({['GRID-UPGRADE'] = true})&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_VERSION_WAIT)&quot;)&#10;&#9;addStage(&quot;waitVersion('NODS', &quot;..adeVersion..&quot;,&quot;..cmsVersion..&quot;)&quot;)&#10;&#9;addStage(&quot;clearCache('NODS')&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_RESOURCE_UNLOAD_WAIT)&quot;)&#10;&#9;&#10;&#9;for node in taskParams:datas(&quot;/RUPD&quot;) do&#10;&#9;&#9;local nodeType = node:name()&#10;&#9;&#9;&#10;&#9;&#9;addStage(&quot;waitUnloadResources('&quot;..nodeType..&quot;')&quot;)&#10;&#9;end&#10;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;for node in taskParams:datas(&quot;/RUPD&quot;) do&#10;&#9;&#9;popAbort()&#10;&#9;end&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_BUNDLE_COMMIT)&quot;)&#10;&#9;addStage(&quot;getLocks({['GRID-UPGRADE'] = true, ['GRID-BUNDLE'] = true})&quot;)&#10;&#9;addStage(&quot;commitBundles('/BCMT')&quot;)&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_BUNDLE_IMPORT..' 2')&quot;)&#10;&#9;addStage(&quot;addBundles('/BDL2')&quot;)&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;-- Transfer S3 Accounts from S3AC bundle to Account Server&#10;&#9;addStage(&quot;getLocks({['GRID-UPGRADE'] = true})&quot;)&#10;&#9;-- Use first DDS, as only a single DDS needs to run this task.&#10;&#9;local targetDdsNid = taskParams:data(&quot;TDDS&quot;)&#10;&#9;addStage(&quot;startAction(&quot;..targetDdsNid..&quot;, 'TS3A', AtomContainer.new{'AAPC'})&quot;)&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_TRANSFER_S3_ACCOUNTS)&quot;)&#10;&#9;addStage(&quot;waitDone(&quot;..targetDdsNid..&quot;, 'TS3A', AtomContainer.new{'AAPC'})&quot;)&#10;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;addStage(&quot;getLocks({})&quot;)&#10;&#9;popAbort() -- RLOK&#10;&#9;&#10;&#9;--------------------------------------------------------------------------------&#10;&#9;popAbort()&#10;&#9;&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;&#9;addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;end&#10;"/>
			</container>
			<container name="UFLT">
				<atom name="0001" type="CSTR" value="-- Update Flags Task&#10;-- Version 1&#10;&#10;&#10;function updateNodeResources(nid, update)&#10;&#9;return executeOnActor(nid, 'UPRE',&#10;&#9;&#9;AtomContainer.new{'AAPC', UPDT = taskParams:data(update)})&#10;end&#10;&#10;function shutdownNode(nid)&#10;&#9;local resp = postCheckAsk(nid, 'CSTT', AtomContainer.new{'CHPC'})&#10;&#10;&#9;if(resp:data('/RSLT') == 'SUCS') then&#10;&#9;&#9;initTime = resp:data('/CSTC/CSTT')&#10;&#9;&#9;cacheStore(&quot;ITME&quot;, initTime)&#10;&#9;else&#10;&#9;     return 0,&quot;Error&quot;&#10;&#9;end&#10;&#10;&#9;return executeOnActor(nid, 'SHDN', AtomContainer.new{'AAPC', DELY = {ui64 = 1000000 }})&#10;&#10;end&#10;&#10;function checkRestartTime(nid)&#10;&#9;local function checkDone(nid, status)&#10;&#9;&#9;-- TODO This assumes monotonically increasing clock after node restart, which isn't guaranteed&#10;&#9;&#9;return initTime &lt; status:data(&quot;CSTT&quot;)&#10;&#9;end&#10;&#9;return waitOnActors(nid, 'CSTT', AtomContainer.new{'CHPC'}, checkDone, true)&#10;end&#10;&#10;function executeUPDT(nid, update, restart)&#10;&#9;numNodes = numNodes + 1&#10;&#9;&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_RESOURCE_UPDATE..' (&quot;..numNodes..&quot;/'..numNodes..'): '..OID_GRIDTASK_MSG_NID..' &quot;..nid..&quot;')&quot;)&#10;&#9;addStage(&quot;updateNodeResources('&quot;..nid..&quot;','&quot;..update..&quot;')&quot;)&#10;&#9;&#10;&#9;if (restart == 1) then&#10;&#9;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_RESOURCE_UPDATE..' (&quot;..numNodes..&quot;/'..numNodes..'): '..OID_GRIDTASK_MSG_NID..' &quot;..nid..&quot;')&quot;)&#10;&#9;&#9;addStage(&quot;shutdownNode('&quot;..nid..&quot;')&quot;)&#10;&#9;&#9;&#10;&#9;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_RESTART_WAIT..' (&quot;..numNodes..&quot;/'..numNodes..'): '..OID_GRIDTASK_MSG_NID..' &quot;..nid..&quot;')&quot;)&#10;&#9;&#9;addStage(&quot;checkRestartTime('&quot;..nid..&quot;')&quot;)&#10;&#9;end&#10;end&#10;&#10;function gtPrepare()&#10;&#10;&#9;pushAbort(&quot;taskFinished()&quot;)&#10;&#10;&#9;-------------------------------------------------------------------------&#10;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;&#9;pushAbort(&quot;getLocks({})&quot;)&#10;&#9;&#10;&#9;-------------------------------------------------------------------------&#10;&#9;for node in taskParams:datas(&quot;/UFLT&quot;) do&#10;&#9;&#9;local nodeType = node:name()&#10;&#9;&#9;local update = &quot;/UFLT/&quot;..nodeType..&quot;/UPDT&quot;&#10;&#9;&#9;local restart = node:data(&quot;REST&quot;)&#10;&#9;&#9;local targets = node:data(&quot;TRGT&quot;)&#10;&#10;&#9;&#9;for name,_,value in targets:tuples() do&#10;&#9;&#9;&#9;if (name == &quot;NTYP&quot;) then&#10;&#9;&#9;&#9;&#9;addStage(&quot;getLocks({['&quot;..value..&quot;-RESOURCES'] = true})&quot;)&#10;&#9;&#9;&#10;&#9;&#9;&#9;&#9;if(restart == 1) then&#10;&#9;&#9;&#9;&#9;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_RESOURCE_UPDATE)&quot;)&#10;&#9;&#9;&#9;&#9;&#9;addStage(&quot;waitUser(OID_GRIDTASK_MSG_UFLTWAIT_TYPE..' &quot;..value..&quot;')&quot;)&#10;&#9;&#9;&#9;&#9;end&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;local nodes = actorsToList(value)&#10;&#9;&#9;&#9;&#9;table.sort(nodes)&#9;-- As of 8.2, this task is specified to process nodes in ascending numerical NID order&#10;&#9;&#9;&#9;&#9;for _,nid in pairs(nodes) do&#10;&#9;&#9;&#9;&#9;&#9;executeUPDT(nid, update, restart)&#10;&#9;&#9;&#9;&#9;end&#10;&#9;&#9;&#9;elseif (name == &quot;NOID&quot;) then&#10;&#9;&#9;&#9;&#9;if(restart == 1) then&#10;&#9;&#9;&#9;&#9;&#9;addStage(&quot;stageName(OID_GRIDTASK_STAGE_RESOURCE_UPDATE)&quot;)&#10;&#9;&#9;&#9;&#9;&#9;addStage(&quot;waitUser(OID_GRIDTASK_MSG_UFLTWAIT_NODE..' &quot;..value..&quot;')&quot;)&#10;&#9;&#9;&#9;&#9;end&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;executeUPDT(value, update, restart)&#10;&#9;&#9;&#9;end&#10;&#9;&#9;end&#10;&#9;end&#10;&#9;-------------------------------------------------------------------------&#10;&#9;addStage(&quot;getLocks({})&quot;)&#10;&#9;popAbort() -- RLOK&#10;&#9;&#10;&#9;-------------------------------------------------------------------------&#10;&#9;popAbort()&#10;&#9;addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;&#9;addStage(&quot;taskFinished()&quot;)&#10;&#9;&#10;&#9;cacheStore(&quot;NUMN&quot;, numNodes)&#10;end&#10;&#10;&#10;function gtInit()&#10;&#9;-- Count the number of nodes to be updated, for status reporting&#10;&#9;numNodes = cacheLoad(&quot;NUMN&quot;) or 0&#10;&#9;&#10;&#9;-- Last init time for node restart check&#10;&#9;initTime = cacheLoad(&quot;ITME&quot;) or UINT64.new(0)&#10;end&#10;"/>
			</container>
			<container name="VFGV">
				<atom name="0001" type="CSTR" value="-- Volume Foreground Verification Task&#10;-- Version 1&#10;&#10;&#10;function abortVFGV()&#10;    -- Helper function to clean up a verification task&#10;    local res,reas&#10;&#10;    Debug.log(&quot;warn&quot;,&quot;Stopping VFGV actions&quot;)&#10;    for _,nid in pairs(cmnList) do&#10;&#10;        res,reas = stopAction(nid,'VFGV',gtActPc)&#10;        if(res ~= 1) then&#10;            return 0,reas&#10;        end&#10;    end&#10;&#10;    if (res ~= 1) then&#10;        return 0,reas&#10;    else&#10;        return 1,&quot;OK&quot;&#10;    end&#10;end&#10;&#10;function resetAttributes(nid)&#10;    return executeOnActor(nid, 'SVRA', gtActPc)&#10;end&#10;&#10;function gtPrepare()&#10;    -- Called once, the first time that the task is run.&#10;    pushAbort(&quot;taskFinished()&quot;)&#10;    for ldr in taskParams:datas('/SLDR') do&#10;        pushAbort(&quot;resetAttributes(&quot;..ldr..&quot;)&quot;)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)&quot;)&#10;    pushAbort(&quot;getLocks({})&quot;)&#10;    addStage(&quot;getLocks({['GRID-FGV'] = true})&quot;)&#10;&#10;    pushAbort(&quot;abortVFGV()&quot;)&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_STARTING)&quot;)&#10;&#10;    for _,targetCMN in pairs(cmnList) do&#10;        addStage(&quot;startAction(&quot;..targetCMN..&quot;,'VFGV',gtActPcStart)&quot;)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_DESC_LDR_VERIFY)&quot;)&#10;    addStage(&quot;waitDone(cmnList, 'VFGV', gtActPcCheck)&quot;)&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_STAGE_FINISHING)&quot;)&#10;    for _,targetCMN in pairs(cmnList) do&#10;        addStage(&quot;stopAction(&quot;..targetCMN..&quot;,'VFGV',gtActPc)&quot;)&#10;    end&#10;&#10;    addStage(&quot;stageName(OID_GRIDTASK_ACTION_VERIFY_ATTR_RESET)&quot;)&#10;    for ldr in taskParams:datas('/SLDR') do&#10;        addStage(&quot;resetAttributes(&quot;..ldr..&quot;)&quot;)&#10;    end&#10;&#10;    addStage(&quot;getLocks({})&quot;)&#10;    popAbort() -- RLOK&#10;    popAbort() -- abortVFGV()&#10;    for ldr in taskParams:datas('/SLDR') do&#10;        popAbort() -- resetAttributes&#10;    end&#10;&#10;    popAbort()&#10;&#10;    addStage(&quot;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)&quot;)&#10;    addStage(&quot;taskFinished()&quot;)&#10;end&#10;&#10;function gtInit()&#10;    -- Called every time that the task is run (first time, as well as after any CMN restart).&#10;&#10;    gtActPc = AtomContainer.new{'AAPC'}&#10;    cmnList = actorsToList('BCMN', true)&#10;&#10;    local idx = 1&#10;    local noidTable = {}&#10;    local volIdTable = {}&#10;&#10;    for ldr in taskParams:datas('/SLDR') do&#10;        table.insert(noidTable, ldr)&#10;    end&#10;    for vid in taskParams:datas('/SVOL') do&#10;        table.insert(volIdTable, vid)&#10;    end&#10;&#10;    if (table.getn(noidTable) ~= table.getn(volIdTable)) then&#10;        Debug.log(&quot;err&quot;,&quot;Noid and VolId pair does not match&quot;)&#10;    end&#10;&#10;    local atomTableStart = {}&#10;    local atomTableCheck = {}&#10;    atomTableStart[1] = 'AAPC'&#10;    atomTableCheck[1] = 'CHPC'&#10;    for key,noid in ipairs(noidTable) do&#10;        local idxStr = string.format(&quot;%04X&quot;, idx)&#10;        local volId = volIdTable[key]&#10;        atomTableStart[idxStr] = AtomContainer.new{idxStr, NOID={ui32 = noid}, VOID ={ui64 = volId}}&#10;        atomTableCheck[idxStr] = AtomContainer.new{idxStr, NOID={ui32 = noid}, VOID ={ui64 = volId}}&#10;        idx = idx + 1&#10;    end&#10;&#10;    gtActPcStart = AtomContainer.new(atomTableStart)&#10;    gtActPcCheck = AtomContainer.new(atomTableCheck)&#10;end&#10;"/>
			</container>
		</container>
	</container>
</containerxml>
