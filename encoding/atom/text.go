package atom

import (
	"bytes"
	"fmt"
)

// Enable reading and writing of text format ADE AtomContainers by fulfilling
// these interfaces from stdlib encoding/:

// TextMarshaler is the interface implemented by an object that can marshal
// itself into a textual form.
//
// MarshalText encodes the receiver into UTF-8-encoded text and returns the result.
//
//     type TextMarshaler interface {
//         MarshalText() (text []byte, err error)
//     }

// TextUnmarshaler is the interface implemented by an object that can unmarshal
// a textual representation of itself.
//
// UnmarshalText must be able to decode the form generated by MarshalText.
// UnmarshalText must copy the text if it wishes to retain the text after
// returning.
//
//     type TextUnmarshaler interface {
//     	   UnmarshalText(text []byte) error
//     }

// Write Atom object to a byte slice in ADE ContainerText format.
func (a *Atom) MarshalText() (text []byte, err error) {
	buf := atomToTextBuffer(a, 0)
	text = buf.Bytes()
	return text, err
}

func atomToTextBuffer(a *Atom, depth int) bytes.Buffer {
	var (
		output        bytes.Buffer
		printableName string
	)
	// print atom name + type
	if isPrint(a.Name) {
		printableName = a.Name
	} else {
		printableName = fmt.Sprintf("0x%+08X", a.Name)
	}
	fmt.Fprintf(&output, "% *s%s:%s:", depth*4, "", printableName, a.Type)
	if a.hasValue() {
		fmt.Fprintln(&output, a.Value())
	} else {
		fmt.Fprintln(&output)
	}

	// print children
	if a.Type == "CONT" {
		for _, childPtr := range a.Children {
			buf := atomToTextBuffer(childPtr, depth+1)
			output.Write(buf.Bytes())
			fmt.Print(buf.String())
		}
	}
	return output
}

func (a *Atom) hasValue() bool {
	if a.Type == "CONT" || a.Type == "NULL" {
		return false
	}
	return true
}

func (a *Atom) ValueAsText() (buf []byte) {
	if !a.hasValue() {
		return
	}

	v := a.Value()
	switch v.Type() {
	}
	return
}
