<?xml version="1.0" encoding="UTF-8"?>
<containerxml version="1" xmlns="http://www.bycast.com/schemas/XML-container-1.0.0">
	<container name="GTDB">
		<atom name="BVER" type="UI32" value="1"></atom>
		<atom name="BTIM" type="UI64" value="1484723612385978"></atom>
		<container name="TSKS">
			<container name="BCMT">
				<atom name="0001" type="CSTR" value="-- Bundle Commit Task\n-- Version 1\n\nfunction commitBundles(path)\n\x09local result = 1\n\x09local reason = OID_GRIDTASK_MSG_NONE\n\x09\n\x09for data in taskParams:datas(path) do\n\x09\x09data:set_name(&#39;AAPC&#39;)\n\x09\x09result,reason = executeOnOneActor(&#39;BCMN&#39;, &#39;BCMT&#39;, data)\n\x09\x09if(result ~= 1) then\n\x09\x09\x09Debug.log(\&#34;warn\&#34;,\&#34;Exiting bundle-commit loop, reason =\&#34;,reason)\n\x09\x09\x09break\n\x09\x09end\n\x09end\n\n\x09return result,reason\nend\n\nfunction gtPrepare()\n\x09pushAbort(\&#34;taskFinished()\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09pushAbort(\&#34;getLocks({})\&#34;)\n\x09addStage(\&#34;getLocks({[&#39;GRID-BUNDLE&#39;] = true})\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_BUNDLE_COMMIT)\&#34;)\n\x09addStage(\&#34;commitBundles(&#39;/&#39;)\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;getLocks({})\&#34;)\n\x09popAbort() -- RLOK\n\x09\n\x09--------------------------------------------------------------------------------\n\x09popAbort()\n\x09\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n\x09addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\nend\n"></atom>
			</container>
			<container name="BDLI">
				<atom name="0001" type="CSTR" value="-- Bundle Import Task\n-- Version 1\n\nfunction addBundles(path)\n\x09local result = 1\n\x09local reason = OID_GRIDTASK_MSG_NONE\n\x09\n\x09for data in taskParams:datas(path) do\n\x09\x09data:set_name(&#39;AAPC&#39;)\n\x09\x09result,reason = executeOnOneActor(&#39;BCMN&#39;, &#39;BDLI&#39;, data)\n\x09\x09if(result ~= 1) then\n\x09\x09\x09Debug.log(\&#34;warn\&#34;,\&#34;Exiting bundle-import loop, reason =\&#34;,reason)\n\x09\x09\x09break\n\x09\x09end\n\x09end\n\n\x09return result,reason\nend\n\nfunction gtPrepare()\n\x09pushAbort(\&#34;taskFinished()\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09pushAbort(\&#34;getLocks({})\&#34;)\n\x09addStage(\&#34;getLocks({[&#39;GRID-BUNDLE&#39;] = true})\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_BUNDLE_IMPORT)\&#34;)\n\x09addStage(\&#34;addBundles(&#39;/&#39;)\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;getLocks({})\&#34;)\n\x09popAbort() -- RLOK\n\x09\n\x09--------------------------------------------------------------------------------\n\x09popAbort()\n\x09\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n\x09addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\nend\n"></atom>
			</container>
			<container name="CCLE">
				<atom name="0001" type="CSTR" value="-- Nodetool cleanup task\n-- Version 1\n\nfunction waitForNewDDS(nid, value)\n        -- See if DDS is in the expected state\n        local function checkDone(nid, status)\n            return status:data(\&#34;STCR\&#34;) == value\n        end\n        return waitOnActors(nid, &#39;DDSS&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone, true)\nend\n\nfunction gtPrepare()\n    pushAbort(\&#34;taskFinished()\&#34;)\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n    pushAbort(\&#34;getLocks({})\&#34;)\n\n    ---------------------------------------------------------------------------\n    --Check whether the new DDSs are in the expected state: cassandra up running\n    for nid in taskParams:datas(\&#34;/NDDS\&#34;) do\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CHECKING_CASSANDRA_STATUS..&#39;: &#39;..OID_GRIDTASK_MSG_NID..&#39; \&#34;..nid..\&#34;&#39;)\&#34;)\n        addStage(\&#34;waitForNewDDS(\&#34;..nid..\&#34;, &#39;REDY&#39;)\&#34;)\n    end\n\n    ---------------------------------------------------------------------------\n    -- Perform Cassandra node cleanup sequentially in old DDS nodes.\n    for nid in taskParams:datas(\&#34;/ODDS\&#34;) do\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n        addStage(\&#34;getLocks({[&#39;\&#34;..nid..\&#34;-NODETOOL&#39;] = true})\&#34;)\n        pushAbort(\&#34;stopAction(\&#34;..nid..\&#34;, &#39;CCLE&#39;, gtActPc)\&#34;)\n        addStage(\&#34;startAction(\&#34;..nid..\&#34;, &#39;CCLE&#39;, gtActPc)\&#34;)\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_RUNNING_NODETOOL_CLEAN_UP..&#39;: &#39;..OID_GRIDTASK_MSG_NID..&#39; \&#34;..nid..\&#34;&#39;)\&#34;)\n        addStage(\&#34;waitDone(\&#34;..nid..\&#34;, &#39;CCLE&#39;, gtActPc)\&#34;)\n    end\n    ---------------------------------------------------------------------------\n    addStage(\&#34;getLocks({})\&#34;)\n    popAbort() -- RLOK\n\n    for nid in taskParams:datas(\&#34;/ODDS\&#34;) do\n        popAbort() -- stopAction abortCCLE\n    end\n\n    popAbort()\n\n    addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n    addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\n\x09gtActPc = AtomContainer.new{&#39;AAPC&#39;, TKID={ui32=taskId}}\nend\n"></atom>
			</container>
			<container name="CDBR">
				<atom name="0001" type="CSTR" value="-- CMS Database Recovery Grid Task\n-- Version 1\n\nfunction abortCDBR()\n\x09-- Helper function to clean up a recovery task\n\x09local res,reas\n\n\x09Debug.log(\&#34;warn\&#34;,\&#34;Stopping CMS action\&#34;)\n\x09for _,nid in pairs(gtCmsList) do\n\x09\x09res,reas = stopAction(nid,&#39;CDBA&#39;,gtActPc)\n\x09\x09if(res ~= 1) then\n\x09\x09\x09return 0,reas\n\x09\x09end\n\x09end\n\n\x09return 1,\&#34;OK\&#34;\nend\n\nfunction gtPrepare()\n\x09-- Called once, the first time that the task is run. \n\x09\n\x09pushAbort(\&#34;taskFinished()\&#34;)\n\n\x09pushAbort(\&#34;abortCDBR()\&#34;)\n\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09pushAbort(\&#34;getLocks({})\&#34;)\n\x09addStage(\&#34;getLocks({[&#39;\&#34;..gtTargetCms..\&#34;-TASK-CDBR&#39;] = true})\&#34;)\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STARTING)\&#34;)\n\x09Debug.log(\&#34;info\&#34;, \&#34;NID = \&#34;, gtTargetCms)\n\x09\x09\n\x09for _,nid in pairs(gtCmsList) do\n\x09\x09Debug.log(\&#34;info\&#34;, \&#34;NID = \&#34;, nid)\n\x09\x09addStage(\&#34;stopAction(\&#34;..nid..\&#34;,&#39;CDBA&#39;,gtActPc)\&#34;)\n\x09end\n\x09\x09\n\x09for _,nid in pairs(gtCmsList) do\n\x09\x09addStage(\&#34;startAction(\&#34;..nid..\&#34;,&#39;CDBA&#39;,gtActPc)\&#34;)\n\x09end\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CMS_DATABASE_RECOVERY..&#39;: &#39;..OID_GRIDTASK_MSG_NID..&#39; \&#34;..gtTargetCms..\&#34;&#39;)\&#34;)\n\x09addStage(\&#34;waitDone(gtCmsList, &#39;CDBA&#39;, gtActPc)\&#34;)\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_FINISHING)\&#34;)\n\x09for _,nid in pairs(gtCmsList) do\n\x09\x09addStage(\&#34;stopAction(\&#34;..nid..\&#34;,&#39;CDBA&#39;,gtActPc)\&#34;)\n\x09end\n\x09\x09\n\x09addStage(\&#34;getLocks({})\&#34;)\n\x09popAbort() -- RLOK\n\x09\n\x09popAbort() -- abortCDBR()\n\x09\n\x09popAbort()\n\x09\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n\x09addStage(\&#34;taskFinished()\&#34;)\n\x09\n\x09-- FIXME - Save bundle to GTEN.\nend\n\x09\x09\x09\x09\nfunction gtInit()\n\x09-- Called every time that the task is run (first time, as well as after any CMN restart). \n\n\x09gtTargetCms = taskParams:data(&#39;/NOID&#39;)\n\x09\n\x09gtActPc = AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = gtTargetCms} }\n\x09gtCmsList = cacheLoadList(&#39;CMSL&#39;)\n\x09\n\x09if(gtCmsList == nil) then\n\x09\x09gtCmsList  = coFindActors(&#39;BCMS&#39;)\n\x09\x09cacheStoreList(&#39;CMSL&#39;,gtCmsList)\n\x09end\nend\n"></atom>
			</container>
			<container name="CDCM">
				<atom name="0001" type="CSTR" value="-- CMS Decommissioning Task\n-- Version 1\nfunction revokeCert(nid)\n--  return executeOnOneActor(&#39;BADC&#39;, &#39;ADBP&#39;, AtomContainer.new{&#39;AAPC&#39;, DLVL = &#39;NOTE&#39;, DSTR = \&#34;Revoking cert for \&#34;..nid})\n    return executeOnOneActor(&#39;BADC&#39;, &#39;CRVK&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}})\nend\n\nfunction removeEntity(oid)\n    return executeOnOneActor(&#39;BCMN&#39;, &#39;ANER&#39;, AtomContainer.new{&#39;AAPC&#39;, EOID = {cstr = oid}})\nend\n\nfunction setOwnerMapping(ocms, ncms)\n    return executeOnOneActor(&#39;BDDS&#39;, &#39;COWR&#39;, AtomContainer.new{&#39;AAPC&#39;, NIDS={ui32=ocms},  NIDD={ui32=ncms}})\nend\n\nfunction setServiceState(nid, value)\n    return executeOnActors(nid, &#39;SVST&#39;, AtomContainer.new{&#39;AAPC&#39;, SVST={fc32=value}})\nend\n\nfunction setAuditState(nid, value)\n    return executeOnActors(nid, &#39;AUDT&#39;, AtomContainer.new{&#39;AAPC&#39;, AUDT={fc32=value}})\nend\n\nfunction waitAudit(nid, value)\n    local function checkDone(nid, status)\n        return status:data(\&#34;AQSZ\&#34;) == UINT64.new(0)\n    end\n    return waitOnActors(nid, &#39;AUDQ&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone)\nend\n\nfunction removeNode(nid, device)\n    return executeOnOneActor(&#39;BCMN&#39;, &#39;UNOD&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}, DTYP = {fc32 = device}})\nend\n\nfunction filterCmsList(nid)\n    for i=#cmsList,1,-1 do\n        if (nid == cmsList[i]) then\n            table.remove(cmsList, i)\n        end\n    end\nend\n\nfunction gtPrepare()\n    -- Called once, the first time that the task is run.\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n    addStage(\&#34;getLocks({[&#39;BCMS-TOPOLOGY&#39;] = true})\&#34;)\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STARTING)\&#34;)\n\n    for nid in taskParams:datas(\&#34;/NOID\&#34;) do\n        filterCmsList(nid)\n    end\n\n    if(table.getn(cmsList) &gt; 0) then\n\n        for nid in taskParams:datas(\&#34;/NOID\&#34;) do\n            local newCms = cmsList[ math.random(table.getn(cmsList)) ]\n            addStage(\&#34;setOwnerMapping(\&#34;..nid..\&#34;, \&#34;..newCms..\&#34; )\&#34;)\n        end\n\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)\&#34;)\n        for nid in taskParams:datas(\&#34;/NOID\&#34;) do\n            addStage(\&#34;setServiceState(\&#34;..nid..\&#34;, &#39;DABL&#39;)\&#34;)\n        end\n\n        -- TODO: CMS doesn&#39;t support these actions/checks yet.\n        --       Uncomment when story B-25861 is implemented.\n        -- addStage(\&#34;stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)\&#34;)\n        -- for nid in taskParams:datas(\&#34;/NOID\&#34;) do\n        --     addStage(\&#34;setAuditState(\&#34;..nid..\&#34;, &#39;DABL&#39;)\&#34;)\n        --     addStage(\&#34;waitAudit(\&#34;..nid..\&#34;, &#39;DABL&#39;)\&#34;)\n        -- end\n\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)\&#34;)\n        for nid in taskParams:datas(\&#34;/NOID\&#34;) do\n            addStage(\&#34;revokeCert(\&#34;..nid..\&#34;)\&#34;)\n        end\n\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)\&#34;)\n        for eoid in taskParams:datas(\&#34;/EOID\&#34;) do\n            addStage(\&#34;removeEntity(&#39;\&#34;..eoid..\&#34;&#39;)\&#34;)\n        end\n\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)\&#34;)\n        for nid in taskParams:datas(\&#34;/NOID\&#34;) do\n            addStage(\&#34;removeNode(\&#34;..nid..\&#34;, &#39;BCMS&#39;)\&#34;)\n        end\n\n        addStage(\&#34;getLocks({})\&#34;)\n\n        addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n        addStage(\&#34;taskFinished()\&#34;)\n    else\n        Debug.log(\&#34;err\&#34;,\&#34;Owner mapping failed. No running CMS\&#34;)\n    end\nend\n\nfunction gtInit()\n    -- Called every time that the task is run (first time, as well as after any CMN restart).\n    gtActPc = AtomContainer.new{&#39;AAPC&#39;}\n    cmsList = actorsToList(&#39;BCMS&#39;, true)\nend\n"></atom>
			</container>
			<container name="CEXP">
				<atom name="0001" type="CSTR" value="-- Cassandra Site Expansion task\n-- Version 1\nfunction alterKeyspace(grps)\n    return executeOnOneActor(&#39;BDDS&#39;, &#39;AKEY&#39;, AtomContainer.new{&#39;AAPC&#39;, GRPS = {ui32 = grps}})\nend\n\nfunction gtPrepare()\n    pushAbort(\&#34;taskFinished()\&#34;)\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n    pushAbort(\&#34;getLocks({})\&#34;)\n    ---------------------------------------------------------------------------\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n    addStage(\&#34;getLocks({[&#39;GRID-CEXP&#39;] = true})\&#34;)\n\n    for grps in taskParams:datas(\&#34;/GRPS\&#34;) do\n        if grps then\n            addStage(\&#34;stageName(OID_GRIDTASK_STAGE_ALTER_KEYSPACE..&#39; Group(\&#34;..grps..\&#34;)&#39;)\&#34;)\n            addStage(\&#34;alterKeyspace(&#39;\&#34;..grps..\&#34;&#39;)\&#34;)\n        end\n    end\n    ---------------------------------------------------------------------------\n    addStage(\&#34;getLocks({})\&#34;)\n    popAbort() -- RLOK\n    popAbort()\n\n    addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n    addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\n    gtActPc = AtomContainer.new{&#39;AAPC&#39;}\nend\n"></atom>
			</container>
			<container name="CSRC">
				<atom name="0001" type="CSTR" value="-- Content Migration Cleanup Task\n-- Used to clean up after a corrupted volume is detected during a content migration stage of a hardware refresh task.\n-- Based on CSRF-1 task. Does all it does, except doesn&#39;t do the content migrate, \n--   and instead sends a CLOC_LOST for all objects on the source LDR\n-- Version 1\n\n--Storage Maintenance Mode\nfunction actionSMNT(ldr,value)\n\x09return executeOnActors(ldr, &#39;SMNT&#39;, AtomContainer.new{&#39;AAPC&#39;, SMNT={fc32=value}})\nend\n\nfunction actionCLDQ(ldr,value)\n\x09return executeOnActors(ldr, &#39;CLDQ&#39;, AtomContainer.new{&#39;AAPC&#39;, FRWD={fc32=value}})\nend\n\nfunction disableCLOCLOSTForwarding(ldr)\n\x09return actionCLDQ(ldr, &#39;DABL&#39;)\nend\n\nfunction enableCLOCLOSTForwarding(ldr)\n\x09return actionCLDQ(ldr, &#39;ENBL&#39;)\nend\n\n--Set Storage State\nfunction actionSTDS(ldr,value)\n\x09return executeOnActors(ldr, &#39;STDS&#39;, AtomContainer.new{&#39;AAPC&#39;, STDS={fc32=value}})\nend\n\n--Storage State\nfunction waitSTCR(ldr,value)\n\x09-- See if Storage is in the expected state\n\x09local function checkDone(nid, status)\n\x09\x09return status:data(\&#34;STUS\&#34;) == &#39;NONE&#39; and\n\x09\x09\x09status:data(\&#34;STCR\&#34;) == value\n\x09end\n\x09\n\x09return waitOnActors(ldr, &#39;STCR&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone)\nend\n\nfunction cmsRemap(from, to, action, skipNode)\n\x09-- Called for both the LDR-remapping and CMS-remapping actions.\n\x09\n\x09local actPc = AtomContainer.new{&#39;AAPC&#39;, SNID = {ui32 = from} ,DNID = {ui32 = to} }\n\x09\n\x09local cmsList = { }\n\x09local tmpList = coFindActors(&#39;BCMS&#39;)\n\x09\n\x09local seq = 1\n\x09for _,nid in pairs(tmpList) do\n\x09\x09-- The now-revoked gtSourceCms node ID may still show up in the coFindActors query response, and must be filtered here.\n\x09\x09\n\x09\x09if(nid ~= skipNode) then\n\x09\x09\x09cmsList[seq] = nid\n\x09\x09\x09seq = seq + 1\n\x09\x09else\n\x09\x09\x09Debug.log(\&#34;note\&#34;,\&#34;Excluding NID \&#34;..skipNode..\&#34;from coFindActors() response\&#34;)\n\x09\x09end\n\x09end\n\n\x09return executeOnActors(cmsList, action, actPc)\nend\n\nfunction revokeCert(nid)\n\x09return executeOnOneActor(&#39;BADC&#39;, &#39;CRVK&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}})\nend\n\nfunction removeEntity(oid)\n\x09return executeOnOneActor(&#39;BCMN&#39;, &#39;ANER&#39;, AtomContainer.new{&#39;AAPC&#39;, EOID = {cstr = oid}})\nend\n\nfunction setServiceState(nid, value)\n\x09return executeOnActors(nid, &#39;SVST&#39;, AtomContainer.new{&#39;AAPC&#39;, SVST={fc32=value}})\nend\n\nfunction setAuditState(nid, value)\n\x09return executeOnActors(nid, &#39;AUDT&#39;, AtomContainer.new{&#39;AAPC&#39;, AUDT={fc32=value}})\nend\n\nfunction waitAudit(nid, value)\n\x09local function checkDone(nid, status)\n\x09\x09return status:data(\&#34;AQSZ\&#34;) == UINT64.new(0)\n\x09end\n\x09return waitOnActors(nid, &#39;AUDQ&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone)\nend\n\nfunction removeGrade(nid)\n\x09return executeOnOneActor(&#39;BCMN&#39;, &#39;USTG&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}})\nend\n\nfunction removeNode(nid, device)\n\x09return executeOnOneActor(&#39;BCMN&#39;, &#39;UNOD&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}, DTYP = {fc32 = device}})\nend\n\nfunction checkOnline(nid)\n\x09-- Uses the \&#34;Version Check\&#34; check to make sure that the target node is reachable. Doesn&#39;t care about the actual version.\n\x09\n\x09local resp = postCheckAsk(nid, &#39;CSWV&#39;, AtomContainer.new{&#39;CHPC&#39;})\n\n\x09if(resp:data(&#39;/RSLT&#39;) == &#39;SUCS&#39;) then\n\x09\x09return 1, \&#34;OK\&#34;\n\x09else\n\x09\x09return 0, OID_GRIDTASK_MSG_CHECK_FAILED..\&#34; - \&#34;..OID_GRIDTASK_MSG_NID..\&#34; \&#34;..nid\n\x09end\n\nend\n\nfunction checkTargetExists(nid, dtype)\n\x09-- FIXME - This is inefficient; replace with a direct \&#34;certificate lookup\&#34; check once a proper Certificate grid service has been implemented.\n\x09\n\x09exists = false\n\x09\n\x09tmpList = coFindActors(dtype)\n\x09\n\x09for _,foundnid in pairs(tmpList) do\n\x09\x09if(nid == foundnid) then\n\x09\x09\x09exists = true\n\x09\x09end\n\x09end\n\x09\n\x09if(exists) then\n\x09\x09return 1, \&#34;OK\&#34;\n\x09else\n\x09\x09return 0, OID_GRIDTASK_MSG_NOID_NOT_FOUND..nid\x09\n\x09end\nend\n\nfunction sendObjectLost(ldr)\n\x09return executeOnOneActor(&#39;BLDR&#39;, &#39;OLOA&#39;, AtomContainer.new{&#39;AAPC&#39;, SNID = {ui32 = ldr}})\nend\n\nfunction gtPrepare()\n\x09-- Called once, the first time that the task is run. \n\n\x09pushAbort(\&#34;taskFinished()\&#34;)\n\x09\n\x09-- Make sure that DLDR and DCMS (if specified) exist in the grid. This is done before the topology lock\n\x09-- is acquired, so that it&#39;s still possible for the user to recover if he/she forgot to run the expansion tasks\n\x09-- before starting this Cleanup task.\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_VERIFY_TARGETS_EXIST)\&#34;)\n\x09\n\x09if (gtDestCms) then\n\x09\x09addStage(\&#34;checkTargetExists(\&#34;..gtDestCms..\&#34;,&#39;BCMS&#39;)\&#34;)\n\x09end\n\x09\n\x09if (gtDestLdr) then\n\x09\x09addStage(\&#34;checkTargetExists(\&#34;..gtDestLdr..\&#34;,&#39;BLDR&#39;)\&#34;)\n\x09end\n\x09\n\x09popAbort()\x09-- Abort not permitted beyond this point\n\x09\x09\n\x09if gtSourceLdr then\n\x09\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09\x09addStage(\&#34;getLocks({[&#39;\&#34;..gtDestLdr..\&#34;-STORAGE&#39;] = true})\&#34;)\n\x09\x09\n\x09\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STORAGE_STATE_WAIT)\&#34;)\n\x09\x09addStage(\&#34;waitSTCR(\&#34;..gtDestLdr..\&#34;,&#39;READ&#39;)\&#34;)\n\n\x09\x09addStage(\&#34;disableCLOCLOSTForwarding(\&#34;..gtDestLdr..\&#34;)\&#34;)\n\n\x09\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_SEND_OBJECT_LOST)\&#34;)\n\x09\x09addStage(\&#34;sendObjectLost(\&#34;..gtSourceLdr..\&#34;)\&#34;)\n\x09\x09\n\x09\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09\x09addStage(\&#34;getLocks({[&#39;\&#34;..gtDestLdr..\&#34;-STORAGE&#39;] = true, [&#39;BCMS-TOPOLOGY&#39;] = false})\&#34;)\n\n\x09\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CONTENT_REMAP)\&#34;)\n\x09\x09addStage(\&#34;cmsRemap(\&#34;..gtSourceLdr..\&#34;,\&#34;..gtDestLdr..\&#34;, &#39;LRMP&#39;, gtSourceCms)\&#34;)\n\x09\x09addStage(\&#34;getLocks({[&#39;\&#34;..gtDestLdr..\&#34;-STORAGE&#39;] = true})\&#34;)\n\n\x09\x09addStage(\&#34;enableCLOCLOSTForwarding(\&#34;..gtDestLdr..\&#34;)\&#34;)\n\n\x09\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)\&#34;)\n\x09\x09addStage(\&#34;actionSTDS(\&#34;..gtDestLdr..\&#34;,&#39;RDWR&#39;)\&#34;)\n\x09end\n\x09\n\x09local sourceNodes = {BADC = gtSourceAdc, BSSM = gtSourceSsm}\n\x09\n\x09local locks = \&#34;[&#39;GRID-BUNDLE&#39;] = true\&#34;\n\x09for nodeType, nid in pairs(sourceNodes) do\n\x09\x09locks = locks..\&#34;, [&#39;\&#34;..nodeType..\&#34;-TOPOLOGY&#39;] = true\&#34;\n\x09end\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09addStage(\&#34;getLocks({\&#34;..locks..\&#34;})\&#34;)\n\x09\n\x09for nodeType, nid in pairs(sourceNodes) do\n\x09\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)\&#34;)\n\x09\x09addStage(\&#34;setServiceState(\&#34;..nid..\&#34;, &#39;DABL&#39;)\&#34;)\n\x09\x09\n\x09\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)\&#34;)\n\x09\x09addStage(\&#34;setAuditState(\&#34;..nid..\&#34;, &#39;DABL&#39;)\&#34;)\n\x09\x09addStage(\&#34;waitAudit(\&#34;..nid..\&#34;)\&#34;)\n\x09end\n\x09\n\x09local revokeNodes = {BLDR = gtSourceLdr, BADC = gtSourceAdc, BSSM = gtSourceSsm}\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)\&#34;)\n\x09for nodeType, nid in pairs(revokeNodes) do\n\x09\x09addStage(\&#34;revokeCert(\&#34;..nid..\&#34;)\&#34;)\n\x09end\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)\&#34;)\n\x09addStage(\&#34;removeEntity(&#39;\&#34;..gtSourceOid..\&#34;&#39;)\&#34;)\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)\&#34;)\n\x09\n\x09for nodeType, nid in pairs(revokeNodes) do\n\x09\x09addStage(\&#34;removeNode(\&#34;..nid..\&#34;, &#39;\&#34;..nodeType..\&#34;&#39;)\&#34;)\n\x09end\n\x09\n\x09if gtSourceLdr then\n\x09\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_GRADE_REMOVE)\&#34;)\n\x09\x09addStage(\&#34;removeGrade(\&#34;..gtSourceLdr..\&#34;)\&#34;)\n\x09end\n\x09\n\x09addStage(\&#34;getLocks({})\&#34;)\n\x09\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n\x09addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\n\x09-- Called every time that the task is run (first time, as well as after any CMN restart). \n\n\x09-- Depending on the node type, some of these may be null. \n\x09gtSourceLdr = taskParams:data(&#39;/SLDR&#39;)\n\x09gtDestLdr = taskParams:data(&#39;/DLDR&#39;)\n\x09gtSourceCms = taskParams:data(&#39;/SCMS&#39;)\n\x09gtDestCms = taskParams:data(&#39;/DCMS&#39;)\n\x09\n\x09gtSourceAdc = taskParams:data(&#39;/SADC&#39;)\x09-- No \&#34;Dest\&#34; needed for ADC and SSM; just decommission the Src nodes\n\x09gtSourceSsm = taskParams:data(&#39;/SSMN&#39;)\n\x09\n\x09gtSourceOid = taskParams:data(&#39;/EOID&#39;)\x09-- OID for the server\n\x09\n\x09if gtDestLdr then\n\x09\x09gtActPc = AtomContainer.new{&#39;AAPC&#39;, DNID = {ui32 = gtDestLdr} }\n\x09end\nend\n"></atom>
			</container>
			<container name="CSRF">
				<atom name="0001" type="CSTR" value="-- Control/Storage Hardware Refresh Task (replaces LMIG)\n-- When splitting a combo-node ([A]GCSN) this task must be run after the Admin/Gateway ones.\n-- Version 1\n\nfunction actionSMNT(ldr,value)\n    return executeOnActors(ldr, &#39;SMNT&#39;, AtomContainer.new{&#39;AAPC&#39;, SMNT={fc32=value}})\nend\n\nfunction actionCLDQ(ldr,value)\n    return executeOnActors(ldr, &#39;CLDQ&#39;, AtomContainer.new{&#39;AAPC&#39;, FRWD={fc32=value}})\nend\n\nfunction disableCLOCLOSTForwarding(ldr)\n    return actionCLDQ(ldr, &#39;DABL&#39;)\nend\n\nfunction enableCLOCLOSTForwarding(ldr)\n    return actionCLDQ(ldr, &#39;ENBL&#39;)\nend\n\nfunction actionSTDS(ldr,value)\n    return executeOnActors(ldr, &#39;STDS&#39;, AtomContainer.new{&#39;AAPC&#39;, STDS={fc32=value}})\nend\n\nfunction waitSTCR(ldr,value)\n    -- See if Storage is in the expected state\n    local function checkDone(nid, status)\n        return status:data(\&#34;STUS\&#34;) == &#39;NONE&#39; and\n            status:data(\&#34;STCR\&#34;) == value\n    end\n\n    return waitOnActors(ldr, &#39;STCR&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone)\nend\n\nfunction getCMSnodeIDs(gndsAtomContainer)\n    if gndsAtomContainer == nil then\n\n        -- Don&#39;t core dump. Just return an empty CMS node ID list.\n        Debug.log(\&#34;warn\&#34;, \&#34;Error: gndsAtomContainer is nil.\&#34;)\n        return {}\n    end\n\n    local nids = gndsAtomContainer:data(\&#34;/GNID/AVAL\&#34;)\n    local types = gndsAtomContainer:data(\&#34;/GNTP/AVAL\&#34;)\n\n    if nids == nil or types == nil then\n        Debug.log(\&#34;warn\&#34;, \&#34;Error: Node ID and/or node type information missing from cached GNDS bundle.\&#34;)\n        return {}\n    end\n\n    local numNids = nids:length()\n    local numTypes = types:length()\n\n    if numNids ~= numTypes then\n        Debug.log(\&#34;warn\&#34;,\&#34;Error: Number of node IDs does not match number of node types.\&#34;)\n        return nil\n    end\n\n    local cmsids = {}\n\n    for num = 2,numNids do\n        local nid = gndsAtomContainer:data(\&#34;/GNID/AVAL\&#34;):data(num)\n        local typ = gndsAtomContainer:data(\&#34;/GNTP/AVAL\&#34;):data(num)\n\n        if typ == \&#34;BCMS\&#34; then\n            table.insert(cmsids, nid)\n        end\n    end\n\n    return cmsids\nend\n\nfunction elementInTable(element, table)\n    if element == nil or table == nil then\n        return false\n    end\n\n    for _,v in pairs(table) do\n        if v == element then\n            return true\n        end\n    end\n\n    return false\nend\n\nfunction cmsRemap(from, to, action, skipNode)\n    -- Called for both the LDR-remapping and CMS-remapping actions.\n    \n    local actPc = AtomContainer.new{&#39;AAPC&#39;, SNID = {ui32 = from} ,DNID = {ui32 = to} }\n\n    local cmsList = { }\n    local tmpList = coFindActors(&#39;BCMS&#39;)\n\n    local gndsAtomCont = Module.getatom():data(\&#34;/conf/GNDS\&#34;)\n\n    local gndsCMSids = getCMSnodeIDs(gndsAtomCont)\n\n    local seq = 1\n    for _,nid in pairs(tmpList) do\n        -- The now-revoked gtSourceCms node ID may still show up in the coFindActors query response, and must be filtered here.\n\n        if(nid ~= skipNode and elementInTable(nid, gndsCMSids)) then\n            cmsList[seq] = nid\n            seq = seq + 1\n        else\n            Debug.log(\&#34;note\&#34;,\&#34;Excluding NID \&#34;..skipNode..\&#34;from coFindActors() response\&#34;)\n        end\n    end\n\n    return executeOnActors(cmsList, action, actPc)\nend\n\nfunction revokeCert(nid)\n    return executeOnOneActor(&#39;BADC&#39;, &#39;CRVK&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}})\nend\n\nfunction removeEntity(oid)\n    return executeOnOneActor(&#39;BCMN&#39;, &#39;ANER&#39;, AtomContainer.new{&#39;AAPC&#39;, EOID = {cstr = oid}})\nend\n\nfunction setServiceState(nid, value)\n    return executeOnActors(nid, &#39;SVST&#39;, AtomContainer.new{&#39;AAPC&#39;, SVST={fc32=value}})\nend\n\nfunction setAuditState(nid, value)\n    return executeOnActors(nid, &#39;AUDT&#39;, AtomContainer.new{&#39;AAPC&#39;, AUDT={fc32=value}})\nend\n\nfunction waitAudit(nid, value)\n    local function checkDone(nid, status)\n        return status:data(\&#34;AQSZ\&#34;) == UINT64.new(0)\n    end\n    return waitOnActors(nid, &#39;AUDQ&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone)\nend\n\nfunction removeGrade(nid)\n    return executeOnOneActor(&#39;BCMN&#39;, &#39;USTG&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}})\nend\n\nfunction removeNode(nid, device)\n    return executeOnOneActor(&#39;BCMN&#39;, &#39;UNOD&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}, DTYP = {fc32 = device}})\nend\n\nfunction checkOnline(nid)\n    -- Uses the \&#34;Version Check\&#34; check to make sure that the target node is reachable. Doesn&#39;t care about the actual version.\n\n    local resp = postCheckAsk(nid, &#39;CSWV&#39;, AtomContainer.new{&#39;CHPC&#39;})\n\n    if(resp:data(&#39;/RSLT&#39;) == &#39;SUCS&#39;) then\n        return 1, \&#34;OK\&#34;\n    else\n        return 0, OID_GRIDTASK_MSG_CHECK_FAILED..\&#34; - \&#34;..OID_GRIDTASK_MSG_NID..\&#34; \&#34;..nid\n    end\n\nend\n\nfunction checkTargetExists(nid, dtype)\n    -- FIXME - This is inefficient; replace with a direct \&#34;certificate lookup\&#34; check once a proper Certificate grid service has been implemented.\n\n    exists = false\n\n    tmpList = coFindActors(dtype)\n\n    for _,foundnid in pairs(tmpList) do\n        if(nid == foundnid) then\n            exists = true\n        end\n    end\n\n    if(exists) then\n        return 1, \&#34;OK\&#34;\n    else\n        return 0, OID_GRIDTASK_MSG_NOID_NOT_FOUND..nid\n    end\nend\n\nfunction gtPrepare()\n    -- Called once, the first time that the task is run.\n\n    pushAbort(\&#34;taskFinished()\&#34;)\n\n    -- Make sure that DLDR and DCMS (if specified) exist in the grid. This is done before the topology lock\n    -- is acquired, so that it&#39;s still possible for the user to recover if he/she forgot to run the expansion tasks\n    -- before starting this Refresh task.\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_VERIFY_TARGETS_EXIST)\&#34;)\n\n    if (gtDestCms) then\n        addStage(\&#34;checkTargetExists(\&#34;..gtDestCms..\&#34;,&#39;BCMS&#39;)\&#34;)\n    end\n\n    if (gtDestLdr) then\n        addStage(\&#34;checkTargetExists(\&#34;..gtDestLdr..\&#34;,&#39;BLDR&#39;)\&#34;)\n    end\n\n    popAbort()  -- Abort not permitted during CMS migration\n\n    if gtSourceCms then\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n        addStage(\&#34;getLocks({[&#39;\&#34;..gtSourceCms..\&#34;-STORAGE&#39;] = true, [&#39;\&#34;..gtDestCms..\&#34;-STORAGE&#39;] = true, [&#39;BCMS-TOPOLOGY&#39;] = true, [&#39;CMS-REMAP&#39;] = true})\&#34;)\n        \n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)\&#34;)\n        addStage(\&#34;setServiceState(\&#34;..gtSourceCms..\&#34;, &#39;DABL&#39;)\&#34;)  -- Stop client services\n        addStage(\&#34;cmsRemap(\&#34;..gtSourceCms..\&#34;,\&#34;..gtDestCms..\&#34;, &#39;CRMP&#39;, gtDestCms)\&#34;)\n        addStage(\&#34;getLocks({[&#39;\&#34;..gtSourceCms..\&#34;-STORAGE&#39;] = true, [&#39;\&#34;..gtDestCms..\&#34;-STORAGE&#39;] = true, [&#39;BCMS-TOPOLOGY&#39;] = true})\&#34;)\n\n        -- Note - Audit is not flushed because database gets migrated to DestCMS. Expected that any queued audit\n        -- messages will be flushed by the new node, even if they were generated by the old node.\n\n        -- Pause the task and instruct the user to run the cms-refresh.sh script \n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CMS_MIGRATION)\&#34;)     \n        addStage(\&#34;waitUser(OID_GRIDTASK_MSG_CLONE_CMS_DB)\&#34;) \n        \n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_FINISH_CMS_MIGRATION)\&#34;)  \n        addStage(\&#34;checkOnline(\&#34;..gtDestCms..\&#34;)\&#34;)\n        addStage(\&#34;checkIfIdInGNDS(\&#34;..gtDestCms..\&#34;)\&#34;)\n\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n        addStage(\&#34;getLocks({[&#39;\&#34;..gtSourceCms..\&#34;-STORAGE&#39;] = true, [&#39;BCMS-TOPOLOGY&#39;] = true, [&#39;GRID-BUNDLE&#39;] = true})\&#34;)\n\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)\&#34;)\n        addStage(\&#34;revokeCert(\&#34;..gtSourceCms..\&#34;)\&#34;) -- Revoked here so that it is not targeted in the following cmsRemap action\n\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)\&#34;)\n        addStage(\&#34;removeNode(\&#34;..gtSourceCms..\&#34;, &#39;BCMS&#39;)\&#34;)\n    end\n\n    if gtSourceLdr then\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n        addStage(\&#34;getLocks({[&#39;\&#34;..gtSourceLdr..\&#34;-STORAGE&#39;] = true, [&#39;\&#34;..gtDestLdr..\&#34;-STORAGE&#39;] = true})\&#34;)\n\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STORAGE_STATE_WAIT)\&#34;)\n        addStage(\&#34;waitSTCR(\&#34;..gtDestLdr..\&#34;,&#39;READ&#39;)\&#34;)\n\n        pushAbort(\&#34;taskFinished()\&#34;)\n        pushAbort(\&#34;enableCLOCLOSTForwarding(\&#34;..gtDestLdr..\&#34;)\&#34;)\n        addStage(\&#34;disableCLOCLOSTForwarding(\&#34;..gtDestLdr..\&#34;)\&#34;)\n\n        addStage(\&#34;actionSMNT(\&#34;..gtSourceLdr..\&#34;,&#39;ENBL&#39;)\&#34;)\n\n        pushAbort(\&#34;getLocks({})\&#34;)\n        \n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CONTENT_MIGRATE)\&#34;)\n        pushAbort(\&#34;stopAction(\&#34;..gtSourceLdr..\&#34;,&#39;LMIG&#39;,gtActPc)\&#34;)\n        addStage(\&#34;startAction(\&#34;..gtSourceLdr..\&#34;,&#39;LMIG&#39;,gtActPc)\&#34;)\n        addStage(\&#34;waitDone(\&#34;..gtSourceLdr..\&#34;, &#39;LMIG&#39;, gtActPc)\&#34;)\n        addStage(\&#34;stopAction(\&#34;..gtSourceLdr..\&#34;,&#39;LMIG&#39;,gtActPc)\&#34;)\n\n        popAbort() -- remove locks\n        popAbort() -- enableCLOCLOSTForwarding\n        popAbort() -- abort not permitted beyond this point. \n\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n        addStage(\&#34;getLocks({[&#39;\&#34;..gtSourceLdr..\&#34;-STORAGE&#39;] = true, [&#39;\&#34;..gtDestLdr..\&#34;-STORAGE&#39;] = true, [&#39;BCMS-TOPOLOGY&#39;] = false, [&#39;CMS-REMAP&#39;] = true})\&#34;)\n\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CONTENT_REMAP)\&#34;)\n        addStage(\&#34;cmsRemap(\&#34;..gtSourceLdr..\&#34;,\&#34;..gtDestLdr..\&#34;, &#39;LRMP&#39;, gtSourceCms)\&#34;)\n        addStage(\&#34;getLocks({[&#39;\&#34;..gtSourceLdr..\&#34;-STORAGE&#39;] = true, [&#39;\&#34;..gtDestLdr..\&#34;-STORAGE&#39;] = true})\&#34;)\n\n        -- enableCLOCLOSTForwarding\n        addStage(\&#34;enableCLOCLOSTForwarding(\&#34;..gtDestLdr..\&#34;)\&#34;)\n\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)\&#34;)\n        addStage(\&#34;actionSTDS(\&#34;..gtDestLdr..\&#34;,&#39;RDWR&#39;)\&#34;)\n        addStage(\&#34;actionSTDS(\&#34;..gtSourceLdr..\&#34;,&#39;OFLN&#39;)\&#34;)\n    end\n\n    -- Using this way of creating a list of nodeTypes mapped to nodeIds and using ipairs() because unit tests expect ordering which\n    -- pairs() doesn&#39;t guarantee.\n    local ldrSource = {nt = &#39;BLDR&#39;, nid = gtSourceLdr}\n    local adcSource = {nt = &#39;BADC&#39;, nid = gtSourceAdc}\n    local ssmSource = {nt = &#39;BSSM&#39;, nid = gtSourceSsm}\n    local ddsSource = {nt = &#39;BDDS&#39;, nid = gtSourceDds}\n\n    local sourceNodes = {}\n\n    if(gtSourceLdr) then\n        table.insert(sourceNodes, ldrSource)\n    end\n    if(gtSourceAdc) then\n        table.insert(sourceNodes, adcSource)\n    end\n    if(gtSourceSsm) then\n        table.insert(sourceNodes, ssmSource)\n    end\n    if(gtSourceDds) then\n        table.insert(sourceNodes, ddsSource)\n    end\n\n    if (gtSourceDds) then\n        addStage(\&#34;stopAction(\&#34;..gtSourceDds..\&#34;, &#39;CCLE&#39;, AtomContainer.new{&#39;AAPC&#39;})\&#34;)\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n        addStage(\&#34;getLocks({[&#39;\&#34;..gtSourceDds..\&#34;-NODETOOL&#39;] = true, [&#39;NODETOOL_DECOMMISSION&#39;] = true})\&#34;)\n\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CASSANDRA_NODETOOL_DECOMMISSION)\&#34;)\n        addStage(\&#34;startAction(\&#34;..gtSourceDds..\&#34;, &#39;NDEC&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = \&#34;..gtSourceDds..\&#34;}})\&#34;)\n        addStage(\&#34;waitDone(\&#34;..gtSourceDds..\&#34;, &#39;NDEC&#39;, gtActPc)\&#34;)\n    end\n\n\n    local locks = \&#34;[&#39;GRID-BUNDLE&#39;] = true\&#34;\n    for _,data in ipairs(sourceNodes) do\n        locks = locks..\&#34;, [&#39;\&#34;..data[&#39;nt&#39;]..\&#34;-TOPOLOGY&#39;] = true\&#34;\n    end\n    if gtSourceLdr then\n        locks = locks..\&#34;, [&#39;\&#34;..gtSourceLdr..\&#34;-STORAGE&#39;] = true\&#34;\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n    addStage(\&#34;getLocks({\&#34;..locks..\&#34;})\&#34;)\n\n    for _,data in ipairs(sourceNodes) do\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)\&#34;)\n        addStage(\&#34;setServiceState(\&#34;..data[&#39;nid&#39;]..\&#34;, &#39;DABL&#39;)\&#34;)\n\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)\&#34;)\n        addStage(\&#34;setAuditState(\&#34;..data[&#39;nid&#39;]..\&#34;, &#39;DABL&#39;)\&#34;)\n        addStage(\&#34;waitAudit(\&#34;..data[&#39;nid&#39;]..\&#34;)\&#34;)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)\&#34;)\n    for _,data in ipairs(sourceNodes) do\n        addStage(\&#34;revokeCert(\&#34;..data[&#39;nid&#39;]..\&#34;)\&#34;)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)\&#34;)\n    addStage(\&#34;removeEntity(&#39;\&#34;..gtSourceOid..\&#34;&#39;)\&#34;)\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)\&#34;)\n\n    for _,data in ipairs(sourceNodes) do\n        addStage(\&#34;removeNode(\&#34;..data[&#39;nid&#39;]..\&#34;, &#39;\&#34;..data[&#39;nt&#39;]..\&#34;&#39;)\&#34;)\n    end\n\n    if gtSourceLdr then\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_GRADE_REMOVE)\&#34;)\n        addStage(\&#34;removeGrade(\&#34;..gtSourceLdr..\&#34;)\&#34;)\n    end\n\n    addStage(\&#34;getLocks({})\&#34;)\n\n    addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n    addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\n    -- Called every time that the task is run (first time, as well as after any CMN restart). \n\n    -- Depending on the node type, some of these may be null. \n    gtSourceLdr = taskParams:data(&#39;/SLDR&#39;)\n    gtDestLdr = taskParams:data(&#39;/DLDR&#39;)\n    gtSourceCms = taskParams:data(&#39;/SCMS&#39;)\n    gtDestCms = taskParams:data(&#39;/DCMS&#39;)\n\n    gtSourceAdc = taskParams:data(&#39;/SADC&#39;)  -- No \&#34;Dest\&#34; needed for ADC, SSM &amp; DDS; just decommission the Src nodes\n    gtSourceSsm = taskParams:data(&#39;/SSMN&#39;)\n    gtSourceDds = taskParams:data(&#39;/SDDS&#39;)\n\n    gtSourceOid = taskParams:data(&#39;/EOID&#39;)  -- OID for the server\n\n    if gtDestLdr then\n        gtActPc = AtomContainer.new{&#39;AAPC&#39;, DNID = {ui32 = gtDestLdr} }\n    end\nend\n"></atom>
			</container>
			<container name="CTNL">
				<atom name="0001" type="CSTR" value="-- Object Location Indexing Conversion Grid Task\n-- Version 1\n\nfunction abortCTNL()\n\x09-- Helper function to clean up a conversion task\n\x09local res,reas\n\n\x09Debug.log(\&#34;warn\&#34;,\&#34;Stopping CMS action\&#34;)\n\x09res,reas = stopAction(gtTargetCms,&#39;CNLT&#39;,gtActPc)\n\n\x09if(res ~= 1) then\n\x09\x09return 0,reas\n\x09else\n\x09\x09return 1,\&#34;OK\&#34;\n\x09end\nend\n\nfunction gtPrepare()\n\x09-- Called once, the first time that the task is run. \n\x09\n\x09pushAbort(\&#34;taskFinished()\&#34;)\n\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09pushAbort(\&#34;getLocks({})\&#34;)\n\x09addStage(\&#34;getLocks({[&#39;\&#34;..gtTargetCms..\&#34;-TASK-CTNL&#39;] = true})\&#34;)\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STARTING)\&#34;)\n\x09Debug.log(\&#34;info\&#34;, \&#34;NID = \&#34;, gtTargetCms)\n\x09\n\x09pushAbort(\&#34;abortCTNL()\&#34;)\n\x09addStage(\&#34;stopAction(\&#34;..gtTargetCms..\&#34;,&#39;CNLT&#39;,gtActPc)\&#34;)\n\x09\x09\n\x09addStage(\&#34;startAction(\&#34;..gtTargetCms..\&#34;,&#39;CNLT&#39;,gtActPc)\&#34;)\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_OBJECT_LOCATION_INDEXING_CONVERSION)\&#34;)\n\x09addStage(\&#34;waitDone(gtTargetCms, &#39;CNLT&#39;, gtActPc)\&#34;)\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_FINISHING)\&#34;)\n\x09addStage(\&#34;stopAction(\&#34;..gtTargetCms..\&#34;,&#39;CNLT&#39;,gtActPc)\&#34;)\n\x09\x09\n\x09addStage(\&#34;getLocks({})\&#34;)\n\x09popAbort() -- RLOK\n\x09\n\x09popAbort() -- abortCTNL()\n\x09\n\x09popAbort()\n\x09\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n\x09addStage(\&#34;taskFinished()\&#34;)\n\x09\n\x09-- FIXME - Save bundle to GTEN.\nend\n\x09\x09\x09\x09\nfunction gtInit()\n\x09-- Called every time that the task is run (first time, as well as after any CMN restart). \n\n\x09gtTargetCms = taskParams:data(&#39;/NOID&#39;)\n\x09\n\x09gtActPc = AtomContainer.new{&#39;AAPC&#39;}\nend\n"></atom>
			</container>
			<container name="CUPD">
				<atom name="0001" type="CSTR" value="-- Certificate Update Task\n-- Version 1\n\nfunction addCert(nid, certpath, adc)\n\x09local cert = taskParams:data(certpath)\n\x09\n\x09local action = AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}, CERT = {data = cert}}\n\n\x09if adc then\n\x09\x09return executeOnOneActor(&#39;BADC&#39;, &#39;CUPD&#39;, action)\n\x09else\n\x09\x09return executeOnActors(nid, &#39;CUPD&#39;, action)\n\x09end\nend\n\nfunction shutdownNode(nid)\n\x09return executeOnActors(nid, &#39;SHDN&#39;, AtomContainer.new{&#39;AAPC&#39;, DELY = {ui64 = 10000000}})\nend\n\nfunction gtPrepare()\n\x09pushAbort(\&#34;taskFinished()\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CERT_UPDATE)\&#34;)\n\x09\n\x09for node in taskParams:datas(\&#34;/NODS\&#34;) do\n\x09\x09local nid = node:data(\&#34;NOID\&#34;)\n\x09\x09local cert = \&#34;/NODS/\&#34;..node:name()..\&#34;/CERT\&#34;\n\x09\x09local mode = node:data(\&#34;MODE\&#34;) or \&#34;BOTH\&#34;\n\x09\x09\n\x09\x09if mode == \&#34;BOTH\&#34; then\n\x09\x09\x09-- Update cert on target node\n\x09\x09\x09addStage(\&#34;addCert(\&#34;..nid..\&#34;,&#39;\&#34;..cert..\&#34;&#39;)\&#34;)\n\x09\x09\x09\n\x09\x09\x09-- Shutdown (restart) target node\n\x09\x09\x09addStage(\&#34;shutdownNode(\&#34;..nid..\&#34;)\&#34;)\n\x09\x09end\n\x09\x09\n\x09\x09-- Update cert on ADC\n\x09\x09addStage(\&#34;addCert(\&#34;..nid..\&#34;,&#39;\&#34;..cert..\&#34;&#39;,true)\&#34;)\n\x09\x09\n\x09end\n\x09\n\x09--------------------------------------------------------------------------------\n\x09popAbort()\n\x09\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n\x09addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\nend\n"></atom>
			</container>
			<container name="EBUN">
				<atom name="0001" type="CSTR" value="-- Edit Bundles Task\n-- Version 1\n\nfunction editBundle(bundleNumber)\n\n\x09return executeOnOneActor(&#39;BCMN&#39;, &#39;EBUN&#39;,AtomContainer.new{&#39;AAPC&#39;, \n\x09EBUN = taskParams:data(\&#34;/EBUN/\&#34;..bundleNumber)} )\nend\n\nfunction gtPrepare()\n\n\x09pushAbort(\&#34;taskFinished()\&#34;)\n\n\x09-------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09pushAbort(\&#34;getLocks({})\&#34;)\n\x09addStage(\&#34;getLocks({[&#39;GRID-BUNDLE&#39;] = true})\&#34;)\n\x09\n\x09-------------------------------------------------------------------------\n\x09for bundle in taskParams:datas(\&#34;/EBUN\&#34;) do\n\x09\x09local bundleNumber = bundle:name()\n\x09\x09local bundleName = bundle:data(\&#34;/BLNM\&#34;)\n\x09\x09\n\x09\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_EDIT_BUNDLE..&#39;(\&#34;..bundleName..\&#34;)&#39;)\&#34;)\n\x09\x09addStage(\&#34;editBundle(&#39;\&#34;..bundleNumber..\&#34;&#39;)\&#34;)\n\n\x09end\n\x09-------------------------------------------------------------------------\n\x09addStage(\&#34;getLocks({})\&#34;)\n\x09popAbort() -- RLOK\n\x09\n\x09-------------------------------------------------------------------------\n\x09popAbort()\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n\x09addStage(\&#34;taskFinished()\&#34;)\n\x09\nend\n\n\nfunction gtInit()\nend\n"></atom>
			</container>
			<container name="ENRM">
				<atom name="0001" type="CSTR" value="-- Entity Remove Task\n-- Version 1\n\n\nfunction removeEntity(oid)\n\x09return executeOnOneActor(&#39;BCMN&#39;, &#39;ANER&#39;, AtomContainer.new{&#39;AAPC&#39;, EOID = {cstr = oid}})\nend\n\nfunction gtPrepare()\n\x09-- Called once, the first time that the task is run. \n\x09\n\x09pushAbort(\&#34;taskFinished()\&#34;)\n\x09\n\x09-----------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09pushAbort(\&#34;getLocks({})\&#34;)\n\x09addStage(\&#34;getLocks({[&#39;GRID-BUNDLE&#39;] = true})\&#34;)\n\n\x09-----------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)\&#34;)\n\n\x09for eoid in taskParams:datas(\&#34;/\&#34;) do\n\x09\x09addStage(\&#34;removeEntity(&#39;\&#34;..eoid..\&#34;&#39;)\&#34;)\n\x09end\n\n\x09-----------------------------------------------------------\n\x09addStage(\&#34;getLocks({})\&#34;)\n\x09popAbort() -- RLOK\n\x09popAbort()\n\x09\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n\x09addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\n\x09-- Called every time that the task is run (first time, as well as after any CMN restart). \n\x09\nend\n"></atom>
			</container>
			<container name="GDCM">
				<atom name="0001" type="CSTR" value="-- Generic Node Decommissioning/Refresh Task\n-- Version 1\n\n-- Currently supports the following node types: ADC, AMS, CLB, CMN, NMS, SSM\n-- TODO Support LDR, CMS, ARC\n\nfunction revokeCert(nid)\n   return executeOnOneActor(&#39;BADC&#39;, &#39;CRVK&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}})\nend\n\nfunction removeEntity(oid)\n   return executeOnOneActor(&#39;BCMN&#39;, &#39;ANER&#39;, AtomContainer.new{&#39;AAPC&#39;, EOID = {cstr = oid}})\nend\n\nfunction setServiceState(nid, value)\n   return executeOnActors(nid, &#39;SVST&#39;, AtomContainer.new{&#39;AAPC&#39;, SVST={fc32=value}})\nend\n\nfunction setAuditState(nid, value)\n   return executeOnActors(nid, &#39;AUDT&#39;, AtomContainer.new{&#39;AAPC&#39;, AUDT={fc32=value}})\nend\n\nfunction removeAuditRepo(nid)\n   -- Tell all relays to stop enqueueing messages for the specified repository\n   return executeOnActors(&#39;BADC&#39;, &#39;RMRP&#39;, AtomContainer.new{&#39;AAPC&#39;, REPO={ui32=nid}})\nend\n\nfunction waitAudit(nid, value)\n   local function checkDone(nid, status)\n      return status:data(\&#34;AQSZ\&#34;) == UINT64.new(0)\n   end\n   return waitOnActors(nid, &#39;AUDQ&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone)\nend\n\nfunction waitRelayFlush(nid)\n   local function checkDone(nid, status)\n      return status:data(\&#34;AQSZ\&#34;) == UINT64.new(0)\n   end\n   return waitOnActors(&#39;BADC&#39;, &#39;AURC&#39;, AtomContainer.new{&#39;CHPC&#39;, REPO={ui32=nid}}, checkDone)\nend\n\nfunction removeNode(nid, device)\n   return executeOnOneActor(&#39;BCMN&#39;, &#39;UNOD&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}, DTYP = {fc32 = device}})\nend\n\nfunction waitCmnStandby(nid)\n   -- Wait for CMN to be configured as standby\n   local function checkDone(nid, status)\n      return status:data(\&#34;CMNS\&#34;) == &#39;OFLN&#39;\n   end\n   return waitOnActors(nid, &#39;CMNS&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone)\nend\n\nfunction modifyBundle(bundleNumber)\n   return executeOnOneActor(&#39;BCMN&#39;, &#39;EBUN&#39;, AtomContainer.new{&#39;AAPC&#39;, EBUN = taskParams:data(\&#34;/EBUN/\&#34;..bundleNumber)} )\nend\n\nfunction deleteBundle(bundleNumber)\n   return executeOnOneActor(&#39;BCMN&#39;, &#39;DBUN&#39;, AtomContainer.new{&#39;AAPC&#39;, DBUN = taskParams:data(\&#34;/DBUN/\&#34;..bundleNumber)} )\nend\n\nfunction nodeId(node)\n   return node:data(\&#34;/NOID\&#34;)\nend\n\nfunction nodeOid(node)\n   return node:data(\&#34;/EOID\&#34;)\nend\n\nfunction deviceType(node)\n   return node:data(\&#34;/DTYP\&#34;)\nend\n\nfunction bundleToString(bundle)\n   return bundleName(bundle)..\&#34;.\&#34;..bundle:data(\&#34;/NMSP\&#34;)..\&#34;-\&#34;..bundle:data(\&#34;/NSIN\&#34;)\nend\n\nfunction bundleNumber(bundle)\n   return bundle:name()\nend\n\nfunction bundleName(bundle)\n   return bundle:data(\&#34;/BLNM\&#34;)\nend\n\nfunction gtPrepare()\n   pushAbort(\&#34;taskFinished()\&#34;)\n\n   --------------------------------------------------------------------------------\n   -- Check pre-conditions\n   --------------------------------------------------------------------------------\n\n   --------------------------------------------------------------------------------\n   for node in taskParams:datas(\&#34;/NODS\&#34;) do\n      local device = deviceType(node)\n      if device == \&#34;BCMN\&#34; then\n         addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CMN_STATE_WAIT)\&#34;)\n         addStage(\&#34;waitCmnStandby(\&#34;..nodeId(node)..\&#34;)\&#34;)\n      end\n   end\n\n   --------------------------------------------------------------------------------\n   -- Acquire an exclusive TOPOLOGY lock on every device type being decommissioned\n   local locks = \&#34;[&#39;GRID-BUNDLE&#39;] = true\&#34;\n   for node in taskParams:datas(\&#34;/NODS\&#34;) do\n      local device = deviceType(node)\n      if nodeId(node) then\n         locks = locks..\&#34;, [&#39;\&#34;..device..\&#34;-TOPOLOGY&#39;] = true\&#34;\n      end\n   end\n\n   addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n   pushAbort(\&#34;getLocks({})\&#34;)\n   addStage(\&#34;getLocks({\&#34;..locks..\&#34;})\&#34;)\n   popAbort() -- RLOK\n   popAbort() -- Cannot abort past this point\n\n   --------------------------------------------------------------------------------\n   -- If an AMS is decommissioned, all relay queues for it must be flushed before\n   -- its services are disabled.\n   --------------------------------------------------------------------------------\n   for node in taskParams:datas(\&#34;/NODS\&#34;) do\n      if deviceType(node) == &#39;BAMS&#39; then\n         -- NOTE - RMRP action will fail if there is not at least 1 remaining repository, but\n         -- if this happens here then topology locks will prevent the addition of another AMS.\n\n         addStage(\&#34;stageName(OID_GRIDTASK_STAGE_AUDIT_RELAY_FLUSH)\&#34;)\n         addStage(\&#34;removeAuditRepo(\&#34;..nodeId(node)..\&#34;)\&#34;)\n         addStage(\&#34;waitRelayFlush(\&#34;..nodeId(node)..\&#34;)\&#34;)\n      end\n   end\n\n   --------------------------------------------------------------------------------\n   -- Execute common decommissioning actions\n   --------------------------------------------------------------------------------\n\n   --------------------------------------------------------------------------------\n   addStage(\&#34;stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)\&#34;)\n   for node in taskParams:datas(\&#34;/NODS\&#34;) do\n      nid = nodeId(node)\n      if nid then\n         addStage(\&#34;setServiceState(\&#34;..nid..\&#34;, &#39;DABL&#39;)\&#34;)\n      end\n   end\n\n   --------------------------------------------------------------------------------\n   addStage(\&#34;stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)\&#34;)\n   for node in taskParams:datas(\&#34;/NODS\&#34;) do\n      -- TODO Support this action on the CMS\n      if deviceType(node) ~= &#39;BCMS&#39; then\n         nid = nodeId(node)\n         if nid then\n            addStage(\&#34;setAuditState(\&#34;..nid..\&#34;, &#39;DABL&#39;)\&#34;)\n            addStage(\&#34;waitAudit(\&#34;..nodeId(node)..\&#34;)\&#34;)\n         end\n      end\n   end\n\n   --------------------------------------------------------------------------------\n   addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)\&#34;)\n   for node in taskParams:datas(\&#34;/NODS\&#34;) do\n      nid = nodeId(node)\n      if nid then\n         addStage(\&#34;revokeCert(\&#34;..nid..\&#34;)\&#34;)\n      end\n   end\n\n   --------------------------------------------------------------------------------\n   addStage(\&#34;stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)\&#34;)\n   for node in taskParams:datas(\&#34;/NODS\&#34;) do\n      local oid = nodeOid(node)\n      if oid then  -- Is this ever not set?\n         addStage(\&#34;removeEntity(&#39;\&#34;..oid..\&#34;&#39;)\&#34;)\n      end\n   end\n\n   --------------------------------------------------------------------------------\n   addStage(\&#34;stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)\&#34;)\n   for node in taskParams:datas(\&#34;/NODS\&#34;) do\n      nid = nodeId(node)\n      if nid then\n         addStage(\&#34;removeNode(\&#34;..nid..\&#34;, &#39;\&#34;..deviceType(node)..\&#34;&#39;)\&#34;)\n      end\n   end\n\n   --------------------------------------------------------------------------------\n   -- Execute node-specific post-decommissioning actions\n   --------------------------------------------------------------------------------\n   for bundle in taskParams:datas(\&#34;/EBUN\&#34;) do\n      addStage(\&#34;stageName(OID_GRIDTASK_STAGE_BUNDLE_DELETEROWS..&#39;(\&#34;..bundleName(bundle)..\&#34;)&#39;)\&#34;)\n      addStage(\&#34;modifyBundle(&#39;\&#34;..bundleNumber(bundle)..\&#34;&#39;)\&#34;)\n   end\n\n   for bundle in taskParams:datas(\&#34;/DBUN\&#34;) do\n      addStage(\&#34;stageName(OID_GRIDTASK_STAGE_BUNDLE_DELETE..&#39;(\&#34;..bundleToString(bundle)..\&#34;)&#39;)\&#34;)\n      addStage(\&#34;deleteBundle(&#39;\&#34;..bundleNumber(bundle)..\&#34;&#39;)\&#34;)\n   end\n\n   --------------------------------------------------------------------------------\n   addStage(\&#34;getLocks({})\&#34;)\n   addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n   addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\nend\n"></atom>
			</container>
			<container name="GEXP">
				<atom name="0001" type="CSTR" value="-- Grid Expansion Task\n-- Version 1\n\nfunction addGroup(gid, siteName)\n    return executeOnOneActor(&#39;BCMN&#39;, &#39;RGRP&#39;,\n        AtomContainer.new{&#39;AAPC&#39;, GPID = {ui32 = gid}, GNAM = {cstr = siteName}})\nend\n\nfunction addEntity(path)\n    local eoid = taskParams:data(path..\&#34;/EOID\&#34;)\n    local eodm = taskParams:data(path..\&#34;/EODM\&#34;)\n    local eodv = taskParams:data(path..\&#34;/EODV\&#34;)\n    local eona = taskParams:data(path..\&#34;/EONA\&#34;)\n    local elng = taskParams:data(path..\&#34;/ELNG\&#34;)\n    local eosi = taskParams:data(path..\&#34;/EOSI\&#34;)\n    local eohn = taskParams:data(path..\&#34;/EOHN\&#34;)\n\n    return executeOnOneActor(&#39;BCMN&#39;, &#39;ANEA&#39;,\n        AtomContainer.new{&#39;AAPC&#39;, EOID = {cstr = eoid}, EODM = {cstr = eodm}, EODV = {cstr = eodv}, EONA = {ustr = eona}, ELNG = {enum = elng}, EOSI = {cstr = eosi}, EOHN = {cstr = eohn}})\nend\n\nfunction addCert(nid, certpath)\n    local cert = taskParams:data(certpath)\n\n    return executeOnOneActor(&#39;BADC&#39;, &#39;CUPD&#39;,\n        AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}, CERT = {data = cert}})\nend\n\nfunction addGrade(nid)\n    return executeOnOneActor(&#39;BCMN&#39;, &#39;RSTG&#39;,\n        AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}})\nend\n\nfunction addNmsCluster(ncid, path)\n    local name = taskParams:data(path..\&#34;/NMCN\&#34;)\n    return executeOnOneActor(&#39;BCMN&#39;, &#39;RNMS&#39;,\n        AtomContainer.new{&#39;AAPC&#39;, NMCI = {ui32 = ncid}, NMCN = {ustr = name}})\nend\n\nfunction addBundles(path)\n    local result = 1\n    local reason = OID_GRIDTASK_MSG_NONE\n\n    for data in taskParams:datas(path) do\n        data:set_name(&#39;AAPC&#39;)\n        result,reason = executeOnOneActor(&#39;BCMN&#39;, &#39;BDLI&#39;, data)\n        if(result ~= 1) then\n            Debug.log(\&#34;warn\&#34;,\&#34;Exiting bundle-import loop, reason =\&#34;,reason)\n            break\n        end\n    end\n\n    return result,reason\nend\n\nfunction modifyBundle(bundleNumber)\n\n    return executeOnOneActor(&#39;BCMN&#39;, &#39;EBUN&#39;,AtomContainer.new{&#39;AAPC&#39;,\n    EBUN = taskParams:data(\&#34;/EBUN/\&#34;..bundleNumber)} )\nend\n\nfunction gtPrepare()\n    --FIXME: is some kind of pre-check necessary?\n\n    pushAbort(\&#34;taskFinished()\&#34;)\n\n    --------------------------------------------------------------------------------\n    -- Acquire an exclusive TOPOLOGY lock on every device type being added\n    local locks = \&#34;[&#39;GRID-BUNDLE&#39;] = true\&#34;\n    for node in taskParams:datas(\&#34;/NODS\&#34;) do\n        local nid = node:data(\&#34;/NOID\&#34;)\n        local cert = node:data(\&#34;/CERT\&#34;)\n        local device = node:data(\&#34;/EODM\&#34;)\n\n        if nid and cert and device then\n            locks = locks..\&#34;, [&#39;\&#34;..device..\&#34;-TOPOLOGY&#39;] = true\&#34;\n        end\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n    pushAbort(\&#34;getLocks({})\&#34;)\n    addStage(\&#34;getLocks({\&#34;..locks..\&#34;})\&#34;)\n\n    --------------------------------------------------------------------------------\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_GROUP_ADD)\&#34;)\n\n\n\n    local numNewGroups = 0\n    newGroups = {}\n    for group in taskParams:datas(\&#34;/GRPS\&#34;) do\n        numNewGroups = numNewGroups + 1\n        newGroups[numNewGroups] = group\n    end\n\n    local numNewEoids = 0\n    entityIds = {}\n    for eoid in taskParams:datas(\&#34;/GEID\&#34;) do\n        numNewEoids = numNewEoids + 1\n        entityIds[numNewEoids] = eoid\n    end\n\n    for index=1,numNewGroups do\n        local group = newGroups[index]\n        local entityId = entityIds[index]\n\n        local siteName = \&#34;\&#34;\n        for node in taskParams:datas(\&#34;/NODS\&#34;) do\n            if entityId == node:data(\&#34;/EOID\&#34;) then\n                siteName = node:data(\&#34;/EONA\&#34;)\n                break\n            end\n        end\n\n        addStage(\&#34;addGroup(\&#34;..group..\&#34;,&#39;\&#34;..siteName..\&#34;&#39;)\&#34;)\n    end\n\n    --------------------------------------------------------------------------------\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_ENTITY_ADD)\&#34;)\n\n    for node in taskParams:datas(\&#34;/NODS\&#34;) do\n        addStage(\&#34;addEntity(&#39;/NODS/\&#34;..node:name()..\&#34;&#39;)\&#34;)\n    end\n\n    --------------------------------------------------------------------------------\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CERT_UPDATE)\&#34;)\n    -- FIXME? - Could interleave the certs with the NENT updates.\n\n    for node in taskParams:datas(\&#34;/NODS\&#34;) do\n        local nid = node:data(\&#34;/NOID\&#34;)\n        local cert = node:data(\&#34;/CERT\&#34;)\n\n        if nid and cert then\n            addStage(\&#34;addCert(\&#34;..nid..\&#34;,&#39;/NODS/\&#34;..node:name()..\&#34;/CERT&#39;)\&#34;)\n        end\n    end\n\n    --------------------------------------------------------------------------------\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_GRADE_ADD)\&#34;)\n\n    for node in taskParams:datas(\&#34;/NODS\&#34;) do\n        -- FIXME Pass an explicit \&#34;device type\&#34; field (or look in cert)?\n        local nid = node:data(\&#34;/NOID\&#34;)\n        local device = node:data(\&#34;/EODM\&#34;)\n        if nid and device == \&#34;BLDR\&#34; then\n            addStage(\&#34;addGrade(\&#34;..nid..\&#34;)\&#34;)\n        end\n    end\n\n    --------------------------------------------------------------------------------\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_NMS_CLUSTER_ADD)\&#34;)\n\n    for node in taskParams:datas(\&#34;/NODS\&#34;) do\n        local nid = node:data(\&#34;/NOID\&#34;)\n        local device = node:data(\&#34;/EODM\&#34;)\n        local ncid = node:data(\&#34;/NMCI\&#34;)\n\n        if nid and device == \&#34;BNMS\&#34; and ncid then\n            addStage(\&#34;addNmsCluster(\&#34;..ncid..\&#34;,&#39;/NODS/\&#34;..node:name()..\&#34;&#39;)\&#34;)\n        end\n    end\n\n    --------------------------------------------------------------------------------\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_BUNDLE_IMPORT)\&#34;)\n    addStage(\&#34;addBundles(&#39;/BDLS&#39;)\&#34;)\n\n    --------------------------------------------------------------------------------\n    for bundle in taskParams:datas(\&#34;/EBUN\&#34;) do\n        local bundleNumber = bundle:name()\n        local bundleName = bundle:data(\&#34;/BLNM\&#34;)\n\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_BUNDLE_ADDROWS..&#39;(\&#34;..bundleName..\&#34;)&#39;)\&#34;)\n        addStage(\&#34;modifyBundle(&#39;\&#34;..bundleNumber..\&#34;&#39;)\&#34;)\n    end\n\n    --------------------------------------------------------------------------------\n    addStage(\&#34;getLocks({})\&#34;)\n    popAbort() -- RLOK\n\n    --------------------------------------------------------------------------------\n    popAbort()\n\n    addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n    addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\nend\n"></atom>
			</container>
			<container name="ILME">
				<atom name="0001" type="CSTR" value="-- ILM Evaluation Task\n-- Version 1\n\n\nfunction abortILME()\n    -- Helper function to clean up a verification task\n    local res,reas\n\n    Debug.log(\&#34;warn\&#34;,\&#34;Stopping DDS actions\&#34;)\n    for _,nid in pairs(cmnList) do\n\n        res,reas = stopAction(nid,&#39;ILME&#39;,gtActPc)\n        if(res ~= 1) then\n            return 0,reas\n        end\n    end\n\n    if (res ~= 1) then\n        return 0,reas\n    else\n        return 1,\&#34;OK\&#34;\n    end\nend\n\nfunction gtPrepare()\n    -- Called once, the first time that the task is run.\n    pushAbort(\&#34;taskFinished()\&#34;)\n\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n    pushAbort(\&#34;getLocks({})\&#34;)\n    addStage(\&#34;getLocks({[&#39;GRID-ILM&#39;] = true})\&#34;)\n\n    pushAbort(\&#34;abortILME()\&#34;)\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STARTING)\&#34;)\n\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\&#34;startAction(\&#34;..targetCMN..\&#34;,&#39;ILME&#39;,gtActPc)\&#34;)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_ILM_EVALUATE)\&#34;)\n    addStage(\&#34;waitDone(cmnList, &#39;ILME&#39;, gtActPc)\&#34;)\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_FINISHING)\&#34;)\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\&#34;stopAction(\&#34;..targetCMN..\&#34;,&#39;ILME&#39;,gtActPc)\&#34;)\n    end\n\n    addStage(\&#34;getLocks({})\&#34;)\n    popAbort() -- RLOK\n\n    popAbort() -- abortILME()\n\n    popAbort()\n\n    addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n    addStage(\&#34;taskFinished()\&#34;)\n\n    -- FIXME - Save bundle to GTEN.\nend\n\nfunction gtInit()\n    -- Called every time that the task is run (first time, as well as after any CMN restart).\n\n    gtActPc = AtomContainer.new{&#39;AAPC&#39;}\n    gtActPc:set(\&#34;/\&#34;, taskParams)\n    cmnList = actorsToList(&#39;BCMN&#39;, true)\nend\n"></atom>
			</container>
			<container name="LCCN">
				<atom name="0001" type="CSTR" value="-- Legacy CBID Continuation Task\n-- Version 1\n\nfunction waitLegacyCBID()\n\x09local function checkDone(nid, status)\n\x09\x09return status:data(\&#34;LCSC\&#34;) == &#39;NFND&#39;,\n\x09\x09\x09status:data(\&#34;PCPN\&#34;),\n\x09\x09\x09status:data(\&#34;PCPD\&#34;)\n\x09end\n\x09\n\x09return waitOnActors(&#39;BCMS&#39;, &#39;LCSC&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone)\nend\n\nfunction gtPrepare()\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LEGACY_CBID)\&#34;)\n\x09addStage(\&#34;waitLegacyCBID()\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n\x09addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\nend\n"></atom>
			</container>
			<container name="LDCM">
				<atom name="0001" type="CSTR" value="-- StorageNODE Decommissioning Task\n\nfunction actionSMNT(ldr,value)\n    return executeOnActors(ldr, &#39;SMNT&#39;, AtomContainer.new{&#39;AAPC&#39;, SMNT={fc32=value}})\nend\n\nfunction actionSTDS(ldr,value)\n    return executeOnActors(ldr, &#39;STDS&#39;, AtomContainer.new{&#39;AAPC&#39;, STDS={fc32=value}})\nend\n\nfunction revokeCert(nid)\n--  return executeOnOneActor(&#39;BADC&#39;, &#39;ADBP&#39;, AtomContainer.new{&#39;AAPC&#39;, DLVL = &#39;NOTE&#39;, DSTR = \&#34;Revoking cert for \&#34;..nid})\n    return executeOnOneActor(&#39;BADC&#39;, &#39;CRVK&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}})\nend\n\nfunction removeEntity(nid)\n    return executeOnOneActor(&#39;BCMN&#39;, &#39;ANER&#39;, AtomContainer.new{&#39;AAPC&#39;, EOID = {cstr = nid}})\nend\n\nfunction setServiceState(nid, value)\n    return executeOnActors(nid, &#39;SVST&#39;, AtomContainer.new{&#39;AAPC&#39;, SVST={fc32=value}})\nend\n\nfunction setAuditState(nid, value)\n    return executeOnActors(nid, &#39;AUDT&#39;, AtomContainer.new{&#39;AAPC&#39;, AUDT={fc32=value}})\nend\n\nfunction waitAudit(nid, value)\n    local function checkDone(nid, status)\n        return status:data(\&#34;AQSZ\&#34;) == UINT64.new(0)\n    end\n    return waitOnActors(nid, &#39;AUDQ&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone)\nend\n\nfunction removeGrade(nid)\n    return executeOnOneActor(&#39;BCMN&#39;, &#39;USTG&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}})\nend\n\nfunction removeNode(nid, device)\n    return executeOnOneActor(&#39;BCMN&#39;, &#39;UNOD&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}, DTYP = {fc32 = device}})\nend\n\nfunction markingLdrDecommissioning(nid)\n    return executeOnOneActor(&#39;BDDS&#39;, &#39;LMDC&#39;, AtomContainer.new{&#39;AAPC&#39;, NODE={ui32=nid}})\nend\n\nfunction filterDdsList(nid)\n    for i=#ddsListReMap,1,-1 do\n        if (nid == ddsListReMap[i]) then\n            table.remove(ddsListReMap, i)\n        end\n    end\nend\n\nfunction filterCmsList(nid)\n    for i=#cmsList,1,-1 do\n        if (nid == cmsList[i]) then\n            table.remove(cmsList, i)\n        end\n    end\nend\n\nfunction setOwnerMapping(onid, nnid)\n    return executeOnOneActor(&#39;BDDS&#39;, &#39;COWR&#39;, AtomContainer.new{&#39;AAPC&#39;, NIDS={ui32=onid},  NIDD={ui32=nnid}})\nend\n\nfunction gtPrepare()\n    -- Called once, the first time that the task is run.\n\n    pushAbort(\&#34;taskFinished()\&#34;)\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n    pushAbort(\&#34;getLocks({})\&#34;)\n\n    for oldLdr in taskParams:datas(&#39;/SLDR&#39;) do\n        addStage(\&#34;getLocks({[&#39;\&#34;..oldLdr..\&#34;-STORAGE&#39;] = true})\&#34;)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STARTING)\&#34;)\n\n    for oldLdr in taskParams:datas(&#39;/SLDR&#39;) do\n        pushAbort(\&#34;actionSMNT(\&#34;..oldLdr..\&#34;,&#39;DABL&#39;)\&#34;)\n        addStage(\&#34;actionSMNT(\&#34;..oldLdr..\&#34;,&#39;ENBL&#39;)\&#34;)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STARTING)\&#34;)\n\n    -- Using this way of creating a list of nodeTypes mapped to nodeIds and using ipairs() because unit tests expect ordering which\n    -- pairs() doesn&#39;t guarantee.\n    local sourceNodes = {}\n\n    for oldLdr in taskParams:datas(&#39;/SLDR&#39;) do\n        popAbort()  -- actionSMNT\n    end\n    popAbort() -- RLOK\n    popAbort()  -- Empty the stack; cannot abort beyond this point\n\n    -- from here,can not roll back\n    addStage(\&#34;getLocks({[&#39;GRID-ILM&#39;] = true})\&#34;)\n\n    for oldLdr in taskParams:datas(&#39;/SLDR&#39;) do\n        addStage(\&#34;markingLdrDecommissioning(\&#34;..oldLdr..\&#34;)\&#34;)\n    end\n\n    -- EC Decommissioning start.\n\n    Debug.log(\&#34;info\&#34;,\&#34;Starting EC decommissioning.\&#34;)\n    -- Start on one CMN?\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\&#34;startAction(\&#34;..targetCMN..\&#34;, &#39;ECND&#39;, ecdcParams)\&#34;)\n    end\n    Debug.log(\&#34;info\&#34;,\&#34;Started EC decommissioning actions.\&#34;)\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_EC_DECOMMISSIONING)\&#34;)\n    addStage(\&#34;waitDone(cmnList, &#39;ECND&#39;, ecdcParams)\&#34;)\n\n    Debug.log(\&#34;info\&#34;,\&#34;EC decommissioning action done.\&#34;)\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_FINISHING)\&#34;)\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\&#34;stopAction(\&#34;..targetCMN..\&#34;, &#39;ECND&#39;, ecdcParams)\&#34;)\n    end\n    Debug.log(\&#34;info\&#34;,\&#34;Finished EC decommissioning.\&#34;)\n\n    -- EC Decommissioning end.\n\n    -- FIXME? This seems wrong; we should only start a single ILM re-evaluation, even if we actually has multiple CMNs\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\&#34;startAction(\&#34;..targetCMN..\&#34;, &#39;ILME&#39;, ilmeParams)\&#34;)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_ILM_EVALUATE)\&#34;)\n    addStage(\&#34;waitDone(cmnList, &#39;ILME&#39;, ilmeParams)\&#34;)\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_FINISHING)\&#34;)\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\&#34;stopAction(\&#34;..targetCMN..\&#34;, &#39;ILME&#39;, ilmeParams)\&#34;)\n    end\n\n    for oldCms in taskParams:datas(\&#34;/SCMS\&#34;) do\n        local cmsSource = {nt = &#39;BCMS&#39;, nid = oldCms}\n        table.insert(sourceNodes, cmsSource)\n        filterCmsList(oldCms)\n    end\n\n    if(table.getn(cmsList) &gt; 0) then\n        for oldCms in taskParams:datas(&#39;/SCMS&#39;) do\n            local newCms = cmsList[ math.random(table.getn(cmsList)) ]\n            addStage(\&#34;setOwnerMapping(\&#34;..oldCms..\&#34;, \&#34;..newCms..\&#34; )\&#34;)\n        end\n    else\n        Debug.log(\&#34;err\&#34;,\&#34;NodeId mapping failed. No running CMS\&#34;)\n    end\n\n    for oldDds in taskParams:datas(&#39;/SDDS&#39;) do\n        filterDdsList(oldDds)\n    end\n\n    if(table.getn(ddsListReMap) &gt; 0) then\n        for oldDds in taskParams:datas(&#39;/SDDS&#39;) do\n            local newDds = ddsListReMap[ math.random(table.getn(ddsListReMap)) ]\n            addStage(\&#34;setOwnerMapping(\&#34;..oldDds..\&#34;, \&#34;..newDds..\&#34; )\&#34;)\n        end\n    else\n        Debug.log(\&#34;err\&#34;,\&#34;NodeId mapping failed. No running DDS\&#34;)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)\&#34;)\n    for oldLdr in taskParams:datas(&#39;/SLDR&#39;) do\n        addStage(\&#34;actionSTDS(\&#34;..oldLdr..\&#34;,&#39;OFLN&#39;)\&#34;)\n        local ldrSource = {nt = &#39;BLDR&#39;, nid = oldLdr}\n        table.insert(sourceNodes, ldrSource)\n    end\n\n    for oldSsm in taskParams:datas(&#39;/SSSM&#39;) do\n        local ssmSource = {nt = &#39;BSSM&#39;, nid = oldSsm}\n        table.insert(sourceNodes, ssmSource)\n    end\n\n    for oldAdc in taskParams:datas(&#39;/SADC&#39;) do\n        local adcSource = {nt = &#39;BADC&#39;, nid = oldAdc}\n        table.insert(sourceNodes, adcSource)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CASSANDRA_NODETOOL_DECOMMISSION)\&#34;)\n    for oldDds in taskParams:datas(&#39;/SDDS&#39;) do\n        local ddsSource = {nt = &#39;BDDS&#39;, nid = oldDds}\n        table.insert(sourceNodes, ddsSource)\n        addStage(\&#34;stopAction(\&#34;..oldDds..\&#34;, &#39;CCLE&#39;, AtomContainer.new{&#39;AAPC&#39;})\&#34;)\n        addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n        addStage(\&#34;getLocks({[&#39;\&#34;..oldDds..\&#34;-NODETOOL&#39;] = true, [&#39;NODETOOL_DECOMMISSION&#39;] = true})\&#34;)\n        addStage(\&#34;startAction(\&#34;..oldDds..\&#34;, &#39;NDEC&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = \&#34;..oldDds..\&#34;}})\&#34;)\n        addStage(\&#34;waitDone(\&#34;..oldDds..\&#34;, &#39;NDEC&#39;, gtActPc)\&#34;)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_FINISHING)\&#34;)\n    for oldDds in taskParams:datas(&#39;/SDDS&#39;) do\n        addStage(\&#34;stopAction(\&#34;..oldDds..\&#34;, &#39;NDEC&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = \&#34;..oldDds..\&#34;}})\&#34;)\n    end\n\n    local locks = \&#34;[&#39;GRID-BUNDLE&#39;] = true\&#34;\n    for _, data in ipairs(sourceNodes) do\n        locks = locks..\&#34;, [&#39;\&#34;..data[&#39;nt&#39;]..\&#34;-TOPOLOGY&#39;] = true\&#34;\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n    addStage(\&#34;getLocks({\&#34;..locks..\&#34;})\&#34;)\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)\&#34;)\n    for _, data in ipairs(sourceNodes) do\n        addStage(\&#34;setServiceState(\&#34;..data[&#39;nid&#39;]..\&#34;, &#39;DABL&#39;)\&#34;)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)\&#34;)\n    for _, data in ipairs(sourceNodes) do\n        -- TODO: CMS doesn&#39;t support these actions/checks yet.\n        --       Uncomment when story B-25861 is implemented.\n        if (data[&#39;nt&#39;] ~= &#39;BCMS&#39;) then\n            addStage(\&#34;setAuditState(\&#34;..data[&#39;nid&#39;]..\&#34;, &#39;DABL&#39;)\&#34;)\n            addStage(\&#34;waitAudit(\&#34;..data[&#39;nid&#39;]..\&#34;)\&#34;)\n        end\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)\&#34;)\n    for _, data in ipairs(sourceNodes) do\n        addStage(\&#34;revokeCert(\&#34;..data[&#39;nid&#39;]..\&#34;)\&#34;)\n    end\n\n    for eoid in taskParams:datas(&#39;/EOID&#39;) do\n        addStage(\&#34;removeEntity(&#39;\&#34;..eoid..\&#34;&#39;)\&#34;)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)\&#34;)\n    for _, data in ipairs(sourceNodes) do\n        addStage(\&#34;removeNode(\&#34;..data[&#39;nid&#39;]..\&#34;, &#39;\&#34;..data[&#39;nt&#39;]..\&#34;&#39;)\&#34;)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_GRADE_REMOVE)\&#34;)\n    for oldLdr in taskParams:datas(&#39;/SLDR&#39;) do\n        addStage(\&#34;removeGrade(\&#34;..oldLdr..\&#34;)\&#34;)\n    end\n\n    addStage(\&#34;getLocks({})\&#34;)\n\n    addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n    addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\n    -- Called every time that the task is run (first time, as well as after any CMN restart).\n\n    cmnList = actorsToList(&#39;BCMN&#39;)\n    cmsList = actorsToList(&#39;BCMS&#39;, true)\n    ddsList = actorsToList(&#39;BDDS&#39;, true)\n    ddsListReMap = ddsList\n\n    gtActPc = AtomContainer.new{&#39;AAPC&#39;}\n\n    -- Add ILM re-evaluation filters for all the LDRs being decommissioned\n    ilmeParams = AtomContainer.new{&#39;AAPC&#39;}\n    local index = 1\n    for oldLdr in taskParams:datas(&#39;/SLDR&#39;) do\n        local filt = AtomContainer.new{&#39;FILT&#39;, NOID={ui32=oldLdr}}\n        ilmeParams:set_cont(index, filt)\n        index = index + 1\n    end\n\n    -- Setup EC decommissioning parameters.\n    --  Pass the taskId as part of the parameters.\n    ecdcParams = AtomContainer.new{&#39;AAPC&#39;, TKID={ui32=taskId}}\n    local nodes = AtomContainer.new{&#39;NODE&#39;}\n    local i = 1\n    for oldLdr in taskParams:datas(&#39;/SLDR&#39;) do\n        local path = string.format(\&#34;%04X\&#34;, i)\n        nodes:set_ui32(path, oldLdr)\n        i = i + 1\n    end\n    ecdcParams:set_cont(&#39;NODE&#39;, nodes)\nend\n"></atom>
			</container>
			<container name="LMIG">
				<atom name="0001" type="CSTR" value="-- LDR Directed Decomissioning (Hardware Refresh) Task\n-- Version 1\n\nfunction actionSMNT(ldr,value)\n\x09return executeOnActors(ldr, &#39;SMNT&#39;, AtomContainer.new{&#39;AAPC&#39;, SMNT={fc32=value}})\nend\n\nfunction actionCLDQ(ldr,value)\n\x09return executeOnActors(ldr, &#39;CLDQ&#39;, AtomContainer.new{&#39;AAPC&#39;, FRWD={fc32=value}})\nend\n\nfunction disableCLOCLOSTForwarding(ldr)\n\x09return actionCLDQ(ldr, &#39;DABL&#39;)\nend\n\nfunction enableCLOCLOSTForwarding(ldr)\n\x09return actionCLDQ(ldr, &#39;ENBL&#39;)\nend\n\nfunction actionSTDS(ldr,value)\n\x09return executeOnActors(ldr, &#39;STDS&#39;, AtomContainer.new{&#39;AAPC&#39;, STDS={fc32=value}})\nend\n\nfunction waitSTCR(ldr,value)\n\x09-- See if Storage is in the expected state\n\x09local function checkDone(nid, status)\n\x09\x09return status:data(\&#34;STUS\&#34;) == &#39;NONE&#39; and\n\x09\x09\x09status:data(\&#34;STCR\&#34;) == value\n\x09end\n\x09\n\x09return waitOnActors(ldr, &#39;STCR&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone)\nend\n\nfunction cmsRemap(from, to)\n\x09local actPc = AtomContainer.new{&#39;AAPC&#39;, SNID = {ui32 = gtSourceLdr} ,DNID = {ui32 = gtDestLdr} }\n\n\x09return executeOnActors(gtCmsList, &#39;LRMP&#39;, actPc)\nend\n\nfunction revokeCert(nid)\n--\x09return executeOnOneActor(&#39;BADC&#39;, &#39;ADBP&#39;, AtomContainer.new{&#39;AAPC&#39;, DLVL = &#39;NOTE&#39;, DSTR = \&#34;Revoking cert for \&#34;..nid})\n\x09return executeOnOneActor(&#39;BADC&#39;, &#39;CRVK&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}})\nend\n\nfunction removeEntity(oid)\n\x09return executeOnOneActor(&#39;BCMN&#39;, &#39;ANER&#39;, AtomContainer.new{&#39;AAPC&#39;, EOID = {cstr = oid}})\nend\n\nfunction setServiceState(nid, value)\n\x09return executeOnActors(nid, &#39;SVST&#39;, AtomContainer.new{&#39;AAPC&#39;, SVST={fc32=value}})\nend\n\nfunction setAuditState(nid, value)\n\x09return executeOnActors(nid, &#39;AUDT&#39;, AtomContainer.new{&#39;AAPC&#39;, AUDT={fc32=value}})\nend\n\nfunction waitAudit(nid, value)\n\x09local function checkDone(nid, status)\n\x09\x09return status:data(\&#34;AQSZ\&#34;) == UINT64.new(0)\n\x09end\n\x09return waitOnActors(nid, &#39;AUDQ&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone)\nend\n\nfunction removeGrade(nid)\n\x09return executeOnOneActor(&#39;BCMN&#39;, &#39;USTG&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}})\nend\n\nfunction removeNode(nid, device)\n\x09return executeOnOneActor(&#39;BCMN&#39;, &#39;UNOD&#39;, AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = nid}, DTYP = {fc32 = device}})\nend\n\nfunction gtPrepare()\n\x09-- Called once, the first time that the task is run. \n\n\x09pushAbort(\&#34;taskFinished()\&#34;)\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09pushAbort(\&#34;getLocks({})\&#34;)\n\x09addStage(\&#34;getLocks({[&#39;\&#34;..gtSourceLdr..\&#34;-STORAGE&#39;] = true, [&#39;\&#34;..gtDestLdr..\&#34;-STORAGE&#39;] = true, [&#39;BCMS-TOPOLOGY&#39;] = false})\&#34;)\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)\&#34;)\n\x09addStage(\&#34;waitSTCR(\&#34;..gtDestLdr..\&#34;,&#39;READ&#39;)\&#34;)\n\n        pushAbort(\&#34;enableCLOCLOSTForwarding(\&#34;..gtDestLdr..\&#34;)\&#34;)\n        addStage(\&#34;disableCLOCLOSTForwarding(\&#34;..gtDestLdr..\&#34;)\&#34;)\n\n\x09pushAbort(\&#34;actionSMNT(\&#34;..gtSourceLdr..\&#34;,&#39;DABL&#39;)\&#34;)\n\x09addStage(\&#34;actionSMNT(\&#34;..gtSourceLdr..\&#34;,&#39;ENBL&#39;)\&#34;)\n\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CONTENT_MIGRATE)\&#34;)\n\x09pushAbort(\&#34;stopAction(\&#34;..gtSourceLdr..\&#34;,&#39;LMIG&#39;,gtActPc)\&#34;)\n\x09addStage(\&#34;startAction(\&#34;..gtSourceLdr..\&#34;,&#39;LMIG&#39;,gtActPc)\&#34;)\n\x09addStage(\&#34;waitDone(\&#34;..gtSourceLdr..\&#34;, &#39;LMIG&#39;, gtActPc)\&#34;)\n\x09addStage(\&#34;stopAction(\&#34;..gtSourceLdr..\&#34;,&#39;LMIG&#39;,gtActPc)\&#34;)\n\n\x09popAbort()\x09-- stopAction\n\x09popAbort()\x09-- actionSMNT\n\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CONTENT_REMAP)\&#34;)\n\x09addStage(\&#34;cmsRemap(\&#34;..gtSourceLdr..\&#34;,\&#34;..gtDestLdr..\&#34;)\&#34;)\n\n        popAbort()      -- enableCLOCLOSTForwarding\n        addStage(\&#34;enableCLOCLOSTForwarding(\&#34;..gtDestLdr..\&#34;)\&#34;)\n\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STORAGE_STATE)\&#34;)\n\x09addStage(\&#34;actionSTDS(\&#34;..gtDestLdr..\&#34;,&#39;RDWR&#39;)\&#34;)\n\x09addStage(\&#34;actionSTDS(\&#34;..gtSourceLdr..\&#34;,&#39;OFLN&#39;)\&#34;)\n\x09\n\x09local sourceNodes = {BLDR = gtSourceLdr, BSSM = gtSourceSsm}\n\x09local locks = \&#34;[&#39;GRID-BUNDLE&#39;] = true, [&#39;\&#34;..gtSourceLdr..\&#34;-STORAGE&#39;] = true\&#34;\n\x09for nodeType, nid in pairs(sourceNodes) do\n\x09\x09locks = locks..\&#34;, [&#39;\&#34;..nodeType..\&#34;-TOPOLOGY&#39;] = true\&#34;\n\x09end\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09addStage(\&#34;getLocks({\&#34;..locks..\&#34;})\&#34;)\n\x09popAbort() -- RLOK\n\x09\n\x09popAbort()\x09-- Empty the stack; cannot abort beyond this point\n\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_SERVICE_DISABLE)\&#34;)\n\x09for nodeType, nid in pairs(sourceNodes) do\n\x09\x09addStage(\&#34;setServiceState(\&#34;..nid..\&#34;, &#39;DABL&#39;)\&#34;)\n\x09end\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_AUDIT_FLUSH)\&#34;)\n\x09for nodeType, nid in pairs(sourceNodes) do\n\x09\x09addStage(\&#34;setAuditState(\&#34;..nid..\&#34;, &#39;DABL&#39;)\&#34;)\n\x09\x09addStage(\&#34;waitAudit(\&#34;..nid..\&#34;)\&#34;)\n\x09end\n\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_CERT_REVOKE)\&#34;)\n\x09for nodeType, nid in pairs(sourceNodes) do\n\x09\x09addStage(\&#34;revokeCert(\&#34;..nid..\&#34;)\&#34;)\n\x09end\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_ENTITY_REMOVE)\&#34;)\n\x09addStage(\&#34;removeEntity(&#39;\&#34;..gtSourceLdrOid..\&#34;&#39;)\&#34;)\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_NODE_REMOVE)\&#34;)\n\x09for nodeType, nid in pairs(sourceNodes) do\n\x09\x09addStage(\&#34;removeNode(\&#34;..nid..\&#34;, &#39;\&#34;..nodeType..\&#34;&#39;)\&#34;)\n\x09end\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_GRADE_REMOVE)\&#34;)\n\x09addStage(\&#34;removeGrade(\&#34;..gtSourceLdr..\&#34;)\&#34;)\n\x09\n\x09addStage(\&#34;getLocks({})\&#34;)\n\x09\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n    addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\n\x09-- Called every time that the task is run (first time, as well as after any CMN restart). \n\n\x09gtSourceLdr = taskParams:data(&#39;/SNID&#39;)\n\x09gtDestLdr = taskParams:data(&#39;/DNID&#39;)\n\x09gtSourceSsm = taskParams:data(&#39;/SSMN&#39;)\n\x09\n\x09gtSourceLdrOid = taskParams:data(&#39;/EOID&#39;)\n\n\x09gtCmsList = cacheLoadList(&#39;CMSL&#39;)\n\x09\n\x09if(gtCmsList == nil) then\n\x09\x09gtCmsList  = coFindActors(&#39;BCMS&#39;)\n\x09\x09cacheStoreList(&#39;CMSL&#39;,gtCmsList)\n\x09end\n\x09\n\x09gtActPc = AtomContainer.new{&#39;AAPC&#39;, DNID = {ui32 = gtDestLdr} }\nend\n"></atom>
			</container>
			<container name="LOCO">
				<atom name="0001" type="CSTR" value="-- Verify Locations\n-- Version 1\n\n\nfunction abortMVFY()\n\x09local res,reas\n\n\x09Debug.log(\&#34;warn\&#34;,\&#34;Stopping CMS actions\&#34;)\n\x09for _,nid in pairs(cmsList) do\n\x09\x09res,reas = stopAction(nid,&#39;MVFY&#39;,gtActPc)\n\x09\x09if(res ~= 1) then\n\x09\x09\x09return 0,reas\n\x09\x09end\n\x09end\n\n\x09if (res ~= 1) then\n\x09\x09return 0,reas\n\x09else\n\x09\x09return 1,\&#34;OK\&#34;\n\x09end\nend\n\nfunction gtPrepare()\n\x09pushAbort(\&#34;taskFinished()\&#34;)\n\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09pushAbort(\&#34;getLocks({})\&#34;)\n\x09addStage(\&#34;getLocks({[&#39;BCMS-TOPOLOGY&#39;] = false})\&#34;)\n\n\x09pushAbort(\&#34;abortMVFY()\&#34;)\n\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STARTING)\&#34;)\n\x09for _,targetCMS in pairs(cmsList) do\n\x09\x09addStage(\&#34;stopAction(\&#34;..targetCMS..\&#34;,&#39;MVFY&#39;,gtActPc)\&#34;)\n\x09end\n\x09\n\x09for _,targetCMS in pairs(cmsList) do\n\x09\x09addStage(\&#34;startAction(\&#34;..targetCMS..\&#34;,&#39;MVFY&#39;,gtActPc)\&#34;)\n\x09end\n\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_VERIFY_LOCATIONS)\&#34;)\n\x09addStage(\&#34;waitDone(cmsList, &#39;MVFY&#39;, gtActPc)\&#34;)\n\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_FINISHING)\&#34;)\n\x09for _,targetCMS in pairs(cmsList) do\n\x09\x09addStage(\&#34;stopAction(\&#34;..targetCMS..\&#34;,&#39;MVFY&#39;,gtActPc)\&#34;)\n\x09end\n\n\x09addStage(\&#34;getLocks({})\&#34;)\n\x09popAbort() -- RLOK\n\x09popAbort() -- abortMVFY()\n\x09popAbort()\n\x09\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n\x09addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\n\x09gtActPc = AtomContainer.new{&#39;AAPC&#39;}\n\x09cmsList = actorsToList(&#39;BCMS&#39;)\nend\n"></atom>
			</container>
			<container name="MVFY">
				<atom name="0001" type="CSTR" value="-- CMS Metadata Background Verification Task\n-- Version 1\n\n\nfunction abortMVFY()\n\x09-- Helper function to clean up a verification task\n\x09local res,reas\n\n\x09Debug.log(\&#34;warn\&#34;,\&#34;Stopping CMS actions\&#34;)\n\x09res,reas = stopAction(gtTargetCMS,&#39;MVFY&#39;,gtActPc)\n\x09if(res ~= 1) then\n\x09\x09return 0,reas\n\x09else\n\x09\x09return 1,\&#34;OK\&#34;\n\x09end\nend\n\nfunction gtPrepare()\n\x09-- Called once, the first time that the task is run. \n\x09\n\x09local targetCMS = gtTargetCMS\n\n\x09pushAbort(\&#34;taskFinished()\&#34;)\n\x09\n\x09pushAbort(\&#34;abortMVFY()\&#34;)\n\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09pushAbort(\&#34;getLocks({})\&#34;)\n\x09addStage(\&#34;getLocks({[&#39;\&#34;..targetCMS..\&#34;-STORAGE&#39;] = true})\&#34;)\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STARTING)\&#34;)\n\x09addStage(\&#34;stopAction(\&#34;..gtTargetCMS..\&#34;,&#39;MVFY&#39;,gtActPc)\&#34;)\n\x09\n\x09addStage(\&#34;startAction(\&#34;..gtTargetCMS..\&#34;,&#39;MVFY&#39;,gtActPc)\&#34;)\n\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_VERIFY_LOCATIONS)\&#34;)\n\x09addStage(\&#34;waitDone(\&#34;..gtTargetCMS..\&#34;, &#39;MVFY&#39;, gtActPc)\&#34;)\n\x09addStage(\&#34;stopAction(\&#34;..gtTargetCMS..\&#34;,&#39;MVFY&#39;,gtActPc)\&#34;)\n\n\x09addStage(\&#34;getLocks({})\&#34;)\n\x09popAbort() -- RLOK\n\x09\n\x09popAbort() -- abortMVFY()\n\x09\n\x09popAbort()\n\x09\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n\x09addStage(\&#34;taskFinished()\&#34;)\n\x09\n\x09-- FIXME - Save bundle to GTEN.\nend\n\nfunction gtInit()\n\x09-- Called every time that the task is run (first time, as well as after any CMN restart). \n\n\x09gtTargetCMS = taskParams:data(&#39;/NOID&#39;)\n\x09\n\x09startCbid = taskParams:data(&#39;/SBID&#39;)\n\x09endCbid = taskParams:data(&#39;/EBID&#39;)\n\x09\n\x09gtActPc = AtomContainer.new{&#39;AAPC&#39;, NOID = {ui32 = gtTargetCMS}, SBID = {ui64 = startCbid}, EBID = {ui64 = endCbid}}\n\nend\n"></atom>
			</container>
			<container name="NREP">
				<atom name="0001" type="CSTR" value="-- Nodetool repair task\n-- Version 1\n\nfunction abortNREP()\n    -- Helper function to clean up a verification task\n    local res,reas\n\n    Debug.log(\&#34;warn\&#34;,\&#34;Stopping DDS(NREP) actions\&#34;)\n\n    res,reas = stopAction(gtTargetDDSNid,&#39;NREP&#39;,gtActPc)\n\n    if (res ~= 1) then\n        return 0,reas\n    else\n        return 1,\&#34;OK\&#34;\n    end\nend\n\nfunction gtPrepare()\n    pushAbort(\&#34;taskFinished()\&#34;)\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n    pushAbort(\&#34;getLocks({})\&#34;)\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n    locks = \&#34;[&#39;\&#34;..gtTargetDDSNid..\&#34;-NODETOOL&#39;] = true\&#34;\n    addStage(\&#34;getLocks({\&#34;..locks..\&#34;})\&#34;)\n\n    pushAbort(\&#34;abortNREP()\&#34;)\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STARTING)\&#34;)\n    addStage(\&#34;startAction(\&#34;..gtTargetDDSNid..\&#34;,&#39;NREP&#39;,gtActPc)\&#34;)\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_RUNNING_CASSANDRA_NODE_REPAIR)\&#34;)\n    addStage(\&#34;waitDone(gtTargetDDSNid, &#39;NREP&#39;, gtActPc)\&#34;)\n    addStage(\&#34;getLocks({})\&#34;)\n    popAbort() -- RLOK\n    popAbort() -- abortNREP()\n    popAbort()\n    addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n    addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\n    gtTargetDDSNid = taskParams:data(&#39;/NOID&#39;)\n    gtActPc = AtomContainer.new{&#39;AAPC&#39;}\nend\n\n"></atom>
			</container>
			<container name="RNMC">
				<atom name="0001" type="CSTR" value="-- Remove NMS Cluster Bindings\n-- Version 1\n\nfunction unbindCluster(clusterId)\n\x09return executeOnOneActor(&#39;BCMN&#39;, &#39;RNMC&#39;, AtomContainer.new{&#39;AAPC&#39;, NCID = {ui32 = clusterId}})\nend\n\nfunction gtPrepare()\n\x09pushAbort(\&#34;taskFinished()\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09pushAbort(\&#34;getLocks({})\&#34;)\n\x09addStage(\&#34;getLocks({[&#39;GRID-BUNDLE&#39;] = true})\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_BUNDLE_COMMIT)\&#34;)\n\x09\n\x09clusterId = taskParams:data(&#39;/NCID&#39;)\n\x09addStage(\&#34;unbindCluster(\&#34;..clusterId..\&#34;)\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;getLocks({})\&#34;)\n\x09popAbort() -- RLOK\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n\x09addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\nend\n"></atom>
			</container>
			<container name="SWUP">
				<atom name="0001" type="CSTR" value="-- Software Upgrade Task\n-- Version 1\n\nfunction addBundles(path)\n\x09local result = 1\n\x09local reason = OID_GRIDTASK_MSG_NONE\n\x09\n\x09for data in taskParams:datas(path) do\n\x09\x09data:set_name(&#39;AAPC&#39;)\n\x09\x09result,reason = executeOnOneActor(&#39;BCMN&#39;, &#39;BDLI&#39;, data)\n\x09\x09if(result ~= 1) then\n\x09\x09\x09Debug.log(\&#34;warn\&#34;,\&#34;Exiting bundle-import loop, reason =\&#34;,reason)\n\x09\x09\x09break\n\x09\x09end\n\x09end\n\n\x09return result,reason\nend\n\nfunction commitBundles(path)\n\x09local result = 1\n\x09local reason = OID_GRIDTASK_MSG_NONE\n\x09\n\x09for data in taskParams:datas(path) do\n\x09\x09data:set_name(&#39;AAPC&#39;)\n\x09\x09result,reason = executeOnOneActor(&#39;BCMN&#39;, &#39;BCMT&#39;, data)\n\x09\x09if(result ~= 1) then\n\x09\x09\x09Debug.log(\&#34;warn\&#34;,\&#34;Exiting bundle-commit loop, reason =\&#34;,reason)\n\x09\x09\x09break\n\x09\x09end\n\x09end\n\n\x09return result,reason\nend\n\nfunction preloadResources(nodeType, version, update)\n\x09return executeOnActors(nodeType, &#39;ARPL&#39;,\n\x09\x09AtomContainer.new{&#39;AAPC&#39;, NVER = {ui32 = version}, UPDT = taskParams:data(update)})\nend\n\nfunction unloadResources(nodeType)\n\x09return executeOnActors(nodeType, &#39;ARUL&#39;, AtomContainer.new{&#39;AAPC&#39;})\nend\n\nfunction waitUnloadResources(nodeType)\n\x09local function checkDone(nid, status)\n\x09\x09return status:data(\&#34;STAT\&#34;) == \&#34;NFND\&#34;\n\x09end\n\x09\n\x09return waitOnActors(nodeType, &#39;CRUL&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone)\nend\n\nfunction waitVersion(path, adeVersion, cmsVersion)\n\x09local function checkDone(nid, status, node)\n\x09\x09local version = adeVersion\n\x09\x09if node:data(\&#34;DTYP\&#34;) == &#39;BCMS&#39; then\n\x09\x09\x09version = cmsVersion\n\x09\x09end\n\x09\x09return status:data(\&#34;VERS\&#34;) &gt;= version\n\x09end\n\x09\n\x09return waitOnIncompleteActors(path, &#39;BALL&#39;, &#39;CSWV&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone)\nend\n\nfunction clearCache(path)\n\x09gtInfoCache:clear(path)\n\x09updateInfo()\n\x09return 1, OID_GRIDTASK_MSG_NONE\nend\n\n-- ------------------------------------------------------------------------------\n-- Helper function to create an atom container populated with the list of nodes\n-- requested in actorTable, which may be \&#34;BALL\&#34; to request all nodes.\n-- ------------------------------------------------------------------------------\n--  2010-04-12 KJ : Updated\n-- ------------------------------------------------------------------------------\nfunction actorTableToContainer(actorTable)\n\x09local container = AtomContainer.new{&#39;NODS&#39;}\n\x09\n\x09if actorTable == \&#34;BALL\&#34; then\n\x09\x09local nodeTypes = {&#39;BADC&#39;, &#39;BLDR&#39;, &#39;BCMS&#39;, &#39;BNMS&#39;, &#39;BAMS&#39;, &#39;BSSM&#39;, &#39;BCLB&#39;, &#39;BCMN&#39;, &#39;BARC&#39;}\n\x09\x09local i = 1\n\x09\x09for _, nodeType in pairs(nodeTypes) do\n\x09\x09\x09local nodes = actorsToList(nodeType)\n\x09\x09\x09for _,nid in pairs(nodes) do\n\x09\x09\x09\x09local path = string.format(\&#34;%04X\&#34;, i)\n\x09\x09\x09\x09container:set_ui32(path..\&#34;/NOID\&#34;, nid)\n\x09\x09\x09\x09container:set_fc32(path..\&#34;/DTYP\&#34;, nodeType)\n\x09\x09\x09\x09i = i + 1\n\x09\x09\x09end\n\x09\x09end\n\x09else\n\x09\x09local nodes = actorsToList(actorTable)\n\x09\x09local i = 1\n\x09\x09for _,nid in pairs(nodes) do\n\x09\x09\x09local path = string.format(\&#34;%04X\&#34;, i)\n\x09\x09\x09container:set_ui32(path..\&#34;/NOID\&#34;, nid)\n\x09\x09\x09i = i + 1\n\x09\x09end\n\x09end\n\x09\n\x09return container\nend\n\n-- ------------------------------------------------------------------------------\n-- Helper function similar to waitOnActors() to wait for a check on all members\n-- of a specified table of actors to meet some condition.\n-- Unlike waitOnActors(), this function does not re-check any actors that have\n-- successfully completed the check (through caching of the list of actors).\n-- ------------------------------------------------------------------------------\n--  2010-04-12 KJ : Updated\n-- ------------------------------------------------------------------------------\nfunction waitOnIncompleteActors(actorCachePath, actorTable, checkType, checkPc, checkDoneFn, abortOnError)\n\x09-- Load or create the cached container of nodes\n\x09local actorCont = cacheLoad(actorCachePath) or actorTableToContainer(actorTable)\n\x09local done = true\n\x09local totN = UINT64.new(0)\n\x09local totD = UINT64.new(0)\n\x09\n\x09for nodeCont in actorCont:datas() do\n\x09\x09local nid = nodeCont:data(&#39;NOID&#39;)\n\x09\x09local nodeDone = nodeCont:data(&#39;DONE&#39;)\n\x09\x09local nodeN = nodeCont:data(&#39;NODN&#39;) or 0\n\x09\x09local nodeD = nodeCont:data(&#39;NODD&#39;) or 1\n\x09\x09\n\x09\x09if nodeDone then\n\x09\x09\x09-- Skip any node on which the check has already been completed\n\x09\x09\x09Debug.log(\&#34;info\&#34;,\&#34;Check\&#34;, checkType, \&#34;on node\&#34;, nid, \&#34;already done\&#34;, \&#34;progress\&#34;, nodeN, \&#34;/\&#34;, nodeD)\n\x09\x09else\n\x09\x09\x09local resp = postCheckAsk(nid, checkType, checkPc)\n\x09\x09\n\x09\x09\x09if resp:data(&#39;/RSLT&#39;) == &#39;SUCS&#39; then\n\x09\x09\x09\x09nodeDone, nodeN, nodeD = checkDoneFn(nid, resp:data(&#39;/CSTC&#39;), nodeCont)\n\x09\x09\x09\x09nodeN = nodeN or ((nodeDone and 1) or 0)\n\x09\x09\x09\x09nodeD = nodeD or 1\n\x09\x09\x09\x09\n\x09\x09\x09\x09Debug.log(\&#34;info\&#34;,\&#34;Check\&#34;, checkType, \&#34;on node\&#34;, nid, \&#34;done\&#34;, nodeDone, \&#34;progress\&#34;, nodeN, \&#34;/\&#34;, nodeD)\n\x09\x09\x09\x09\n\x09\x09\x09\x09if nodeDone then\n\x09\x09\x09\x09\x09actorCont:set_ui32(nodeCont:name()..&#39;/DONE&#39;, 1)\n\x09\x09\x09\x09end\n\x09\x09\x09\x09\n\x09\x09\x09\x09actorCont:set_ui64(nodeCont:name()..&#39;/NODN&#39;, nodeN)\n\x09\x09\x09\x09actorCont:set_ui64(nodeCont:name()..&#39;/NODD&#39;, nodeD)\n\x09\x09\x09else\n\x09\x09\x09\x09Debug.log(\&#34;warn\&#34;,\&#34;Check\&#34;, checkType, \&#34;failed on node\&#34;, nid)\n\x09\x09\x09end\n\x09\x09end\n\x09\x09\n\x09\x09done = done and nodeDone\n\x09\x09totN = totN + nodeN\n\x09\x09totD = totD + nodeD\n\x09end\n\x09\n\x09Debug.log(\&#34;info\&#34;,\&#34;Overall check\&#34;, checkType, \&#34;done\&#34;, done, \&#34;progress\&#34;, totN, \&#34;/\&#34;, totD)\n\x09\n\x09-- Update NMS attributes\n\x09stageReport(gtStageString, totN, totD)\n\x09\n\x09-- Update the cached data table\n\x09gtInfoCache:clear(actorCachePath)\n\x09cacheStore(actorCachePath, actorCont)\n\x09\n\x09if(not done) then\n\x09\x09if(abortOnError) then\n\x09\x09\x09return 0, OID_GRIDTASK_MSG_WAITING\n\x09\x09end\n\x09\x09return 4, \&#34;Again\&#34;\n\x09end\n\n\x09return 1, \&#34;OK\&#34;\nend\n\nfunction gtPrepare()\n\x09--FIXME: is some kind of pre-check necessary?\n\n\x09pushAbort(\&#34;taskFinished()\&#34;)\n\n\x09local adeVersion = taskParams:data(\&#34;NAVR\&#34;)\n\x09local cmsVersion = taskParams:data(\&#34;NCVR\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09pushAbort(\&#34;getLocks({})\&#34;)\n\x09addStage(\&#34;getLocks({[&#39;GRID-UPGRADE&#39;] = true})\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_RESOURCE_PRELOAD)\&#34;)\n\x09\n\x09for node in taskParams:datas(\&#34;/RUPD\&#34;) do\n\x09\x09local nodeType = node:name()\n\x09\x09local update = \&#34;/RUPD/\&#34;..nodeType..\&#34;/UPDT\&#34;\n\x09\x09\n\x09\x09addStage(\&#34;getLocks({[&#39;GRID-UPGRADE&#39;] = true, [&#39;\&#34;..nodeType..\&#34;-RESOURCES&#39;] = true})\&#34;)\n\x09\x09pushAbort(\&#34;unloadResources(&#39;\&#34;..nodeType..\&#34;&#39;)\&#34;)\n\x09\x09addStage(\&#34;preloadResources(&#39;\&#34;..nodeType..\&#34;&#39;,\&#34;..adeVersion..\&#34;,&#39;\&#34;..update..\&#34;&#39;)\&#34;)\n\x09end\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_BUNDLE_IMPORT..&#39; 1&#39;)\&#34;)\n\x09addStage(\&#34;getLocks({[&#39;GRID-UPGRADE&#39;] = true, [&#39;GRID-BUNDLE&#39;] = true})\&#34;)\n\x09addStage(\&#34;addBundles(&#39;/BDL1&#39;)\&#34;)\n\x09addStage(\&#34;getLocks({[&#39;GRID-UPGRADE&#39;] = true})\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_VERSION_WAIT)\&#34;)\n\x09addStage(\&#34;waitVersion(&#39;NODS&#39;, \&#34;..adeVersion..\&#34;,\&#34;..cmsVersion..\&#34;)\&#34;)\n\x09addStage(\&#34;clearCache(&#39;NODS&#39;)\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_RESOURCE_UNLOAD_WAIT)\&#34;)\n\x09\n\x09for node in taskParams:datas(\&#34;/RUPD\&#34;) do\n\x09\x09local nodeType = node:name()\n\x09\x09\n\x09\x09addStage(\&#34;waitUnloadResources(&#39;\&#34;..nodeType..\&#34;&#39;)\&#34;)\n\x09end\n\n\x09--------------------------------------------------------------------------------\n\x09for node in taskParams:datas(\&#34;/RUPD\&#34;) do\n\x09\x09popAbort()\n\x09end\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_BUNDLE_COMMIT)\&#34;)\n\x09addStage(\&#34;getLocks({[&#39;GRID-UPGRADE&#39;] = true, [&#39;GRID-BUNDLE&#39;] = true})\&#34;)\n\x09addStage(\&#34;commitBundles(&#39;/BCMT&#39;)\&#34;)\n\x09\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_BUNDLE_IMPORT..&#39; 2&#39;)\&#34;)\n\x09addStage(\&#34;addBundles(&#39;/BDL2&#39;)\&#34;)\n\x09--------------------------------------------------------------------------------\n\x09-- Transfer S3 Accounts from S3AC bundle to Account Server\n\x09addStage(\&#34;getLocks({[&#39;GRID-UPGRADE&#39;] = true})\&#34;)\n\x09-- Use first DDS, as only a single DDS needs to run this task.\n\x09local targetDdsNid = taskParams:data(\&#34;TDDS\&#34;)\n\x09addStage(\&#34;startAction(\&#34;..targetDdsNid..\&#34;, &#39;TS3A&#39;, AtomContainer.new{&#39;AAPC&#39;})\&#34;)\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_TRANSFER_S3_ACCOUNTS)\&#34;)\n\x09addStage(\&#34;waitDone(\&#34;..targetDdsNid..\&#34;, &#39;TS3A&#39;, AtomContainer.new{&#39;AAPC&#39;})\&#34;)\n\n\x09--------------------------------------------------------------------------------\n\x09addStage(\&#34;getLocks({})\&#34;)\n\x09popAbort() -- RLOK\n\x09\n\x09--------------------------------------------------------------------------------\n\x09popAbort()\n\x09\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n\x09addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\nend\n"></atom>
			</container>
			<container name="UFLT">
				<atom name="0001" type="CSTR" value="-- Update Flags Task\n-- Version 1\n\n\nfunction updateNodeResources(nid, update)\n\x09return executeOnActor(nid, &#39;UPRE&#39;,\n\x09\x09AtomContainer.new{&#39;AAPC&#39;, UPDT = taskParams:data(update)})\nend\n\nfunction shutdownNode(nid)\n\x09local resp = postCheckAsk(nid, &#39;CSTT&#39;, AtomContainer.new{&#39;CHPC&#39;})\n\n\x09if(resp:data(&#39;/RSLT&#39;) == &#39;SUCS&#39;) then\n\x09\x09initTime = resp:data(&#39;/CSTC/CSTT&#39;)\n\x09\x09cacheStore(\&#34;ITME\&#34;, initTime)\n\x09else\n\x09     return 0,\&#34;Error\&#34;\n\x09end\n\n\x09return executeOnActor(nid, &#39;SHDN&#39;, AtomContainer.new{&#39;AAPC&#39;, DELY = {ui64 = 1000000 }})\n\nend\n\nfunction checkRestartTime(nid)\n\x09local function checkDone(nid, status)\n\x09\x09-- TODO This assumes monotonically increasing clock after node restart, which isn&#39;t guaranteed\n\x09\x09return initTime &lt; status:data(\&#34;CSTT\&#34;)\n\x09end\n\x09return waitOnActors(nid, &#39;CSTT&#39;, AtomContainer.new{&#39;CHPC&#39;}, checkDone, true)\nend\n\nfunction executeUPDT(nid, update, restart)\n\x09numNodes = numNodes + 1\n\x09\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_RESOURCE_UPDATE..&#39; (\&#34;..numNodes..\&#34;/&#39;..numNodes..&#39;): &#39;..OID_GRIDTASK_MSG_NID..&#39; \&#34;..nid..\&#34;&#39;)\&#34;)\n\x09addStage(\&#34;updateNodeResources(&#39;\&#34;..nid..\&#34;&#39;,&#39;\&#34;..update..\&#34;&#39;)\&#34;)\n\x09\n\x09if (restart == 1) then\n\x09\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_RESOURCE_UPDATE..&#39; (\&#34;..numNodes..\&#34;/&#39;..numNodes..&#39;): &#39;..OID_GRIDTASK_MSG_NID..&#39; \&#34;..nid..\&#34;&#39;)\&#34;)\n\x09\x09addStage(\&#34;shutdownNode(&#39;\&#34;..nid..\&#34;&#39;)\&#34;)\n\x09\x09\n\x09\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_RESTART_WAIT..&#39; (\&#34;..numNodes..\&#34;/&#39;..numNodes..&#39;): &#39;..OID_GRIDTASK_MSG_NID..&#39; \&#34;..nid..\&#34;&#39;)\&#34;)\n\x09\x09addStage(\&#34;checkRestartTime(&#39;\&#34;..nid..\&#34;&#39;)\&#34;)\n\x09end\nend\n\nfunction gtPrepare()\n\n\x09pushAbort(\&#34;taskFinished()\&#34;)\n\n\x09-------------------------------------------------------------------------\n\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n\x09pushAbort(\&#34;getLocks({})\&#34;)\n\x09\n\x09-------------------------------------------------------------------------\n\x09for node in taskParams:datas(\&#34;/UFLT\&#34;) do\n\x09\x09local nodeType = node:name()\n\x09\x09local update = \&#34;/UFLT/\&#34;..nodeType..\&#34;/UPDT\&#34;\n\x09\x09local restart = node:data(\&#34;REST\&#34;)\n\x09\x09local targets = node:data(\&#34;TRGT\&#34;)\n\n\x09\x09for name,_,value in targets:tuples() do\n\x09\x09\x09if (name == \&#34;NTYP\&#34;) then\n\x09\x09\x09\x09addStage(\&#34;getLocks({[&#39;\&#34;..value..\&#34;-RESOURCES&#39;] = true})\&#34;)\n\x09\x09\n\x09\x09\x09\x09if(restart == 1) then\n\x09\x09\x09\x09\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_RESOURCE_UPDATE)\&#34;)\n\x09\x09\x09\x09\x09addStage(\&#34;waitUser(OID_GRIDTASK_MSG_UFLTWAIT_TYPE..&#39; \&#34;..value..\&#34;&#39;)\&#34;)\n\x09\x09\x09\x09end\n\x09\x09\x09\x09\n\x09\x09\x09\x09local nodes = actorsToList(value)\n\x09\x09\x09\x09table.sort(nodes)\x09-- As of 8.2, this task is specified to process nodes in ascending numerical NID order\n\x09\x09\x09\x09for _,nid in pairs(nodes) do\n\x09\x09\x09\x09\x09executeUPDT(nid, update, restart)\n\x09\x09\x09\x09end\n\x09\x09\x09elseif (name == \&#34;NOID\&#34;) then\n\x09\x09\x09\x09if(restart == 1) then\n\x09\x09\x09\x09\x09addStage(\&#34;stageName(OID_GRIDTASK_STAGE_RESOURCE_UPDATE)\&#34;)\n\x09\x09\x09\x09\x09addStage(\&#34;waitUser(OID_GRIDTASK_MSG_UFLTWAIT_NODE..&#39; \&#34;..value..\&#34;&#39;)\&#34;)\n\x09\x09\x09\x09end\n\x09\x09\x09\x09\n\x09\x09\x09\x09executeUPDT(value, update, restart)\n\x09\x09\x09end\n\x09\x09end\n\x09end\n\x09-------------------------------------------------------------------------\n\x09addStage(\&#34;getLocks({})\&#34;)\n\x09popAbort() -- RLOK\n\x09\n\x09-------------------------------------------------------------------------\n\x09popAbort()\n\x09addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n\x09addStage(\&#34;taskFinished()\&#34;)\n\x09\n\x09cacheStore(\&#34;NUMN\&#34;, numNodes)\nend\n\n\nfunction gtInit()\n\x09-- Count the number of nodes to be updated, for status reporting\n\x09numNodes = cacheLoad(\&#34;NUMN\&#34;) or 0\n\x09\n\x09-- Last init time for node restart check\n\x09initTime = cacheLoad(\&#34;ITME\&#34;) or UINT64.new(0)\nend\n"></atom>
			</container>
			<container name="VFGV">
				<atom name="0001" type="CSTR" value="-- Volume Foreground Verification Task\n-- Version 1\n\n\nfunction abortVFGV()\n    -- Helper function to clean up a verification task\n    local res,reas\n\n    Debug.log(\&#34;warn\&#34;,\&#34;Stopping VFGV actions\&#34;)\n    for _,nid in pairs(cmnList) do\n\n        res,reas = stopAction(nid,&#39;VFGV&#39;,gtActPc)\n        if(res ~= 1) then\n            return 0,reas\n        end\n    end\n\n    if (res ~= 1) then\n        return 0,reas\n    else\n        return 1,\&#34;OK\&#34;\n    end\nend\n\nfunction resetAttributes(nid)\n    return executeOnActor(nid, &#39;SVRA&#39;, gtActPc)\nend\n\nfunction gtPrepare()\n    -- Called once, the first time that the task is run.\n    pushAbort(\&#34;taskFinished()\&#34;)\n    for ldr in taskParams:datas(&#39;/SLDR&#39;) do\n        pushAbort(\&#34;resetAttributes(\&#34;..ldr..\&#34;)\&#34;)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_LOCKS_WAIT)\&#34;)\n    pushAbort(\&#34;getLocks({})\&#34;)\n    addStage(\&#34;getLocks({[&#39;GRID-FGV&#39;] = true})\&#34;)\n\n    pushAbort(\&#34;abortVFGV()\&#34;)\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_STARTING)\&#34;)\n\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\&#34;startAction(\&#34;..targetCMN..\&#34;,&#39;VFGV&#39;,gtActPcStart)\&#34;)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_DESC_LDR_VERIFY)\&#34;)\n    addStage(\&#34;waitDone(cmnList, &#39;VFGV&#39;, gtActPcCheck)\&#34;)\n\n    addStage(\&#34;stageName(OID_GRIDTASK_STAGE_FINISHING)\&#34;)\n    for _,targetCMN in pairs(cmnList) do\n        addStage(\&#34;stopAction(\&#34;..targetCMN..\&#34;,&#39;VFGV&#39;,gtActPc)\&#34;)\n    end\n\n    addStage(\&#34;stageName(OID_GRIDTASK_ACTION_VERIFY_ATTR_RESET)\&#34;)\n    for ldr in taskParams:datas(&#39;/SLDR&#39;) do\n        addStage(\&#34;resetAttributes(\&#34;..ldr..\&#34;)\&#34;)\n    end\n\n    addStage(\&#34;getLocks({})\&#34;)\n    popAbort() -- RLOK\n    popAbort() -- abortVFGV()\n    for ldr in taskParams:datas(&#39;/SLDR&#39;) do\n        popAbort() -- resetAttributes\n    end\n\n    popAbort()\n\n    addStage(\&#34;stageReport(OID_GRIDTASK_MSG_DONE, 1, 1)\&#34;)\n    addStage(\&#34;taskFinished()\&#34;)\nend\n\nfunction gtInit()\n    -- Called every time that the task is run (first time, as well as after any CMN restart).\n\n    gtActPc = AtomContainer.new{&#39;AAPC&#39;}\n    cmnList = actorsToList(&#39;BCMN&#39;, true)\n\n    local idx = 1\n    local noidTable = {}\n    local volIdTable = {}\n\n    for ldr in taskParams:datas(&#39;/SLDR&#39;) do\n        table.insert(noidTable, ldr)\n    end\n    for vid in taskParams:datas(&#39;/SVOL&#39;) do\n        table.insert(volIdTable, vid)\n    end\n\n    if (table.getn(noidTable) ~= table.getn(volIdTable)) then\n        Debug.log(\&#34;err\&#34;,\&#34;Noid and VolId pair does not match\&#34;)\n    end\n\n    local atomTableStart = {}\n    local atomTableCheck = {}\n    atomTableStart[1] = &#39;AAPC&#39;\n    atomTableCheck[1] = &#39;CHPC&#39;\n    for key,noid in ipairs(noidTable) do\n        local idxStr = string.format(\&#34;%04X\&#34;, idx)\n        local volId = volIdTable[key]\n        atomTableStart[idxStr] = AtomContainer.new{idxStr, NOID={ui32 = noid}, VOID ={ui64 = volId}}\n        atomTableCheck[idxStr] = AtomContainer.new{idxStr, NOID={ui32 = noid}, VOID ={ui64 = volId}}\n        idx = idx + 1\n    end\n\n    gtActPcStart = AtomContainer.new(atomTableStart)\n    gtActPcCheck = AtomContainer.new(atomTableCheck)\nend\n"></atom>
			</container>
		</container>
	</container>
</containerxml>
